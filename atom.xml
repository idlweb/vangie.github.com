<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Code Life]]></title>
  <link href="http://codelife.me/atom.xml" rel="self"/>
  <link href="http://codelife.me/"/>
  <updated>2014-08-31T09:28:28+08:00</updated>
  <id>http://codelife.me/</id>
  <author>
    <name><![CDATA[Vangie Du]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[实时web的4种实现方式]]></title>
    <link href="http://codelife.me/blog/2014/08/16/4-ways-to-implement-real-time-web/"/>
    <updated>2014-08-16T20:34:05+08:00</updated>
    <id>http://codelife.me/blog/2014/08/16/4-ways-to-implement-real-time-web</id>
    <content type="html"><![CDATA[<blockquote><p>随着互联网的飞速发展，我们在网页里完成越来越多的事情。Web应用程序开始逐渐替代传统的桌面程序，然而HTTP协议设计之初没有考虑到面向应用开发的需求，HTTP协议服务端只能被动的响应客户端（浏览器）的请求，若服务端需要实时的给客户端推送消息，HTTP协议就需要借助与轮询和长连接等变通的技术。这些技术虽然勉强能够实现，但是都有些弊端。直到websocket协议推出，才真正的意义上解决了实时数据传输问题。但是由于旧版本浏览器不兼容websocket协议，为了更好的向下兼容，社区遍有了socket.io框架，该框架能智能识别浏览器端对websocket的支持情况，对于不支持的旧版本浏览器采用长轮询的方式通讯。本文将讨论4中常见的实时Web通讯技术。</p></blockquote>

<!-- more -->


<h3>轮询（Polling）</h3>

<p><img src="http://codelife.me/images/post/2014-08-16/polling.png" alt="轮询" /></p>

<p>浏览器端连续发送请求以寻求新信息，服务端收到请求立即响应，无论请求的新信息是否已经就绪。此方式适用场景要求轮询的时间间隔相对宽松。例如，邮件客户端通常10分钟连接一次服务器检测是否有新邮件。</p>

<p>轮询简单而且易于实现。然而如果对实时的要求提高，提升轮询的频率，这种方式就会变得低效。</p>

<h3>长轮询 （Long Polling）</h3>

<p><img src="http://codelife.me/images/post/2014-08-16/long_polling.png" alt="长轮询" /></p>

<p>浏览器端连续发送请求，但是服务端并不立即响应，而是等待请求的资源准备好了才发送响应给客户端。从客户端的角度来看，和普通的轮询没有区别。从服务端的角度看这非常类似于长请求。</p>

<p>那响应端口能保持多久不关闭呢？通常浏览器被设置成5分钟超时，若网络中间存在代理超时间隔可能更短。因此即使没有新消息需要发送，长轮询请求也需要周期性的完成，以触发浏览器重新发送一个新请求。这篇 <a href="http://tools.ietf.org/html/rfc6202" title="Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP">IETF 文档</a>建议超时设置成30~120秒，但是真实值如何设置依赖于你对服务器和客户端之间的网络设备的控制程度。</p>

<p>长轮询能显著的降低请求数并保持响应的低延时，尤其是新消息以不规则的频率产生时。然而信息产生过于频繁，长轮询将接近于普通轮询。</p>

<h3>流推送 （Streaming）</h3>

<p><img src="http://codelife.me/images/post/2014-08-16/streaming.png" alt="流推送" /></p>

<p>浏览器端连续发送请求，当服务端有新消息时响应请求。然后不同于长轮询，服务端保持响应端口不关闭，持续发送当更多的消息到达时。这种方式不需要轮询，但是它也背离了HTTP请求响应模式的语义。例如客户端和服务端需要协调如何解释响应流，客户端可以知道两个连续消息的分割边界。而且，网络中间设备对响应的缓存会让这种方式失效。这就是为何长轮询使用的更普遍。</p>

<h3>WebSocket</h3>

<p><img src="http://codelife.me/images/post/2014-08-16/websocket.png" alt="WebSocket" /></p>

<p>浏览器发送一个HTTP 升级首部请求，服务端确认升级，HTTP协议升级为WebSocket协议。此后浏览器和服务器可以在TCP Socket之上双向的发送数据帧。</p>

<p>WebSocket协议被设计用来替换轮询机制，它非常适合服务端和客户端需要高频率的双向交换数据的场景。初始的基于HTTP协议的握手确保WebSocket请求可以穿透防火墙。然后，最大的挑战是仍然后很多遗留的浏览器不支持该协议。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">Spring MVC 3.2 Preview: Techniques for Real-time Updates</a></li>
<li><a href="http://www.slideshare.net/yongboy/real-time-web-14045690">Real time web实时信息流推送</a></li>
<li><a href="http://tools.ietf.org/html/rfc6202" title="Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP">Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP</a></li>
<li><a href="http://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header">HTTP/1.1 Upgrade header</a></li>
<li><a href="http://en.wikipedia.org/wiki/WebSocket">WebSocket</a></li>
<li><a href="https://www.websocket.org/aboutwebsocket.html">About HTML5 WebSockets</a></li>
<li><a href="https://github.com/automattic/socket.io-protocol">Socket.IO 1.0 Protocol</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS X下如何分卷压缩]]></title>
    <link href="http://codelife.me/blog/2014/07/15/how-to-create-split-zipped-archives-in-macosx/"/>
    <updated>2014-07-15T21:22:06+08:00</updated>
    <id>http://codelife.me/blog/2014/07/15/how-to-create-split-zipped-archives-in-macosx</id>
    <content type="html"><![CDATA[<blockquote><p>一朋友的公司邮箱只能接受5M的附件，还世界500强企业真心落后。无奈只能分卷压缩大文件，Mac OS X下没有盗版的WinRar可用，所以只好采用ZIP格式分卷了</p></blockquote>

<h3>创建分卷压缩文件</h3>

<h4>将目录分卷压缩</h4>

<pre><code>zip -s 100m -x "*.DS_Store" -r split-foo.zip foo/
</code></pre>

<ul>
<li><code>-s</code> 切分单元的大小，可选的单位有k(kB), m(MB), g(GB), t(TB),默认为m</li>
<li><code>-r</code> 或者 <code>--recurse-paths</code> 递归目录</li>
<li><code>-x</code> 或者 <code>--exclude</code> 忽略文件</li>
</ul>


<h4>切分已有zip文件</h4>

<pre><code>zip existing.zip --out new.zip -s 50m
</code></pre>

<p>将创建</p>

<blockquote><p>new.zip <br/>
new.z01   <br/>
new.z02 <br/>
new.z03 <br/>
&hellip;</p></blockquote>

<!-- more -->


<h3>解压分卷压缩文件</h3>

<p>还原分为两步</p>

<p>1.将切分文件合并成单一zip文件</p>

<pre><code>zip -s 0 split.zip --out single.zip
</code></pre>

<ul>
<li><code>-s 0</code> 表示合并</li>
</ul>


<p>2.解压</p>

<pre><code>unzip single.zip 
</code></pre>

<h3>参考文献</h3>

<ol>
<li><a href="http://superuser.com/questions/336219/how-do-i-split-a-zip-file-into-multiple-segments">How do I split a .zip file into multiple segments?</a></li>
<li><a href="http://www.addictivetips.com/mac-os/how-to-create-a-split-zipped-archive-from-mac-os-x-terminal/">How To Create A Split Zipped Archive From Mac OS X Terminal</a></li>
<li><a href="http://apple.stackexchange.com/questions/12371/how-can-i-compress-a-folder-into-multiple-zip-files">How can I compress a folder into multiple zip files?</a></li>
<li><a href="http://notepad2.blogspot.jp/2012/12/mac-os-x-createextract-split-zip.html">Mac OS X: create/extract split zip archives</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在OS X Mavericks上安装gdb]]></title>
    <link href="http://codelife.me/blog/2014/07/14/install-gdb-on-osx-mavericks/"/>
    <updated>2014-07-14T00:19:21+08:00</updated>
    <id>http://codelife.me/blog/2014/07/14/install-gdb-on-osx-mavericks</id>
    <content type="html"><![CDATA[<blockquote><p>最近帮外甥女写一段C程序作业。代码量不多，所有采用Sublime Text + gcc的方式。遇到了奇怪的<code>segmentation fault</code>,没有显示具体错误行号，所有需要借助gdb(The GNU Project Debugger 是*nix环境下著名的调试程序)返回更多有效信息和断点调试。</p></blockquote>

<h3>安装</h3>

<pre><code>brew install gdb
</code></pre>

<h3>开启调试编译选项</h3>

<p>希望gdb调试时输出行号与堆栈等详细信息需要<code>gcc</code>编译的时候使用<code>-g</code>选项</p>

<pre><code>gcc -o course_test -g -rdynamic course_test.c
</code></pre>

<p>注意 homebrew安装的gnu版本的<code>gcc</code>在macox上不支持<code>-rdynamic</code>选项，此处使用的是xcode提供的<code>gcc</code>。</p>

<!-- more -->


<h3>调试</h3>

<pre><code>bash$ gdb course_test
gdb&gt;run
....
The GDB command:
„-exec-run“ returned the error:
„,msg=„Unable to find Mach task port for process-id 62593:
(os/kern) failure (0x5). (please check gdb is codesigned - see taskgated(8))““
</code></pre>

<p>不出意外将会遇到上述错误。这是由于macos的安全策略，homebrew安装的gdb没有签名导致。</p>

<h3>签名gdb</h3>

<ol>
<li>打开 “钥匙串访问”，位于<code>/Applications/Utilities/Keychain Access.app</code></li>
<li>打开菜单 /钥匙串访问/证书助理/创建证书&hellip;</li>
<li>在&#8221;创建您的证书&#8221;窗口设置如下

<ul>
<li>名称: gdbc</li>
<li>身份类型: 自签名根证书</li>
<li>证书类型: 代码签名</li>
<li>勾选&#8221;让我覆盖这些默认值&#8221;</li>
</ul>
</li>
<li>点击&#8221;继续&#8221;，将&#8221;有效期（天数）&#8221;设置为: 3650</li>
<li>点击若干次&#8221;继续&#8221;，指导出现&#8221;指定用于该证书的位置&#8221;&#8221;

<ul>
<li>钥匙串: 系统</li>
</ul>
</li>
<li>点击&#8221;创建&#8221;，会弹出用户名密码输入框，输入密码，点击&#8221;修改钥匙串&#8221;</li>
<li>在“系统”钥匙串找到刚才创建的&#8221;gdbc&#8221;证书，右键&#8221;显示简介&#8221;，在“信任”分类下找到“代码签名”，指定为“总是信任”。</li>
<li>退出“钥匙串访问”</li>
</ol>


<p>要让刚刚添加的证书生效需要重启<code>taskgated</code>服务或者重启系统</p>

<pre><code>sudo killall taskgated
</code></pre>

<p>证书准备好了，接下来给gdb签名</p>

<pre><code>codesign -fs gdbc /usr/local/bin/gdb
</code></pre>

<h3>lldb</h3>

<p>即使给签名gdb以后，在执行gdb调试仍然无法显示行号（行号显示为 ??），新版本的macox已经和gdb不兼容了，lldb是gdb的替代者。使用lldb调试可以显示错误发生位置的行号。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://blog.panks.me/posts/2013/11/install-gdb-on-os-x-mavericks-from-source/">Install GDB on OS X Mavericks from source</a></li>
<li><a href="http://wiki.lazarus.freepascal.org/GDB_on_OS_X_Mavericks_and_Xcode_5">GDB on OS X Mavericks and Xcode 5</a></li>
<li><a href="http://stackoverflow.com/questions/13913818/how-to-get-a-codesigned-gdb-on-osx">How to get a “codesigned” gdb on OSX?</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当元素滚动出可视区域后固定漂浮在底部]]></title>
    <link href="http://codelife.me/blog/2014/06/22/fixed-floating-bottom-when-element-scroll-out-of-client-area/"/>
    <updated>2014-06-22T00:28:05+08:00</updated>
    <id>http://codelife.me/blog/2014/06/22/fixed-floating-bottom-when-element-scroll-out-of-client-area</id>
    <content type="html"><![CDATA[<blockquote><p>页面底部放置了几个功能按钮，当页面长度超过窗口高度时需要滚动到底部才能操作。点击按钮前多了一步滚动操作，多少有些不方便。如果元素位于可视区域之外时，可以固定漂浮于窗口底部就可以解决这种不便。</p></blockquote>

<p><img src="http://codelife.me/images/post/2014-06-22/fixed-floating.png" alt="不在可视区域内时固定漂浮于底部" /></p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="c1">#声明全局top变量，记录元素里页面顶部高度值</span>
</span><span class='line'><span class="nv">top = </span><span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 计算top值</span>
</span><span class='line'><span class="nv">calcTop = </span><span class="nf">-&gt;</span>
</span><span class='line'>  <span class="nv">$ff_container = </span><span class="nx">$</span><span class="p">(</span><span class="s">&#39;form:visible .panel-footer&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="nv">top = </span><span class="nx">$ff_container</span><span class="p">.</span><span class="nx">offset</span><span class="p">().</span><span class="nx">top</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">unless</span> <span class="nx">jQuery</span><span class="p">.</span><span class="nx">browser</span><span class="p">.</span><span class="nx">mobile</span>
</span><span class='line'>    <span class="nx">top</span> <span class="o">+=</span> <span class="nx">$ff_container</span><span class="p">.</span><span class="nx">outerHeight</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 判断是否需要固定漂浮</span>
</span><span class='line'><span class="nv">floating = </span><span class="nf">-&gt;</span>
</span><span class='line'>  <span class="nv">y = </span><span class="nx">$win</span><span class="p">.</span><span class="nx">scrollTop</span><span class="p">()</span> <span class="o">+</span> <span class="nx">$win</span><span class="p">.</span><span class="nx">height</span><span class="p">()</span>
</span><span class='line'>  <span class="nv">$ff_container = </span><span class="nx">$</span><span class="p">(</span><span class="s">&#39;form:visible .panel-footer&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">y</span> <span class="o">&gt;=</span> <span class="nx">top</span>
</span><span class='line'>    <span class="nx">$ff_container</span><span class="p">.</span><span class="nx">removeClass</span><span class="p">(</span><span class="s">&#39;fixed&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="nx">$ff_container</span><span class="p">.</span><span class="nx">addClass</span><span class="p">(</span><span class="s">&#39;fixed&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 窗口滚动时计算是否需要漂浮</span>
</span><span class='line'><span class="nx">$win</span><span class="p">.</span><span class="nx">scroll</span><span class="p">(</span><span class="nx">floating</span><span class="p">)</span>
</span><span class='line'><span class="c1"># 调整窗口大小时计算是否需要漂浮</span>
</span><span class='line'><span class="nx">$win</span><span class="p">.</span><span class="nx">resize</span><span class="p">(</span><span class="nx">floating</span><span class="p">)</span>
</span><span class='line'><span class="c1"># 在手机屏幕滚动时计算是否需要漂浮</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s">&#39;body&#39;</span><span class="p">).</span><span class="nx">bind</span><span class="p">(</span><span class="s">&#39;touchmove&#39;</span><span class="p">,</span> <span class="nx">floating</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nx">calcTop</span><span class="p">()</span>
</span><span class='line'><span class="nx">floating</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考阅读</h3>

<ol>
<li><a href="http://jqueryfordesigners.com/fixed-floating-elements/">Fixed Floating Elements</a></li>
<li><a href="http://stackoverflow.com/questions/8644248/jquery-fix-div-when-browser-scrolls-to-it">jQuery: Fix div when browser scrolls to it</a></li>
<li><a href="http://stackoverflow.com/questions/18753367/jquery-live-scroll-event-on-mobile-work-around">jQuery: Fix div when browser scrolls to it</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[纯Javascirpt实现页面二维码]]></title>
    <link href="http://codelife.me/blog/2014/06/20/add-a-qrcode-of-current-page-url-by-pure-javascript/"/>
    <updated>2014-06-20T11:39:03+08:00</updated>
    <id>http://codelife.me/blog/2014/06/20/add-a-qrcode-of-current-page-url-by-pure-javascript</id>
    <content type="html"><![CDATA[<blockquote><p>页面采用响应式布局可以在移动设备上有较好的展现效果，但移动设备输入长长的URL地址有些麻烦。URL<strong>二维码</strong>结合<strong>微信扫一扫</strong>可以较好的解决输入不便的问题。通常二维码是一张黑白相间的图片，网上可以找到很多二维码的生成工具和生成服务。所以二维码通常采用预生成或者临时请求第三方服务生成的方式引入到页面中，本文介绍一种通过js动态生成二维码的实现方法，并附带交互上的特效。动态生成可以方便的适应URL的变化。js动态生成可以去除对第三方服务的依赖，在隔绝内网下也可以使用。</p></blockquote>

<p><img src="http://codelife.me/images/post/2014-06-20/qrcode.png" alt="页面二维码效果图" /></p>

<!-- more -->


<p>Jade</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='jade'><span class='line'><span class="nt">a</span><span class="nc">.p-qrcode-link</span>(<span class="na">href=</span><span class="s">&#39;#&#39;</span>)
</span><span class='line'>  <span class="nt">span</span><span class="nc">.icon-qrcode</span>
</span><span class='line'>    <span class="nc">.p-qrcode</span>
</span></code></pre></td></tr></table></div></figure>


<p>Stylus</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.p-qrcode-link</span>
</span><span class='line'>  <span class="nt">position</span> <span class="nt">relative</span>
</span><span class='line'>  <span class="nt">padding-top</span> <span class="nt">11px</span> <span class="o">!</span><span class="nt">important</span>
</span><span class='line'>  <span class="nt">padding-bottom</span> <span class="nt">10px</span> <span class="o">!</span><span class="nt">important</span>
</span><span class='line'>  <span class="nt">padding-right</span> <span class="nt">2px</span> <span class="o">!</span><span class="nt">important</span>
</span><span class='line'>  <span class="nt">font-size</span> <span class="nt">2em</span>
</span><span class='line'>  <span class="nc">.icon-qrcode</span><span class="nd">:before</span>
</span><span class='line'>    <span class="nt">margin-right</span> <span class="nt">-15px</span> <span class="o">!</span><span class="nt">important</span>
</span><span class='line'><span class="nc">.p-qrcode</span>
</span><span class='line'>  <span class="nt">position</span> <span class="nt">absolute</span>
</span><span class='line'>  <span class="nt">top</span> <span class="nt">10px</span>
</span><span class='line'>  <span class="nt">right</span> <span class="nt">-13px</span>
</span><span class='line'>  <span class="nt">z-index</span> <span class="nt">5</span>
</span><span class='line'>  <span class="nt">display</span> <span class="nt">none</span>
</span><span class='line'>  <span class="nt">cursor</span><span class="o">:</span> <span class="nt">url</span><span class="o">(</span><span class="s1">&#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjbQg61aAAAADUlEQVQYV2P4//8/IwAI/QL/+TZZdwAAAABJRU5ErkJggg==&#39;</span><span class="o">),</span><span class="nt">url</span><span class="o">(../</span><span class="nt">img</span><span class="o">/</span><span class="nt">blank</span><span class="nc">.cur</span><span class="o">),</span><span class="nt">none</span> <span class="o">!</span><span class="nt">important</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Coffeescript</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">base_url = </span><span class="nf">-&gt;</span>
</span><span class='line'>  <span class="nv">arr = </span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="s">&quot;</span><span class="si">#{</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s">//</span><span class="si">#{</span><span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s">&quot;</span>
</span><span class='line'><span class="c1">#qrcode</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.p-qrcode&#39;</span><span class="p">).</span><span class="nx">qrcode</span><span class="p">({</span>
</span><span class='line'>  <span class="nv">rendeer : </span><span class="s">&#39;table&#39;</span>
</span><span class='line'>  <span class="nv">width   : </span><span class="mi">128</span>
</span><span class='line'>  <span class="nv">height  : </span><span class="mi">128</span>
</span><span class='line'>  <span class="nv">foreground: </span><span class="s">&quot;</span><span class="err">#</span><span class="s">777777&quot;</span>
</span><span class='line'>  <span class="nv">text    : </span><span class="nx">base_url</span><span class="p">()</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="c1">#toggle</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s">&#39;.p-qrcode-link&#39;</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s">&#39;mouseenter&#39;</span><span class="p">,</span> <span class="nf">-&gt;</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.p-qrcode&#39;</span><span class="p">).</span><span class="nx">show</span><span class="p">()</span>
</span><span class='line'><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s">&#39;mouseleave&#39;</span><span class="p">,</span> <span class="nf">-&gt;</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="s">&#39;.p-qrcode&#39;</span><span class="p">).</span><span class="nx">hide</span><span class="p">()</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考阅读</h3>

<ol>
<li><a href="https://github.com/jeromeetienne/jquery-qrcode">jquery.qrcode.js</a></li>
<li><a href="http://stackoverflow.com/questions/2636068/hide-cursor-in-chrome-and-ie">Hide cursor in Chrome (and IE)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Capistrano在每台应用服务器上都执行数据库迁移]]></title>
    <link href="http://codelife.me/blog/2014/05/20/db-migrate-all-app-by-capistrano/"/>
    <updated>2014-05-20T23:47:44+08:00</updated>
    <id>http://codelife.me/blog/2014/05/20/db-migrate-all-app-by-capistrano</id>
    <content type="html"><![CDATA[<blockquote><p>Capistrano发布Rails app到远端服务器时，只在primary db服务器上执行db:migrate。对于每个app都使用独立的本地Sqlite数据库的场景不适用。</p></blockquote>

<p>通过添加如下task，在每台app服务器上执行db:migrate</p>

<pre><code>#lib/capistrano/task/migrate_all.rake

desc 'Runs rake db:migrate on all app server'
task :migrate_all =&gt; [:set_rails_env] do
    on roles(:app), in: :parallel do
        within release_path do
            with rails_env: fetch(:rails_env) do
                execute :rake, "db:migrate"
            end
        end
    end
end

after :updated, :migrate_all
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Master-Agent模式的Rails应用借助JWT Token验证]]></title>
    <link href="http://codelife.me/blog/2014/05/17/rails-app-authenticate-by-jwt-between-master-and-agent/"/>
    <updated>2014-05-17T17:35:50+08:00</updated>
    <id>http://codelife.me/blog/2014/05/17/rails-app-authenticate-by-jwt-between-master-and-agent</id>
    <content type="html"><![CDATA[<blockquote><p>一对Master-Agent模式Rails应用，Agent需要验证Master。通常考虑采用HTTP基础认证或者HTTP摘要认证。这里Agent不需要多用户支持，所以只要一个加密口令即可，无需用户名。本文介绍采用JWT实现基于Token验证，结合Rails 4.1的新特性，装载secrets.yml文件里的密钥，作为JWT Token的计算密钥，应用于Rails应用。</p></blockquote>

<h3>Agent端配置</h3>

<h4>安装jwt Gem</h4>

<p>Gemfile添加如下行</p>

<pre><code>gem 'jwt'
</code></pre>

<p>然后执行<code>bundle install</code></p>

<!-- more -->


<h4>让所有Controller验证JWT Token</h4>

<p>编辑<code>app/controllers/application_controller.rb</code>文件，</p>

<pre><code>require 'jwt'
class ApplicationController &lt; ActionController::Base
    ...
before_action :validate_token

# Validate JWT token
def validate_token
    begin
    authz_header = request.headers['Authorization']
    if authz_header.nil?
        raise SecurityError.new("Authorization Header is missing")
    end
    token = authz_header.split(' ').last
    JWT.decode(token, Rails.application.secrets.jwt_secret_key)
    rescue JWT::DecodeError, SecurityError
    render nothing: true, status: :unauthorized
    end
end
    ...
end
</code></pre>

<p>其中密钥<code>Rails.application.secrets.jwt_secret_key</code>需要配置<code>config/secrets.yml</code>。</p>

<h4>配置config/secrets.yml</h4>

<pre><code>development:
    secret_key_base: c5e867eee171336e0b00d648a3d73cd176379ad9bc556ccc34102a046893c451add2b2fccb6d3ea914834cd9737e6ca432ecdf6cef8c81b61b79c8cad412ac88
    jwt_secret_key: c5e867eee171336e0b00d648a3d73cd176379ad9bc556ccc34102a046893c451add2b2fccb6d3ea914834cd9737e6ca432ecdf6cef8c81b61b79c8cad412ac88

test:
    secret_key_base: eaddadc7e11e7228c78670537d53a5b62d5b3908a84dcad6340c4a8104052b9043271bb03ae1ce11b03efe72ce4547aec61a9b71891451568a1084c80ba388d2
    jwt_secret_key: c5e867eee171336e0b00d648a3d73cd176379ad9bc556ccc34102a046893c451add2b2fccb6d3ea914834cd9737e6ca432ecdf6cef8c81b61b79c8cad412ac88

# Do not keep production secrets in the repository,
# instead read values from the environment.
production:
    secret_key_base: &lt;%= ENV["SECRET_KEY_BASE"] %&gt;
    jwt_secret_key: &lt;%= ENV["JWT_SECRET_KEY"] %&gt;
</code></pre>

<p>开发和测试环境取静态值，部署环境取环境变量的值。</p>

<h4>配置.env文件存放环境变量</h4>

<p>安装 dotenv gem，修改Gemfile，添加如下行</p>

<pre><code>gem 'dotenv-rails'
</code></pre>

<p><strong>请将&#8217;dotenv-rails&#8217;放在其他依赖环境变量的gem的前面</strong>，保存后执行<code>bundle install</code></p>

<p>Rails.Root目录新建<code>.env</code>文件</p>

<pre><code>JWT_SECRET_KEY: 4efe25e7fb153c392baf0787ee78c153a4fba5e6d7c8715b4a03849cd8a13b064ad2a636845e6753481613111dffb3c48c9a5a84fc38d50b757b3a2f46b8a493
SECRET_KEY_BASE: 2d78298e02650fefd0381ae0be261064466ac028567a8c5d113b46f0e4696d3153b8bac9ab62828b2befc08c48b009678d4b5de0f47b72f7e5fce51800ce5fee
</code></pre>

<p>然后将<code>.env</code>添加到<code>.gitignore</code>里去，防止其被提交到版本库</p>

<h4>与Capistrano集成</h4>

<p>修改config/deploy.rb文件，添加如下Task</p>

<pre><code>namespace :deploy do
    desc 'Generate Secret key to .env file'
task :generate_sceret_key do
    on roles(:app), in: :parallel do
    within release_path do
        if test("! grep -q JWT_SECRET_KEY #{release_path.join('.env')}")
            execute :rake, 'env:generate_secret[JWT_SECRET_KEY]'
        end
        if test("! grep -q SECRET_KEY_BASE #{release_path.join('.env')}")
            execute :rake, 'env:generate_secret[SECRET_KEY_BASE]'
        end     
        end
    end
    end
    after :updated, :generate_sceret_key
end
</code></pre>

<h3>Master端配置</h3>

<p>采用RestClient与Agent端进行通信，需要在请求的头部加入JWT Token以通过Agent端验证。</p>

<pre><code>#sync with agent
def sync
    res = site['sync.json'].get
    json =  JSON::parse(res.body)
    puts json
end

#generate jwt token
def generate_token
    unless self.secret_key.nil?
        self.token = JWT.encode("something_to_secret", self.secret_key)
    end
end

private
    def site
        @_site ||= RestClient::Resource.new(self.endpoint, :headers =&gt; {"Authorization" =&gt; "Bearer #{self.token}"})
    end
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://blog.yanted.com/2014/02/13/jwt-based-authentication-with-ember-js-and-rails/">JWT based authentication with Ember.js and Rails</a></li>
<li><a href="https://github.com/bkeepers/dotenv">Loads environment variables from &lsquo;.env&rsquo;</a></li>
<li><a href="http://www.jamesbadger.ca/2012/12/18/generate-new-secret-token/">Generate a New Secret Token for Rails Apps</a></li>
<li><a href="http://daniel.fone.net.nz/blog/2013/05/20/a-better-way-to-manage-the-rails-secret-token/">A better way to manage the Rails secret token</a></li>
<li><a href="http://edgeguides.rubyonrails.org/4_1_release_notes.html#config/secrets.yml">Rails 4.1 generates a new secrets.yml file in the config folder</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将Git提交版本号作为Rails应用版本号]]></title>
    <link href="http://codelife.me/blog/2014/05/17/using-git-commit-version-as-version-number-of-rails-app/"/>
    <updated>2014-05-17T14:02:04+08:00</updated>
    <id>http://codelife.me/blog/2014/05/17/using-git-commit-version-as-version-number-of-rails-app</id>
    <content type="html"><![CDATA[<blockquote><p>应用的版本管理和代码的版本管理通常是分开的，作为两套独立的版本系统来维护。对于小型应用来说有些浪费精力。最早在<a href="https://www.gitlab.com/">GitLab</a>这款开源软件上看到其使用Git的提交版本号作为版本号，本文将借鉴这种做法。</p></blockquote>

<h3>获得Git版本号</h3>

<ol>
<li>开发环境，当前的工作目录里包含了<code>.git</code>目录，直接执行下面的命令<code>git describe --always</code>。该命令通常返回形如<code>1f36a3b</code>的SHA-1短序列，但是如果该提交版本有对应的Tag的话，将返回该Tag名称。真实应用发布场景显得非常有用，毕竟随机序列不如自定义的有意义的名称便于记忆、沟通和传播。</li>
<li>对于<a href="http://capistranorb.com/">Capistrano</a>工具发布的生产环境，应用根目录不包含<code>.git</code>目录，所以如果通过<code>git</code>命令直接获得代码版本号，好在Capistrano发布时会自动生成<code>REVISION</code>文件，其内容为代码版本号。</li>
</ol>


<p>综合两种情况的代码如下</p>

<pre><code>if File.exist? 'REVISION' then `cat REVISION`.chomp else `git describe --always` end
</code></pre>

<!-- more -->


<h3>版本号作为静态变量</h3>

<p>上面我们讨论了在rails应用里通过代码获得版本号，但是版本号在应用系统相当于静态变量，在启动时候初始化，通过更有意义的名称（app_version）来引用会方便一些。</p>

<p>下面我们介绍如何结合<a href="https://github.com/binarylogic/settingslogic">settingslogic</a>，将版本号变成应用级的全局变量（通过<code>Settings.app_version</code>引用）。</p>

<p>在<code>Gemfile</code>里添加下面一行</p>

<pre><code>gem 'settingslogic'
</code></pre>

<p>然后执行<code>bundle install</code>.</p>

<p>向<code>config/application.yml</code>文件添加如下内容：</p>

<pre><code>#config/application.yml
defaults: &amp;defaults
    app_version: &lt;%= `git describe --always`%&gt;

development:
    &lt;&lt;: *defaults

test:
    &lt;&lt;: *defaults

production:
    &lt;&lt;: *defaults
</code></pre>

<p>修改<code>config/application.rb</code>文件
在<code>module AppName</code>（AppName 随应用名称而变）行之后添加</p>

<pre><code>class Settings &lt; Settingslogic
    source File.expand_path("../application.yml", __FILE__)
    namespace Rails.env
end
</code></pre>

<h3>HTTP响应包含版本号</h3>

<p>用Rails实现一个纯API应用，仅接受和响应JSON格式数据，将版本号添加到响应头部是一种不错的方法。</p>

<p>编辑<code>config/application.rb</code>在<code>class Application &lt; Rails::Application</code>里面加入</p>

<pre><code>config.action_dispatch.default_headers.merge!({ 
    'X-App-Version' =&gt; Settings.app_version 
})
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://blog.danielpietzsch.com/post/1209091430/show-the-version-number-of-your-rails-app-using-git">Show the version number of your Rails app using Git</a></li>
<li><a href="http://chriszetter.com/blog/2013/10/04/setting-headers-in-rails-4/">Setting headers in Rails 4</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Token的认证和基于声明的标识]]></title>
    <link href="http://codelife.me/blog/2014/03/26/token-based-authentication-and-claims-based-identity/"/>
    <updated>2014-03-26T14:12:05+08:00</updated>
    <id>http://codelife.me/blog/2014/03/26/token-based-authentication-and-claims-based-identity</id>
    <content type="html"><![CDATA[<blockquote><p>OpenID解决跨站点的认证问题，OAuth解决跨站点的授权问题。认证和授权是密不可分的。而OpenID和OAuth这两套协议出自两个不同的组织，协议上有相似和重合的之处，所以想将二者整合有些难度。好在OpenID Connect作为OpenID的下一版本，在OAuth 2.0的协议基础上进行扩展，很好的解决了认证和授权的统一，给开发者带来的便利。在学习和研究OpenID Connect协议时，遇上两个概念基于Token的认证（token based authentication）和基于声明的标识（claims based identity）。本文就这两个概念展开讨论，为了更好的理解OpenID Connect协议的原理。</p></blockquote>

<h3>基于Cookie的认证和基于Token的认证</h3>

<p>有两种不同的方法实现服务端的认证</p>

<ul>
<li>常见方式是<strong>基于Cookie的认证</strong>,每个请求中携带Cookie信息以便于服务端识别</li>
<li>另一种新方法，<strong>基于Token的认证</strong>，在每个请求中携带被签名过Token信息传送到服务端</li>
</ul>


<p><a href="https://docs.google.com/drawings/d/1IPgSFz2loaOIrnIKinGyrSoRm54slHFi8d_oRJ7BGPc/edit?usp=sharing"><img src="http://codelife.me/images/post/2014-03-26/cookie-based-auth-vs-token-based-auth.png" alt="Cookie-based Auth vs Token-based Auth" /></a></p>

<!-- more -->


<p>相比Cookie，基于Token的认证有如下好处：</p>

<ul>
<li><strong>跨域</strong>: cookies在跨域场景表现并不好。基于Token的方法允许你向任何不同域名的服务器发送Ajax请求，因为你可以通过HTTP头传递用户信息。</li>
<li><strong>无状态</strong>（或者 服务端可扩展）：无须再存储Session，由于Token已经自包含了所有的用户信息。</li>
<li><strong>内容分发</strong>：你可以将所有的静态资源（例如：脚本，HTML，图片等）分发到CDN服务上，你的服务器仅仅提供API。<a href="http://www.internap.com/cdn-services-content-delivery-network/cdn-user-authentication/">某些CDN服务商</a>提供了基于Token验证的安全服务。</li>
<li><strong>解耦</strong>：无须被绑定在一个特定的验证方案。</li>
<li><strong>移动支持</strong>：在移动设备的原生平台，使用cookie作为安全认证并不是好主意。采用基于Token的方法会简单得多。</li>
<li><strong>跨站点脚本攻击</strong>：由于没有基于cookie技术，你不再需要考虑跨站点请求的安全性问题。</li>
<li><strong>性能</strong>：虽然没有做严格的性能测试，但是还原session所做的数据库查询往返的性能损耗要大于<code>HMACSH256</code>算法验证和解析Token。</li>
<li><strong>基于标准</strong>：JWT(<a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token">JSON Web Token</a>)作为Token的标准已经被广泛的接受。主流语言（.NET, Ruby, Java, Python, PHP）都有相应支持JWT标准的工具包。</li>
</ul>


<h3>JWT格式</h3>

<p><abbr title="JSON Web Token">JWT</abbr>是一种紧凑的URL安全表示格式，适用于空格受限制的场景，比如HTTP授权头部和请求参数。JWT使用JSON格式表示一组声明，该JSON被编码成<abbr title="JSON Web Signature">JWS</abbr>或<abbr title="JSON Web Encryption">JWE</abbr>结构。</p>

<p>JWT是一段被base64url编码过的字符序列（去除了尾部的“=”），并用点号分隔。</p>

<p>下面是一个JWT头部的</p>

<div><script src='https://gist.github.com/9976068.js?file=headers.json'></script>
<noscript><pre><code>{
  &quot;typ&quot;: &quot;JWT&quot;,
  &quot;alg&quot;: &quot;HS256&quot;
}</code></pre></noscript></div>


<p>使用base64url编码以后</p>

<div><script src='https://gist.github.com/9976068.js?file=header_encoded'></script>
<noscript><pre><code>eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9</code></pre></noscript></div>


<p>下面是一个JWT的消息体其中包含声明集合</p>

<div><script src='https://gist.github.com/9976068.js?file=payload.json'></script>
<noscript><pre><code>{
  &quot;user_id&quot;: 1
}</code></pre></noscript></div>


<p>使用base64url编码以后</p>

<div><script src='https://gist.github.com/9976068.js?file=payload_encoded'></script>
<noscript><pre><code>eyJ1c2VyX2lkIjogMX0</code></pre></noscript></div>


<p>将上面编码过的JWS头部和JWS消息体使用HMAC SHA-256算法，并结合私钥计算得到的MAC，再经过base64url编码获得的字符序列成为JWS签名</p>

<div><script src='https://gist.github.com/9976068.js?file=signature'></script>
<noscript><pre><code>BSf1w1blYKcbxVlyOtUogUsozH2clY34xxYPd8lQIlQ</code></pre></noscript></div>


<p>将编码过的头部，消息体和JWS签名通过&#8217;.&lsquo;号连接起来，就获得JWT</p>

<div><script src='https://gist.github.com/9976068.js?file=jwt'></script>
<noscript><pre><code>eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJ1c2VyX2lkIjogMX0.BSf1w1blYKcbxVlyOtUogUsozH2clY34xxYPd8lQIlQ</code></pre></noscript></div>


<p>关于JWT的更多技术细节，请阅读<a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token">JWT规范</a>.</p>

<h3>基于声明的标识</h3>

<p>Cookie在请求和响应之间反复传递，对于无状态的HTTP协议，在Cookie里加入一个会话ID，以标识一组请求和响应属于同一会话。通常会话与用户是多对一关系，也就是说一个会话只会属于一个用户。所以通过Cookie技术就可以标识出用户。通常Cookie里也会携带一些额外的信息，但是考虑Cookie容易被截获和篡改，所以Cookie里并不适合放置用户的基本信息。</p>

<p>Token其实和Cookie类似是一段序列化字符串，作为HTTP请求头的一部分，发送到服务端。但是Token加入了签名机制，可以防篡改。所以Token可以包含用户信息发送给不同域的应用服务作为身份标识，只要相应的应用服务能识别其有效性。</p>

<p>Token仅仅是某种信息的承载形式，基于Token的认证有一个更宽泛的概念：基于声明的标识</p>

<p><a href="https://docs.google.com/drawings/d/1bSBW-rNfOUA4jsWVABXyuJklNY-hXI8QRMRtarh5Ek4/edit?usp=sharing"><img src="http://codelife.me/images/post/2014-03-26/claims-based-identity.png" alt="Claims based Identity" /></a></p>

<p>基于声明的标识其实无处不在，举个我们很熟悉的例子。</p>

<p>每次机场登机前过安检时，你不能简单地走到门口，并出示身份证。相反，必须先办理登机手续柜台。如果出国，还需要出示护照。安检人员先验证证件头像与你本人是否一致，然后核实您的信息，并确认您已经购买了机票。假设一切顺利，您将获得登机牌。</p>

<p>登机牌上包括知道您的姓名，航班号和座位号等常规信息。安检人员可以从登机牌上获得足够的信息以配合他们的工作。</p>

<p>登机牌上还有一些特殊信息，包含在条形码和背面的磁条里，以证明该登机牌是由航空公司签发的，而不是伪造的。</p>

<p>从本质上说，登机牌是一个由航空公司签发的关于你的一组信息。它表明你被允许某时登上某飞机坐在某个座位。当然，安检人员不必深入地理解这些。他们只需验证您的登机牌，读取其中的信息，然后让你登机。</p>

<p>同样值得注意的是，可能有不止一种方法获得您的登机牌。可能去机场售票柜台领取，或者在家里从航空公司网站下载并打印。安检人员不在乎的登机牌是如何获得的 。他们只关心登机牌是否真实的。</p>

<p>登机牌就是一张包含了一组声明信息的卡片，是Token的一种实体形式。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://book.douban.com/subject/5303216/">《A Guide to Claims-Based Identity and Access Control》</a></li>
<li><a href="http://dotnetcodr.com/2014/01/20/introduction-to-oauth2-json-web-tokens/">Introduction to OAuth2: Json Web Tokens</a></li>
<li><a href="http://www.layer7tech.com/blogs/index.php/give-me-a-jwt-ill-give-you-an-access-token/">Give Me a JWT, I’ll Give You an Access Token</a></li>
<li><a href="http://en.wikipedia.org/wiki/Claims-based_identity">Claims-based identity</a></li>
<li><a href="http://blog.auth0.com/2014/01/07/angularjs-authentication-with-cookies-vs-token/">Cookies vs Tokens. Getting auth right with Angular.JS</a></li>
<li><a href="http://jpadilla.com/post/73791304724/auth-with-json-web-tokens">Auth with JSON Web Tokens</a></li>
<li><a href="http://openid.net/specs/draft-jones-json-web-token-07.html">JSON Web Token (JWT) draft-jones-json-web-token-07</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java泛型让声明方法返回子类型]]></title>
    <link href="http://codelife.me/blog/2014/03/05/returning-subtype-of-declared-type-from-method-by-java-generics/"/>
    <updated>2014-03-05T11:11:45+08:00</updated>
    <id>http://codelife.me/blog/2014/03/05/returning-subtype-of-declared-type-from-method-by-java-generics</id>
    <content type="html"><![CDATA[<blockquote><p>泛型典型的使用场景是集合。考虑到大多数情况下集合是同质的（同一类型），通过声明参数类型，可免去类型转换的麻烦。本文将讨论本人阅读Spring Security源码时遇到的一个关于<strong><em>泛型递归模式</em></strong>的问题。</p></blockquote>

<h3>声明方法返回子类型</h3>

<p>在Spring Security的源码里有一个<code>ProviderManagerBuilder</code>接口，声明如下</p>

<pre><code>public interface ProviderManagerBuilder&lt;B extends ProviderManagerBuilder&lt;B&gt;&gt; extends SecurityBuilder&lt;AuthenticationManager&gt; {
    B authenticationProvider(AuthenticationProvider authenticationProvider);
}
</code></pre>

<p>其实现类<code>AuthenticationManagerBuilder</code></p>

<pre><code>public class AuthenticationManagerBuilder extends AbstractConfiguredSecurityBuilder&lt;AuthenticationManager, AuthenticationManagerBuilder&gt; implements ProviderManagerBuilder&lt;AuthenticationManagerBuilder&gt; {

    //...

    public AuthenticationManagerBuilder authenticationProvider(
        AuthenticationProvider authenticationProvider) {
        this.authenticationProviders.add(authenticationProvider);
        return this;
    }

    //...

}
</code></pre>

<p>上面有很多干扰项，我们来简化一下</p>

<!-- more -->


<p>接口<code>A</code>定义如下</p>

<pre><code>public interface A&lt;T extends A&lt;T&gt;&gt; {

    T add();

}
</code></pre>

<blockquote><p>说明：<code>A</code>接口只有一个<code>add</code>方法，返回泛型<code>T</code>。<code>T</code>的声明有些饶<code>&lt;T extends A&lt;T&gt;&gt;</code>。</p></blockquote>

<p><code>A</code>接口的实现类<code>B</code></p>

<pre><code>public class B implements A&lt;B&gt; {

    @Override
    public B add() {
        return null;
    }

}
</code></pre>

<p>注意，此处类<code>B</code>里的add方法返回类型<code>B</code>。也就是说，接口<code>A</code>里声明的方法时并不知道子类型<code>B</code>的存在，通过继承和泛型，可以放返回值动态的适配子类型，这一切都要归功于<code>&lt;T extends A&lt;T&gt;&gt;</code></p>

<h3>泛型递归模式（Recurring Generic Pattern）</h3>

<p><code>public interface A&lt;T extends A&lt;T&gt;&gt;</code>对于参数类型<code>T</code>是递归定义的。有如GNU的定义“GNU&rsquo;s Not Unix!”。</p>

<p>典型的例子是<code>java.lang.Enum</code></p>

<pre><code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;
    implements Comparable&lt;E&gt;, Serializable {
    //...
}
</code></pre>

<blockquote><p>java所有的枚举类型都隐式的继承<code>java.lang.Enum</code>，不允许通过现实的继承声明枚举类型，甚至集成<code>java.lang.Enum</code>也是编译器所不允许的。</p></blockquote>

<p>假设有一个枚举类<code>StatusCode</code>,其等价的声明如下</p>

<pre><code>public class StatusCode extends Enum&lt;StatusCode&gt;
</code></pre>

<p>现在我们来验证一下泛型约束，</p>

<ol>
<li>因为<code>Enum&lt;StatusCode&gt;</code>,所以<code>E=StatusCode</code></li>
<li>根据<code>&lt;E extend Enum&lt;E&gt;&gt;</code> 和 <code>E=StatusCode</code> 可得，<code>&lt;StatusCode extend Enum&lt;StatusCode&gt;&gt;</code>，</li>
<li>由于<code>public class StatusCode extends Enum&lt;StatusCode&gt;</code>第二步的结论显然成立。</li>
</ol>


<h4>为什么Enum的声明这么绕？直接Enum<E>不行么？</h4>

<p>因为<code>Enum&lt;E&gt;</code>实现了<code>Comparable&lt;E&gt;</code>接口，该接口有一个<code>compareTo</code>方法</p>

<pre><code>public int compareTo(E o) {}
</code></pre>

<p><E extend Enum<E>>强制约束了进行<code>compareTo</code>的调用对象类型和参数类型都严格一致，不会出现子类和超类或者兄弟类之间的比较。</p>

<h3>泛型递归模式与继承</h3>

<p>泛型递归模式<code>interface A&lt;T extend A&lt;T&gt;&gt;</code>用于约束参数类型T，要求其为类型<code>A</code>的子类。考虑到继承和实现<code>B implements A&lt;B&gt;</code>,参数类型和实体类型是一致的。这样类<code>A</code>中方法签名里涉及到参数类型<code>T</code>的地方，在实现类里会为实现类本身，这让类型系统更加的严谨。</p>

<h3>参考文献</h3>

<ol>
<li><a href="http://stackoverflow.com/questions/211143/java-enum-definition">Java Enum definition</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html">Java Toturial &ndash; Enum Types</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL Select和关系操作]]></title>
    <link href="http://codelife.me/blog/2014/02/23/sql-select-and-relational-operations/"/>
    <updated>2014-02-23T19:55:31+08:00</updated>
    <id>http://codelife.me/blog/2014/02/23/sql-select-and-relational-operations</id>
    <content type="html"><![CDATA[<blockquote><p>没有系统的学习过关系数据库，所以对SQL Select的理解有些浅薄，特别是group by和having语句。<a href="http://book.douban.com/subject/7061934/">《SQLite 权威指南（第二版）》</a>的第三章SQLite中的SQL，让我对Select，乃至SQL语言和关系数据库有了全新的认识。一时间激起了对关系数据库和理论的兴趣，到豆瓣上淘了一本绝版的<a href="http://book.douban.com/subject/2122940/">《深度探索关系数据库》</a>，可惜基础太差，读了一半实在读不下去了，作罢。</p></blockquote>

<p>最大的收获和发现莫过于下面这幅图了，</p>

<p><img src="http://codelife.me/images/post/2014-02-23/select.png" alt="select处理过程" /></p>

<!-- more -->


<p>说明：</p>

<ul>
<li>多张表通过笛卡尔积（Cartesian Production）或者连接（Join）产生R1</li>
<li>R1到R2的过程称作限制（Restriction），即过滤掉不符合条件的行（元组）</li>
<li>R4到R5的过程称作投影（Projection），即选择出需要的列（属性）</li>
</ul>


<h3>参考阅读</h3>

<ol>
<li><a href="http://book.douban.com/subject/7061934/">《SQLite 权威指南（第二版）》</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将Gemfile模板文件的source改成淘宝源]]></title>
    <link href="http://codelife.me/blog/2014/02/03/modify-source-of-the-gemfile-template/"/>
    <updated>2014-02-03T21:54:20+08:00</updated>
    <id>http://codelife.me/blog/2014/02/03/modify-source-of-the-gemfile-template</id>
    <content type="html"><![CDATA[<blockquote><p>由于国内网络原因（你懂的），导致rubygems.org存放在Amazon S3上面的资源文件间歇性连接失败。所有你会遇到<code>gem install rack</code>或<code>bundle install</code>的时候半天没有响应。将默认源改成国内的淘宝源(<a href="http://ruby.taobao.org">http://ruby.taobao.org</a>)可以解决该问题。</p></blockquote>

<p>对于Rails项目通常需要将Gemfile的第一行改为</p>

<pre><code>    source 'http://ruby.taobao.org/'
</code></pre>

<p>但是通过<code>rails new my_project</code>创建项目时，由于Gemfile生成以后立即执行<code>bundle install</code>，此时source尚未修改，所以项目创建的过程仍然很慢。</p>

<p>解决rails new 卡住的问题，有如下两种方法</p>

<!-- more -->


<h3>使用<code>--skip-bundle</code>参数</h3>

<pre><code>rails new app1 --skip-bundle
</code></pre>

<p>通过设置<code>--skip-bundle</code>参数，<code>rails new</code> 命令创建完成项目骨架以后，不会执行<code>bundle install</code>。于是可以修改Gemfile行首的source，然后再执行<code>bundle install</code>。</p>

<h3>修改Gemfile模板</h3>

<p>使用如下命令，修改Gemfile模板文件，一劳永逸</p>

<h4>For Mac</h4>

<pre><code>/usr/bin/sed -i .bak 's!https://rubygems.org!http://ruby.taobao.org!' `rvm info homes | grep gem: | awk '{print $2}' | tr -d '"'`/gems/railties-`gem list | grep railties | awk '{print $2}'| tr -d '()'`/lib/rails/generators/rails/app/templates/Gemfile
</code></pre>

<h4>For Linux</h4>

<pre><code>sed -i 's!https://rubygems.org!http://ruby.taobao.org!' `rvm info homes | grep gem: | awk '{print $2}' | tr -d '"'`/gems/railties-`gem list | grep railties | awk '{print $2}'| tr -d '()'`/lib/rails/generators/rails/app/templates/Gemfile
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://ruby.taobao.org/">RubyGems 镜像 &ndash; 淘宝网</a></li>
<li><a href="http://snails.github.io/2012/06/04/Modify-the-Gemfile-Template/">修改Rails默认生成的Gemfile的source</a></li>
<li><a href="http://ruby-china.org/topics/914">run bundle install 卡住很久</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将树莓派配置成时间胶囊]]></title>
    <link href="http://codelife.me/blog/2013/12/21/raspberry-pi-as-time-capsule/"/>
    <updated>2013-12-21T21:00:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/21/raspberry-pi-as-time-capsule</id>
    <content type="html"><![CDATA[<blockquote><p>MacBookAir的SSD坏了两次以后，发现TimeMachine真的很有必要。外插个尿袋子真的不方便。AirPort Time Capsule 2T版本价格买到了$299，觉得有些不值。$25的树莓派+一块移动硬盘DIY一个Time Capsule即经济又有趣。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-12-21/raspberry-pi-as-time-capsule.png" alt="Raspberry Pi as TimeCapsule" /></p>

<!-- more -->


<h3>组件清单</h3>

<p><img src="http://codelife.me/images/post/2013-12-21/component-of-time-capsule.png" alt="Component of TimeCapsule" /></p>

<ul>
<li>树莓派

<ul>
<li>TF卡 + 卡套</li>
<li>USB WiFi 网卡</li>
<li>5V电源 + MicroUSB 电源线</li>
</ul>
</li>
<li>移动硬盘

<ul>
<li>2.5寸 500G SATA 硬盘</li>
<li>USB3.0 硬盘电路板</li>
<li>USB3.0 数据线</li>
</ul>
</li>
</ul>


<h3>安装HFS+文件系统工具</h3>

<pre><code>sudo apt-get install hfsplus hfsutils hfsprogs
</code></pre>

<h3>准备HFS+设备</h3>

<p>列出所有块设备</p>

<pre><code>sudo blkid
</code></pre>

<p>返回如下</p>

<pre><code>/dev/mmcblk0p1: LABEL="RECOVERY" UUID="F69B-A989" TYPE="vfat"
/dev/mmcblk0p3: LABEL="SETTINGS" UUID="7f8a9faf-84a1-4062-ab9c-b2e6115035ce" TYPE="ext4"
/dev/mmcblk0p5: LABEL="BOOT" UUID="03D6-2985" TYPE="vfat"
/dev/mmcblk0p6: LABEL="root" UUID="e2a46600-20ca-42f4-8ec8-aa52d258aad2" TYPE="ext4"
/dev/sda1: UUID="943f46c5-2de2-3ef9-8494-46c3cf8bd915" LABEL="Time Capsule" TYPE="hfsplus"
</code></pre>

<p>包含TYPE=“hfsplus”的即是。</p>

<p>如果希望把一个新的分区格式化为HFS+，使用如下命令</p>

<pre><code>sudo mkfs.hfsplus -v "Time Capsule" /dev/sda1
</code></pre>

<p><strong>建议使用全新的hfs+分区</strong>
把一块已经做过TimeMachine的hfs+分区，可能导致原有的备份数据丢失</p>

<h3>挂载</h3>

<pre><code>sudo mkidr /media/TimeCapsule
sudo mount -t hfsplus -o force /dev/sda1 /media/TimeCapsule
sudo chown -R pi:pi /media/TimeCapsule
</code></pre>

<h3>安装配置netatalk服务</h3>

<pre><code>sudo apt-get install netatalk
sudo echo "/media/TimeCapsule \"Time Capsule\" options:tm" &gt;&gt; /etc/netatalk/AppleVolumes.default
sudo service netatalk restart
</code></pre>

<p>接下来就可以从Mac的Time Machine里找到这块磁盘 <br/>
<img src="http://codelife.me/images/post/2013-12-21/avaliable-disk.png" alt="选择Time Machine磁盘" /></p>

<h3>配置Avahi</h3>

<p>安装<code>avahi-daemon</code>和<code>libnss-mdns</code></p>

<pre><code>sudo apt-get install avahi-daemon libnss-mdns
</code></pre>

<p>配置nsswitch.conf</p>

<p>在<code>hosts:</code>后添加“mdns”</p>

<pre><code>hosts:      files mdns4_minimal [NOTFOUND=return] dns mdns4 mdns
</code></pre>

<p>接下来让Avahi在局域网广播AFP共享</p>

<p>添加如下文件<code>/etc/avahi/services/afpd.service</code>内容如下：</p>

<pre><code>&lt;?xml version="1.0" standalone='no'?&gt;&lt;!--*-nxml-*--&gt;
&lt;!DOCTYPE service-group SYSTEM "avahi-service.dtd"&gt;
&lt;service-group&gt;
    &lt;name replace-wildcards="yes"&gt;%h&lt;/name&gt;
    &lt;service&gt;
        &lt;type&gt;_afpovertcp._tcp&lt;/type&gt;
        &lt;port&gt;548&lt;/port&gt;
    &lt;/service&gt;
    &lt;service&gt;
        &lt;type&gt;_device-info._tcp&lt;/type&gt;
       &lt;port&gt;0&lt;/port&gt;
        &lt;txt-record&gt;model=Xserve&lt;/txt-record&gt;
    &lt;/service&gt;
&lt;/service-group&gt;
</code></pre>

<p>重启服务</p>

<pre><code>sudo /etc/init.d/avahi-daemon restart
</code></pre>

<p>在findler的左侧可以看到共享的文件系统</p>

<p><img src="http://codelife.me/images/post/2013-12-21/share.png" alt="共享" /></p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.zisoft.de/elektronik/raspberrypi/timecapsule.html">Raspberry Pi als TimeCapsule</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=36&amp;t=47029">Use rPi as a Time Capsule &ndash; another method</a></li>
<li><a href="http://garmoncheg.blogspot.jp/2012/11/time-capsule-for-25.html">Time Capsule for $25</a></li>
<li><a href="http://andadapt.com/raspberry-pi-raspbian-hfs-afp-and-time-machine/">Raspberry Pi, Raspbian, HFS+, AFP and Time Machine</a></li>
<li><a href="http://kremalicious.com/ubuntu-as-mac-file-server-and-time-machine-volume/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+kremalicious+(kremalicious">HowTo: Make Ubuntu a Perfect Mac File Server and Time Machine Volume</a>)</li>
<li><a href="http://www.andyibanez.com/260-linux-file-server-os-x-mavericks">Making A Linux File Server That Interacts With OS X Mavericks</a></li>
<li><a href="http://netatalk.sourceforge.net/wiki/index.php/Install_Netatalk_v3_on_Debian">Install Netatalk v3 on Debian</a></li>
<li><a href="http://superuser.com/questions/558150/how-to-write-to-hfs-through-afp-netatalk-without-permission-denied-and-cnid-met">How to write to HFS+ through AFP/Netatalk without permission denied and cnid_metad error?</a></li>
<li><a href="http://www.afp548.com/2013/05/06/afp-services-on-a-linux-server/">Using Netatalk: AFP Services on a Linux Server</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pcDuino上手记]]></title>
    <link href="http://codelife.me/blog/2013/12/19/beginner-of-pcduino/"/>
    <updated>2013-12-19T15:05:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/19/beginner-of-pcduino</id>
    <content type="html"><![CDATA[<blockquote><p>感谢刘博士送的这块pcDuino板。入Raspberry Pi前，优先考虑过pcDuino。在OSChina源创会上海站被刘博士打动过。买Raspberry Pi是为了DIY一个Mac的Time Capsule。随便Google了一下，找到了Raspberry实现Time Capsule的相关资料，而pcDuino的相关资料没有找到，于是作罢。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-12-19/pcduinov2.jpg" alt="pcDuino V2" /></p>

<p>由于Raspberry Pi的先入为主，上手pcDuino碰到写问题，下面一一列出</p>

<!-- more -->


<h3>选什么TF卡</h3>

<p>关于如何选购Raspberry Pi的SD卡，我好生下了功夫，最后还是有不好收获的。没有话冤枉钱买极速的。</p>

<p><strong>兼容列表</strong> <br/>
pcDuino支持哪些TF卡，网上找不到兼容列表。可能是都支持吧，不需要。</p>

<p><strong>读写速度</strong> <br/>
最大支持到少读写速度也找不到资料。</p>

<p>后来得知板载的2G闪存里内置了ubuntu系统，于是TF卡的问题就先悬着吧，等搞清楚再做决定。</p>

<h3>启动pcDuino</h3>

<p>插上网线，pcDuino的网线口比Raspberry Pi的要小巧，但是有些过紧，拔出网线时候要小心，别弄断了。
插上电源线，指示灯亮了。</p>

<p>没有显示器，IP地址默认应该是DHCP的，先要找到IP地址。</p>

<p><strong>找到IP地址</strong></p>

<pre><code>arp-scan --localnet
</code></pre>

<p>如果发现主机名ubuntu，那就是了。要是没有就找Unknow的逐个ssh测试，能连接上的就是。</p>

<h3>初始化系统</h3>

<p>ssh登录系统以后先执行系统初始化</p>

<pre><code>sudo board-config.sh
</code></pre>

<h3>安装Vim</h3>

<p>一直不习惯原生的vi，对方向键支持不好。</p>

<pre><code>sudo apt-get install vim
</code></pre>

<p>安装不成功，返回如下</p>

<pre><code>Reading package lists... Done
Building dependency tree
Reading state information... Done

....省去若干行

Failed to fetch http://ports.ubuntu.com/ubuntu-ports/pool/main/p/python2.7/libpython2.7_2.7.3-0ubuntu3.2_armhf.deb  404  Not Found
E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?
</code></pre>

<p>一大堆404，提示先<code>apt-get update</code>,好吧</p>

<pre><code>sudo apt-get update
</code></pre>

<p>返回如下</p>

<pre><code>....省去若干行

Get:20 http://ports.ubuntu.com precise-updates/universe Translation-en [132 kB]
Fetched 2681 kB in 21s (123 kB/s)
Reading package lists... Done
W: Conflicting distribution: http://www.wiimu.com pcduino Release (expected pcduino but got )
</code></pre>

<p>编辑器打开<code>/etc/apt/sources.list</code>,注释掉最后两行</p>

<pre><code>#deb http://www.wiimu.com:8020/pcduino/ pcuino main
#deb-src http://www.wimu.com:8020/pcduion/ pcduino main
</code></pre>

<p>然后在<code>sudo apt-get update</code>就正常了。</p>

<h3>VNC远程桌面</h3>

<h4>设置vnc密码</h4>

<pre><code>sudo x11vnc -storepasswd
sudo x11vnc -storepasswd in /etc/x11vnc.pass
sudo cp .vnc/passwd /etc/x11vnc.pass
</code></pre>

<h4>启动桌面</h4>

<pre><code>sudo start lightdm
</code></pre>

<h4>连接</h4>

<p>在mac终端敲入</p>

<pre><code>open vnc://&lt;ip_of_pcduino&gt;
</code></pre>

<h4>已知问题</h4>

<p><code>sudo stop lightdm</code>再次<code>sudo start lightdm</code>启动后，客户端无法连接上VNC服务器。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.cnblogs.com/iscode/p/3200503.html">pcDuino 刷系统-卡刷</a></li>
<li><a href="http://www.cnblogs.com/iscode/p/3200558.html">pcDuino无显示器刷机与使用</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kindle PaperWhite作为树莓派的命令终端]]></title>
    <link href="http://codelife.me/blog/2013/12/17/kindle-pw-as-a-terminal-connect-to-raspberry-pi/"/>
    <updated>2013-12-17T03:14:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/17/kindle-pw-as-a-terminal-connect-to-raspberry-pi</id>
    <content type="html"><![CDATA[<blockquote><p>网上有大牛把Kindle作为树莓派的显示屏，外带一个Mac蓝牙键盘，实用移动电源供给。一个台低功耗的可移动主机，酷极了。手上真好有一台Kindle PaperWhite，于是开始折腾。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-12-17/kindle-berry.png" alt="KindleBerry" /></p>

<h3>准备工作</h3>

<ol>
<li>Raspberry Pi 一台</li>
<li>Kindle PaperWhite 一台（已<a href="http://www.mobileread.com/forums/showthread.php?t=198446">越狱</a>）</li>
<li>USB转microUSB数据线2根，一根给Raspberry Pi供电，一根作为Kindle和Raspberry Pi的连接线</li>
</ol>


<!-- more -->


<h3>安装USBNetwork</h3>

<p><a href="http://www.mobileread.com/forums/showthread.php?t=186645">USBNetwork</a>工具可以通过usb数据线连接kindle和另一台电脑，实现ssh登录。</p>

<p>安装步骤如下</p>

<ol>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=116323&amp;d=1386361702">Kindle-usbnet-0.1.5N.zip</a>，解压以后仔细阅读<code>README_FIRST.txt</code>文件</li>
<li>将update_usbnet_0.15.N_install_touch_pw.bin拷贝到Kindle根目录</li>
<li><p>Kindle里工具栏菜单[设置]&ndash;> 工具栏菜单[更新您的Kindle]，安装完成后会重启</p>

<p> <img src="http://codelife.me/images/post/2013-12-17/kindle_install_sw.png" alt="安装Kindle应用" /></p></li>
<li>安装完成以后Kindle更目录会多出一个<code>usbnet</code>目录和<code>extensions\usbnet</code>目录</li>
<li><p>编辑<code>usbnet\etc\config</code>文件，修改如下</p>

<pre><code> USE_WIFI="true"
 USE_OPENSSH="true"
</code></pre></li>
</ol>


<p><strong>开关USBNetwork模式</strong></p>

<blockquote><p>在Kindle的搜索框内，输入<code>;usbnetwork</code>或者<code>;un</code>。再输入一个可以切换。</p></blockquote>

<p><strong>查看网络状态</strong></p>

<blockquote><p>在Kindle的搜索框内，输入<code>;711</code>。可以查到当前无线网卡的IP地址</p></blockquote>

<h4>Mac通过USB线登录Kindle</h4>

<ol>
<li>用USB线连接Mac和Kindle</li>
<li>默认Kindle会被挂载成存储设备，先弹出该设备</li>
<li>然后开启Kindle的USBNetwork模式</li>
<li><p>Mac[系统偏好设置]&ndash;>[网络] 新建一个RNDIS/Ethernet Gadget链接配置如下</p>

<pre><code> ip:     192.168.15.201
 mask:   255.255.255.0
 router: 192.168.15.244
</code></pre>

<ul>
<li>如果无法创建RNDIS连接，可能需要安装<a href="http://joshuawise.com/horndis">HoRNDIS</a></li>
<li>router的地址要Kindle的<code>/usbnet/etc/config</code>文件里<code>KINDLE_IP</code>项一致</li>
</ul>
</li>
<li><p>终端SSH连接</p>

<pre><code> ssh root@192.168.15.244
</code></pre></li>
</ol>


<h4>通过WiFi登录Kindle</h4>

<ol>
<li>在Kindle的搜索框内，输入<code>;711</code>查找Kindle无线网卡IP</li>
<li>通过终端SSH连接即可</li>
</ol>


<p>到此Kindle的Network算配置完毕，下来我们来配置Kindle的Kterm</p>

<h3>安装KUAL和Kterm</h3>

<h4>KUAL</h4>

<p><a href="http://www.mobileread.com/forums/showthread.php?t=203326">KUAL</a>是Kindle Unified Application Launcher的缩写，其作用是为越狱的Kindle启动第三方应用。简单的说通过一本特殊的书籍来统一实现启动触发器。</p>

<ol>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=115571&amp;d=1385111909">prerequisites-all-supported-devices.zip</a></li>
<li>解压后将update_kindlet-dev-20130710-k5-ALL_install.bin文件拷贝到Kindle根目录，Kindle安装.bin文件的方法都是一样的，Kindle里点击[更新您的Kindle],然后会显示安装进度，自动重启后完成。</li>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=109526&amp;d=1376691043">KUAL.V.2.2.zip</a></li>
<li>解压后将KindleLauncher-2.0.azw2文件拷贝到Kindle的<code>/documents</code>目录</li>
<li>断开连接后Kindle里多了一本《Kindle Launcher》的书，点开有一排可以启动的应用列表。 <br/>
 <img src="http://codelife.me/images/post/2013-12-17/kindle_launcher.png" alt="Kindle Launcher" /><img src="http://codelife.me/images/post/2013-12-17/kindle_launcher_opened.png" alt="Kindle Launcher打开以后的效果" /></li>
</ol>


<h4>Extend</h4>

<p><code>Extend</code>是一组扩展的预编译好的linux命令行工具，让Kindle可以运行一些常用的linux命令，如：openssh，nano，screen，irssi，php，bash，rsync等。</p>

<ol>
<li>下载<a href="http://ge.tt/9Qoa9YD/v/0?c">optware_img_60m.zip</a>和<a href="http://ge.tt/9Qoa9YD/v/2?c">kindle_extend-1.1.zip</a></li>
<li>解压kindle_extend-1.1.zip到kindle_extend-1.1目录</li>
<li>解压optware_img_60m.zip将<code>optware.img</code>文件替换<code>kindle_extend-1.1/extend/optware.img</code>文件</li>
<li>将<code>kindle_extend-1.1</code>目录下的<code>extend</code>和<code>extensions</code>子目录拷贝到Kindle更目录</li>
<li><p>然后通过SSH登录Kindle执行如下命令</p>

<pre><code> mntroot rw
 mkdir /mnt/us/circles
 cp /mnt/us/extend/mountd /mnt/us/circles
 ln -s /mnt/us/circles/mountd /etc/rc5.d/S101mountd
 mntroot ro
 /mnt/us/install.sh
 /mnt/us/mount.sh
</code></pre></li>
</ol>


<h4>Kterm</h4>

<p><a href="http://www.fabiszewski.net/kindle-terminal/">Kterm</a>是一个内置虚拟键盘的GTK+的Kindle终端模拟器</p>

<p><img src="http://codelife.me/images/post/2013-12-17/kterm.gif" alt="Kterm效果图" /></p>

<ol>
<li>下载<a href="http://www.fabiszewski.net/kindle-terminal/kterm-0.7.zip">Kerm 0.7</a></li>
<li>解压后将<a href="https://dl.dropbox.com/s/tagzqiz06fbdltz/kterm-landscape-enabled.zip?token_hash=AAH5k68xlwcYqi065-n5Bu5XaoiEXB12zCDjj50udrRg_w&amp;dl=1">此文件</a>替换<code>kterm/bin/kterm</code>文件。具体看<a href="https://github.com/bfabiszewski/kterm/issues/2#issuecomment-14204814">这里</a></li>
<li>然后将<code>kterm</code>文件夹拷贝到Kindle的<code>extensions</code>目录下</li>
<li>断开Kindle与电脑的链接，通过KUAL打开Kterm，随便Ping台机器试试。</li>
</ol>


<h3>配置Raspberry Pi的USB网络连接</h3>

<p>安装了USBNetwork，Kindle已经可以通过数据线和Mac电脑连网，接下来配置Raspberry Pi的USB网络链接，使Kindle插入Raspberry Pi以后可以自动建立网络连接。</p>

<pre><code>sudo vim /etc/network/interfaces
</code></pre>

<p>添加如下内容</p>

<pre><code>#USB tethering
allow-hotplug usb0
iface usb0 inet static
    address 192.168.15.1
    netmask 255.255.255.0
    broadcast 192.168.15.255
    up iptables -I INPUT 1 -s 192.168.15.1 -j ACCEPT
    up eject /dev/sda1
</code></pre>

<ul>
<li><code>allow-hotplug usb0</code>表示插入USB后自动加载网络配置</li>
<li><code>up eject /dev/sda1</code>表示弹出Kindle自动挂载的磁盘分区</li>
</ul>


<p>重启网络</p>

<pre><code>sudo service networking reload
</code></pre>

<h3>见证奇迹的时刻</h3>

<ol>
<li>使用数据线连接Kindle和Raspberry Pi</li>
<li>开启USBNetwork模式，Kindle的搜索框内，输入<code>;un</code>然后回车</li>
<li><p>打开Kterm键入</p>

<p> ssh <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#112;&#105;&#64;&#49;&#x39;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x31;&#53;&#x2e;&#x31;">&#x70;&#x69;&#64;&#x31;&#x39;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#49;&#53;&#x2e;&#x31;</a></p></li>
</ol>


<p>若提示输入密码或者保存密钥指纹，说明大功告成。</p>

<p><strong>Kindle作为跳板机</strong></p>

<p>Kindle和Raspberry Pi顺利创建连接之后，Mac OS可以通过Kindle的Wifi连接SSH登录进Kindle，然后再次SSH登录进入Raspberry Pi。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.ponnuki.net/2012/09/kindleberry-pi/">KindleBerry Pi</a></li>
<li><a href="https://gist.github.com/rvagg/5095506">Kindleberry &ldquo;Paperwhite&rdquo; Pi</a></li>
<li><a href="http://wiki.mobileread.com/wiki/Kindle_Touch_Hacking#GUI_launcher">Kindle Touch Hacking</a></li>
<li><a href="http://maxogden.com/kindleberry-wireless.html">Kindleberry Wireless: A Portable Outdoor Hackstation</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何找到树莓派通过DHCP获得的IP地址]]></title>
    <link href="http://codelife.me/blog/2013/12/17/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp/"/>
    <updated>2013-12-17T03:08:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/17/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp</id>
    <content type="html"><![CDATA[<blockquote><p>小巧的树莓派配一个硕大的显示器，很不协调。本文介绍如何获得树莓派通过DHCP动态分配的IP地址。</p></blockquote>

<h3>几种有趣的方法</h3>

<p>mathworks论坛提到了几种有意思的方法</p>

<ol>
<li><p>通过Matlab命令行</p>

<pre><code> h = raspberrypi(‘raspberrypi-ah')
 h.openShell(‘ssh')
</code></pre></li>
<li>安装一个启动过程中能读出IP的软件，该软件也是MathWork出品的</li>
<li>通过DDNS（Dynamic DNS）</li>
<li>启动时发邮件通知</li>
</ol>


<p>就个人而言，上面的方法觉得都不够好。</p>

<ol>
<li>需要安装Matlab，一个好几G的工具软件就是为了找个IP用，有些蛋疼</li>
<li>要插个耳机或者音响什么的</li>
<li>需要互联网环境</li>
<li>需要互联网环境</li>
</ol>


<p>下面我介绍一个简单实用的方法，通过arp协议获得IP</p>

<!-- more -->


<h3>通过arp-scan获得树莓派IP</h3>

<p>arp协议是一个数据链路层协议，负责IP地址和Mac地址的转换。下面我们介绍一个arp-scan工具扫出局域网所有的IP地址</p>

<h4>安装arp-scan</h4>

<p>Mac OS</p>

<pre><code>brew install arp-scan
</code></pre>

<p>Ubuntu</p>

<pre><code>sudo apt-get arp-scan
</code></pre>

<h4>扫描以太网IP地址</h4>

<pre><code>arp-scan --interface en0 --localnet  
</code></pre>

<p>此处en0是网卡的设备名称，可以通过ifconfig命令获得，有多种网卡时注意不要写错</p>

<p>扫描结果如下</p>

<pre><code>nterface: en0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.8 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
192.168.199.1   d4:ee:07:04:0d:e6   (Unknown)
192.168.199.239 e8:8d:28:06:db:2f   (Unknown)
192.168.199.107 b8:27:eb:96:c4:2f  (Unknown)

513 packets received by filter, 0 packets dropped by kernel
Ending arp-scan 1.8: 256 hosts scanned in 1.242 seconds (206.12 hosts/sec). 2 responded
</code></pre>

<p>由于arp-scan的版本比较低，所以主机名为Unknown,不过没有关系，由于树莓派的Mac地址都是<code>b8:27:3b</code>开头的。所以<code>192.168.199.107</code>就是树莓派的IP地址</p>

<h4>One line Command</h4>

<pre><code>arp-scan --interface en0 --localnet | grep grep b8:27:eb
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://blog.remibergsma.com/2013/05/03/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp/">HOWTO discover the ip address of a Raspberry Pi</a></li>
<li><a href="http://www.mathworks.cn/cn/help/simulink/ug/get-the-ip-address-of-the-raspberry_pi-hardware.html">Get IP Address of Raspberry Pi Hardware</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?t=55804">FYI: via Raspi&rsquo;s IP address with &lsquo;arp-scan&rsquo;</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspbian成功驱动TP-Link TL-WN725N V2版无线网卡]]></title>
    <link href="http://codelife.me/blog/2013/12/14/tp-link-wn725n-v2-works-on-raspbian/"/>
    <updated>2013-12-14T00:03:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/14/tp-link-wn725n-v2-works-on-raspbian</id>
    <content type="html"><![CDATA[<blockquote><p>淘宝双12搞活动，225入了一台英国产2代B型512M RaspBerry Pi，英国产的相对便宜，但是不带外壳，另外加12块，搞了个带固定螺丝的亚克力外壳。话说这个外壳裁剪的相对不错，花了老半天才装好。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-12-14/4-items.jpg" alt="配件合集" /></p>

<p><img src="http://codelife.me/images/post/2013-12-14/raspberry.jpg" alt="组装成品" /></p>

<p><img src="http://codelife.me/images/post/2013-12-14/pi-with-tl-wn725n.jpg" alt="TP-Link TL-WN725N V2" /></p>

<!-- more -->


<h3>如何选SD卡</h3>

<p>先罗嗦一段SD卡的选取过程。其实想买开树莓的板子很长时间了，但是如何选SD卡一直犹豫不决。主要考虑两个因素：</p>

<ul>
<li>SD卡的兼容性，某些SD卡树莓派无法识别；</li>
<li>SD卡的读写速度，市面上的Class 10卡从20M/s到UHS-I卡95M/s的价格相差很大。</li>
</ul>


<p>一开始很想选 <a href="http://item.jd.com/530220.html">闪迪（SanDisk）至尊超极速SDHC存储卡 8G-Class10-95MB/s</a> 查了<a href="http://elinux.org/RPi_SD_cards">树莓的SD卡兼容列表</a>显示可以识别，但159元的价格让我犹豫了。</p>

<p>研究了一段时间，发现有网友称树莓派对UHS-I类型的SD支持不好，目前树莓的控制器读取SD卡速度也就20-30M/s。后来选了 <a href="http://item.jd.com/679771.html">闪迪（SanDisk）至尊高速MicroSDHC（TF）存储卡 8G-Class10-30MB/s</a>， 39元搞定。</p>

<h3>安装rtl8188eu驱动模块</h3>

<p>现在进入正题，安装这块无线网卡的驱动是个痛苦的精力，虽然树莓派的官方论坛已经有几篇关于驱动TL-WN725N的帖子：</p>

<ul>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=66&amp;t=55779&amp;sid=946c22c3b95fea0e73539828e33018b1">Getting TL-WN725N working</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=28&amp;t=52932">TL-WN725N V2, raspbian driver update</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=91&amp;t=29752">TP-Link TL-WN725N V2 works out of the box on Raspbian</a></li>
</ul>


<p>但由于Raspbian的版本在不断的升级，生搬帖子上的步骤不起效果。</p>

<p>因为我的这个 <a href="http://item.jd.com/618066.html">TP-LINK TL-WN725N 微型150M无线USB网卡</a> 是先于树莓派购买闲置的。如果买新的话，强烈建议买免驱的无线网卡，省得折腾。比如说这款 <a href="http://item.jd.com/509932.html">EDUP EP-N8508GS黄金版 迷你USB无线网卡</a>.这里有一份<a href="http://elinux.org/RPi_USB_Wi-Fi_Adapters">树莓派支持的无线网卡清单</a></p>

<p>下的步骤是综合了上面的帖子及其引用，不断试错总结出来的步骤。</p>

<h4>确定网卡的版本</h4>

<p>TP-LINK TL-WN725N分<a href="http://wikidevi.com/wiki/TP-LINK_TL-WN725N_v1">V1</a>, <a href="http://wikidevi.com/wiki/TP-LINK_TL-WN725N_v2">V2</a>版本。 <br/>
<img src="http://codelife.me/images/post/2013-12-14/tl-wn725n.jpg" alt="" /></p>

<p>将无线网卡插上树莓的USB接口，执行<code>lsusb</code>返回如下</p>

<blockquote><p>Bus 001 Device 004: ID 0bda:8179 Realtek Semiconductor Corp.</p></blockquote>

<p>因为V1和V2的ID代号分别是0bda:8176、0bda:8179。</p>

<p>本文只针对V2版本，V1版本未经测试。</p>

<h4>升级内核</h4>

<pre><code>sudo rpi-update
</code></pre>

<p>升级后执行<code>uname -a</code>的结果是</p>

<blockquote><p>Linux raspberrypi 3.10.24+ #610 PREEMPT Thu Dec 12 13:12:09 GMT 2013 armv6l GNU/Linux</p></blockquote>

<h4>编辑驱动模块</h4>

<pre><code>git clone --depth 1 git://github.com/raspberrypi/linux.git rpi-linux

git clone --depth 1 git://github.com/raspberrypi/firmware.git rpi-firmware

git clone git://github.com/lwfinger/rtl8188eu.git rtl8188eu

cd rpi-linux

make mrproper

zcat /proc/config.gz &gt; .config

make modules_prepare

cp ../rpi-firmware/extra/Module.symvers .

cd ../rtl8188eu

CONFIG_RTL8188EU=m make -C ../rpi-linux M=`pwd`

sudo cp rtl8188eufw.bin /lib/firmware/rtlwifi

sudo install -p -m 644 8188eu.ko /lib/modules/`uname -r`/kernel/drivers/net/wireless

sudo insmod /lib/modules/`uname -r`/kernel/drivers/net/wireless/8188eu.ko

sudo depmod -a
</code></pre>

<h4>验证网卡是否识别</h4>

<p>若上面的命令执行过程没有报错，执行<code>iwconfig</code>的结果如下</p>

<pre><code>wlan0     IEEE 802.11bgn  ESSID:"22_1707"  Nickname:"&lt;WIFI@REALTEK&gt;"
          Mode:Managed  Frequency:2.457 GHz  Access Point: D4:EE:07:04:0D:E6
          Bit Rate:150 Mb/s   Sensitivity:0/0
          Retry:off   RTS thr:off   Fragment thr:off
          Power Management:off
         Link Quality=0/100  Signal level=15/100  Noise level=0/100
         Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
         Tx excessive retries:0  Invalid misc:0   Missed beacon:0

lo        no wireless extensions.

eth0      no wireless extensions.
</code></pre>

<p>证明无线网卡已被识别，下面我们来配置网络参数。</p>

<h4>配置无线网络参数</h4>

<p>打开/etc/wpa_supplicant/wpa_supplicant.conf文件，添加如下内容</p>

<pre><code>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid="NETWORK_NAME"
    psk="NETWORK_PASSWORD"
}
</code></pre>

<p>上面的方法psk是明文，如果觉得敏感，可以使用下面的命令生成密文</p>

<pre><code>wpa_passphrase ssid pass_phrase
</code></pre>

<p>输出如下</p>

<pre><code>network={
        ssid="myrouter"
        #psk="thisisalongpassphrasenobodycanguess"
        psk=fd50e5fb2b66493702338dd5175241d2e8dd7dd42fc292bbb7c56b01f9e9fdc0
}
</code></pre>

<p>将输出结果添加到/etc/wpa_supplicant/wpa_supplicant.conf文件。</p>

<p>重启网络服务<code>sudo service networking reload</code>后</p>

<p>执行<code>ifconfig</code>，如果wlan0获得IP就可以使用了</p>

<pre><code>wlan0     Link encap:Ethernet  HWaddr 14:cf:92:b5:59:6d
          inet addr:192.168.199.109  Bcast:192.168.199.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8805 errors:0 dropped:15 overruns:0 frame:0
          TX packets:600 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:2542242 (2.4 MiB)  TX bytes:82318 (80.3 KiB)
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://smhaziq.blogspot.co.at/2013/06/compiling-tp-link-wn725n-v2-driver-in.html">Compiling TP-LINK WN725N V2 driver in Raspbmc with 3.6.11 kernel</a></li>
<li><a href="https://github.com/liwei/rpi-rtl8188eu">Linux driver for tplink-wn725n nano wireless adapter</a></li>
<li><a href="http://blog.pi3g.com/2013/10/easy-tp-link-tl-wn725-driver-installation/">Easy TP-Link TL-WN725 driver installation</a></li>
<li><a href="http://www.fars-robotics.net/">Fars Robotics Website</a></li>
<li><a href="http://undiff.com/2008/08/wireless-with-wpa_supplicant-easier-then-you-think/">Wireless with wpasupplicant easier then you think</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google屏蔽Linode的IPv6导致SSH隧道不可用]]></title>
    <link href="http://codelife.me/blog/2013/11/16/google-block-linode-traffic-over-ipv6/"/>
    <updated>2013-11-16T01:48:00+08:00</updated>
    <id>http://codelife.me/blog/2013/11/16/google-block-linode-traffic-over-ipv6</id>
    <content type="html"><![CDATA[<blockquote><p>最近几个月通过linode的SSH隧道访问Google都会报出类似“We‘re sorry”或者“unusual traffic”的错误，有时需要输入验证码，但大多数时候直接不可用。一段时间使用GoAgent比较多，可惜GoAgent有时不太稳定。</p></blockquote>

<p>Google了一番，才知道是因为Google屏蔽了Linode服务器的IPv6协议导致SSH隧道出问题的。
下面我们就来关闭Ubuntu的IPv6</p>

<h3>关闭Ubuntu的IPv6</h3>

<ul>
<li><p>编辑 <code>/etc/sysctl.conf</code>,添加如下内容</p>

<p>  net.ipv6.conf.all.disable_ipv6=1<br/>
  net.ipv6.conf.default.disable_ipv6=1<br/>
  net.ipv6.conf.lo.disable_ipv6=1</p></li>
</ul>


<p>如上修改虽然是永久性的需要重启网卡才能生效<code>/etc/init.d/networking restart</code></p>

<ul>
<li><p>实时生效</p>

<p>  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/lo/disable_ipv6<br/>
  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/lo/disable_ipv6<br/>
  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/all/disable_ipv6<br/>
  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/default/disable_ipv6</p></li>
</ul>


<p>再试试通过SSH隧道搜索Google，是不是已经好了，^_^。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="https://forum.linode.com/viewtopic.php?f=20&amp;t=10436">Intermittent &ldquo;We&rsquo;re sorry&rdquo; error accessing Google via IPv6</a></li>
<li><a href="http://en.kioskea.net/faq/759-ubuntu-disabling-ipv6-support">Ubuntu &ndash; Disabling IPv6 support</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS X替换Razer的状态栏图标]]></title>
    <link href="http://codelife.me/blog/2013/11/16/replace-razer-status-bar-icon-in-macos/"/>
    <updated>2013-11-16T01:37:00+08:00</updated>
    <id>http://codelife.me/blog/2013/11/16/replace-razer-status-bar-icon-in-macos</id>
    <content type="html"><![CDATA[<blockquote><p>心爱的QeathAdder炼狱蝰蛇变形金刚款，用了300多天左键坏了，联系易迅给换了个QeathAdder炼狱蝰蛇2013款。虽然黑色的外观不如变形金刚款银色的配MacBook，但是6400dpi的分辨率，着实给力。CS:GO的甩狙命中率显著提升，开始以为年纪大了水平下降了，换鼠标后，发现还是鼠标的问题。话说Razer鼠标的管理界面支持登录以后保存鼠标配置的功能很好，就是状态栏的蓝色图标和Mac OS统一的暗灰色图标比起来太不协调了。</p></blockquote>

<p>默认效果</p>

<p><img src="http://codelife.me/images/post/2013-11-16/replace_before.png" alt="" /></p>

<p>替换后的效果</p>

<p><img src="http://codelife.me/images/post/2013-11-16/replace_after.png" alt="" /></p>

<p>替换图标</p>

<p><img src="http://codelife.me/images/post/2013-11-16/Status.png" alt="" /></p>

<h3>替换图标</h3>

<ol>
<li>在Finder里找到<code>/Library/Application Support/Razer/RzUpdater.app</code>
Command+Shift+G打开GO to对话框，输入<code>/Library/Application Support/Razer</code></li>
<li>右键RzUpdater.app显示包内容</li>
<li>然后再进入<code>Contents/Resources</code>目录</li>
<li>用上面的图标替换Status.png文件即可。</li>
<li>重启系统或者杀掉RzUpdater进程</li>
</ol>


<h3>参考阅读</h3>

<ol>
<li><a href="http://forums.macrumors.com/showthread.php?t=1432198">Razer DeathAdder Icon in Menubar (Synapse 2.0)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Mac正确的识别Noppoo Chic Mini84]]></title>
    <link href="http://codelife.me/blog/2013/11/13/noppoo-chic-mini84-osx-support/"/>
    <updated>2013-11-13T14:44:00+08:00</updated>
    <id>http://codelife.me/blog/2013/11/13/noppoo-chic-mini84-osx-support</id>
    <content type="html"><![CDATA[<blockquote><p>半年前入了一把Noppoo的84键茶轴机械键盘，这把键盘的手感真心不错，也非常的小巧，很短，放在桌上也一点都不占位置。唯一的缺点就是不支持Mac系统。官方未提供mac版本的驱动程序，在mac系统下有部分键不好用。网上倒是提供了两种解决方案：一种是usb转ps2，再ps2转usb两次转换以后就好用了（依靠转换器里的芯片）；另一个种是安装Github上的<a href="https://github.com/thefloweringash/iousbhiddriver-descriptor-override">第三方驱动</a>。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-11-13/noppoo-chic-mini84.jpg" alt="Noppoo Chic Mini84" /></p>

<p>两种方法都有试过，两次转换可以免去装驱动的麻烦，但是由于接了两个转换器，有时候会接触不好。最后选用了加装驱动的方案。</p>

<!-- more -->


<h3>加装驱动</h3>

<ul>
<li><p>pkg安装包 <a href="https://thefloweringash.com/iousbhiddriver-descriptor-override/downloads/IOUSBHIDDriverDescriptorOverride-2013-04-21-b545d15.pkg">https://thefloweringash.com/iousbhiddriver-descriptor-override/downloads/IOUSBHIDDriverDescriptorOverride-2013-04-21-b545d15.pkg</a></p></li>
<li><p>编译安装</p>

<ol>
<li> 下载源码 <a href="https://github.com/thefloweringash/iousbhiddriver-descriptor-override/archive/master.zip">https://github.com/thefloweringash/iousbhiddriver-descriptor-override/archive/master.zip</a></li>
<li> 编译</li>
</ol>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># dependencies
</span><span class='line'>gem install bundler
</span><span class='line'>bundle install --without scan
</span><span class='line'>
</span><span class='line'># build
</span><span class='line'>xcodebuild
</span><span class='line'>sudo cp -r build/Release/IOUSBHIDDriverDescriptorOverride.kext \
</span><span class='line'>    /System/Library/Extensions
</span><span class='line'>sudo kextutil \
</span><span class='line'>    /System/Library/Extensions/IOUSBHIDDriverDescriptorOverride.kext</span></code></pre></td></tr></table></div></figure>


<pre><code>3. 启动时加载，把com.apple.IOUSBHIDDriverDescriptorOverride.plist复制到/Library/LaunchDaemons/下面
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>launchctl load -w /Library/LaunchDaemons/com.apple.IOUSBHIDDriverDescriptorOverride.plist
</span><span class='line'>launchctl list | grep om.apple.IOUSBHIDDriverDescriptorOverride</span></code></pre></td></tr></table></div></figure>


<h3>安装KeyRemap4MacBook</h3>

<p>下载地址 <a href="https://pqrs.org/macosx/keyremap4macbook/">https://pqrs.org/macosx/keyremap4macbook/</a></p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://likidu.com/noppoo-chic-mini84-osx-support/">Noppoo Chic Mini 84支持Mac OS X</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
