<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Code Life]]></title>
  <link href="http://codelife.me/atom.xml" rel="self"/>
  <link href="http://codelife.me/"/>
  <updated>2014-07-04T23:03:19+08:00</updated>
  <id>http://codelife.me/</id>
  <author>
    <name><![CDATA[Vangie Du]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[当元素滚动出可视区域后固定漂浮在底部]]></title>
    <link href="http://codelife.me/blog/2014/06/22/fixed-floating-bottom-when-element-scroll-out-of-client-area/"/>
    <updated>2014-06-22T00:28:05+08:00</updated>
    <id>http://codelife.me/blog/2014/06/22/fixed-floating-bottom-when-element-scroll-out-of-client-area</id>
    <content type="html"><![CDATA[<blockquote><p>页面底部放置了几个功能按钮，当页面长度超过窗口高度时需要滚动到底部才能操作。点击按钮前多了一步滚动操作，多少有些不方便。如果元素位于可视区域之外时，可以固定漂浮于窗口底部就可以解决这种不便。</p></blockquote>

<p><img src="http://codelife.me/images/post/2014-06-22/fixed-floating.png" alt="不在可视区域内时固定漂浮于底部" /></p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="c1">#声明全局top变量，记录元素里页面顶部高度值</span>
</span><span class='line'><span class="nv">top = </span><span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 计算top值</span>
</span><span class='line'><span class="nv">calcTop = </span><span class="nf">-&gt;</span>
</span><span class='line'>  <span class="nv">$ff_container = </span><span class="nx">$</span><span class="p">(</span><span class="s">&#39;form:visible .panel-footer&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="nv">top = </span><span class="nx">$ff_container</span><span class="p">.</span><span class="nx">offset</span><span class="p">().</span><span class="nx">top</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">unless</span> <span class="nx">jQuery</span><span class="p">.</span><span class="nx">browser</span><span class="p">.</span><span class="nx">mobile</span>
</span><span class='line'>    <span class="nx">top</span> <span class="o">+=</span> <span class="nx">$ff_container</span><span class="p">.</span><span class="nx">outerHeight</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 判断是否需要固定漂浮</span>
</span><span class='line'><span class="nv">floating = </span><span class="nf">-&gt;</span>
</span><span class='line'>  <span class="nv">y = </span><span class="nx">$win</span><span class="p">.</span><span class="nx">scrollTop</span><span class="p">()</span> <span class="o">+</span> <span class="nx">$win</span><span class="p">.</span><span class="nx">height</span><span class="p">()</span>
</span><span class='line'>  <span class="nv">$ff_container = </span><span class="nx">$</span><span class="p">(</span><span class="s">&#39;form:visible .panel-footer&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="nx">y</span> <span class="o">&gt;=</span> <span class="nx">top</span>
</span><span class='line'>    <span class="nx">$ff_container</span><span class="p">.</span><span class="nx">removeClass</span><span class="p">(</span><span class="s">&#39;fixed&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="nx">$ff_container</span><span class="p">.</span><span class="nx">addClass</span><span class="p">(</span><span class="s">&#39;fixed&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 窗口滚动时计算是否需要漂浮</span>
</span><span class='line'><span class="nx">$win</span><span class="p">.</span><span class="nx">scroll</span><span class="p">(</span><span class="nx">floating</span><span class="p">)</span>
</span><span class='line'><span class="c1"># 调整窗口大小时计算是否需要漂浮</span>
</span><span class='line'><span class="nx">$win</span><span class="p">.</span><span class="nx">resize</span><span class="p">(</span><span class="nx">floating</span><span class="p">)</span>
</span><span class='line'><span class="c1"># 在手机屏幕滚动时计算是否需要漂浮</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s">&#39;body&#39;</span><span class="p">).</span><span class="nx">bind</span><span class="p">(</span><span class="s">&#39;touchmove&#39;</span><span class="p">,</span> <span class="nx">floating</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nx">calcTop</span><span class="p">()</span>
</span><span class='line'><span class="nx">floating</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考阅读</h3>

<ol>
<li><a href="http://jqueryfordesigners.com/fixed-floating-elements/">Fixed Floating Elements</a></li>
<li><a href="http://stackoverflow.com/questions/8644248/jquery-fix-div-when-browser-scrolls-to-it">jQuery: Fix div when browser scrolls to it</a></li>
<li><a href="http://stackoverflow.com/questions/18753367/jquery-live-scroll-event-on-mobile-work-around">jQuery: Fix div when browser scrolls to it</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Capistrano在每台应用服务器上都执行数据库迁移]]></title>
    <link href="http://codelife.me/blog/2014/05/20/db-migrate-all-app-by-capistrano/"/>
    <updated>2014-05-20T23:47:44+08:00</updated>
    <id>http://codelife.me/blog/2014/05/20/db-migrate-all-app-by-capistrano</id>
    <content type="html"><![CDATA[<blockquote><p>Capistrano发布Rails app到远端服务器时，只在primary db服务器上执行db:migrate。对于每个app都使用独立的本地Sqlite数据库的场景不适用。</p></blockquote>

<p>通过添加如下task，在每台app服务器上执行db:migrate</p>

<pre><code>#lib/capistrano/task/migrate_all.rake

desc 'Runs rake db:migrate on all app server'
task :migrate_all =&gt; [:set_rails_env] do
    on roles(:app), in: :parallel do
        within release_path do
            with rails_env: fetch(:rails_env) do
                execute :rake, "db:migrate"
            end
        end
    end
end

after :updated, :migrate_all
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Master-Agent模式的Rails应用借助JWT Token验证]]></title>
    <link href="http://codelife.me/blog/2014/05/17/rails-app-authenticate-by-jwt-between-master-and-agent/"/>
    <updated>2014-05-17T17:35:50+08:00</updated>
    <id>http://codelife.me/blog/2014/05/17/rails-app-authenticate-by-jwt-between-master-and-agent</id>
    <content type="html"><![CDATA[<blockquote><p>一对Master-Agent模式Rails应用，Agent需要验证Master。通常考虑采用HTTP基础认证或者HTTP摘要认证。这里Agent不需要多用户支持，所以只要一个加密口令即可，无需用户名。本文介绍采用JWT实现基于Token验证，结合Rails 4.1的新特性，装载secrets.yml文件里的密钥，作为JWT Token的计算密钥，应用于Rails应用。</p></blockquote>

<h3>Agent端配置</h3>

<h4>安装jwt Gem</h4>

<p>Gemfile添加如下行</p>

<pre><code>gem 'jwt'
</code></pre>

<p>然后执行<code>bundle install</code></p>

<!-- more -->


<h4>让所有Controller验证JWT Token</h4>

<p>编辑<code>app/controllers/application_controller.rb</code>文件，</p>

<pre><code>require 'jwt'
class ApplicationController &lt; ActionController::Base
    ...
before_action :validate_token

# Validate JWT token
def validate_token
    begin
    authz_header = request.headers['Authorization']
    if authz_header.nil?
        raise SecurityError.new("Authorization Header is missing")
    end
    token = authz_header.split(' ').last
    JWT.decode(token, Rails.application.secrets.jwt_secret_key)
    rescue JWT::DecodeError, SecurityError
    render nothing: true, status: :unauthorized
    end
end
    ...
end
</code></pre>

<p>其中密钥<code>Rails.application.secrets.jwt_secret_key</code>需要配置<code>config/secrets.yml</code>。</p>

<h4>配置config/secrets.yml</h4>

<pre><code>development:
    secret_key_base: c5e867eee171336e0b00d648a3d73cd176379ad9bc556ccc34102a046893c451add2b2fccb6d3ea914834cd9737e6ca432ecdf6cef8c81b61b79c8cad412ac88
    jwt_secret_key: c5e867eee171336e0b00d648a3d73cd176379ad9bc556ccc34102a046893c451add2b2fccb6d3ea914834cd9737e6ca432ecdf6cef8c81b61b79c8cad412ac88

test:
    secret_key_base: eaddadc7e11e7228c78670537d53a5b62d5b3908a84dcad6340c4a8104052b9043271bb03ae1ce11b03efe72ce4547aec61a9b71891451568a1084c80ba388d2
    jwt_secret_key: c5e867eee171336e0b00d648a3d73cd176379ad9bc556ccc34102a046893c451add2b2fccb6d3ea914834cd9737e6ca432ecdf6cef8c81b61b79c8cad412ac88

# Do not keep production secrets in the repository,
# instead read values from the environment.
production:
    secret_key_base: &lt;%= ENV["SECRET_KEY_BASE"] %&gt;
    jwt_secret_key: &lt;%= ENV["JWT_SECRET_KEY"] %&gt;
</code></pre>

<p>开发和测试环境取静态值，部署环境取环境变量的值。</p>

<h4>配置.env文件存放环境变量</h4>

<p>安装 dotenv gem，修改Gemfile，添加如下行</p>

<pre><code>gem 'dotenv-rails'
</code></pre>

<p><strong>请将&#8217;dotenv-rails&#8217;放在其他依赖环境变量的gem的前面</strong>，保存后执行<code>bundle install</code></p>

<p>Rails.Root目录新建<code>.env</code>文件</p>

<pre><code>JWT_SECRET_KEY: 4efe25e7fb153c392baf0787ee78c153a4fba5e6d7c8715b4a03849cd8a13b064ad2a636845e6753481613111dffb3c48c9a5a84fc38d50b757b3a2f46b8a493
SECRET_KEY_BASE: 2d78298e02650fefd0381ae0be261064466ac028567a8c5d113b46f0e4696d3153b8bac9ab62828b2befc08c48b009678d4b5de0f47b72f7e5fce51800ce5fee
</code></pre>

<p>然后将<code>.env</code>添加到<code>.gitignore</code>里去，防止其被提交到版本库</p>

<h4>与Capistrano集成</h4>

<p>修改config/deploy.rb文件，添加如下Task</p>

<pre><code>namespace :deploy do
    desc 'Generate Secret key to .env file'
task :generate_sceret_key do
    on roles(:app), in: :parallel do
    within release_path do
        if test("! grep -q JWT_SECRET_KEY #{release_path.join('.env')}")
            execute :rake, 'env:generate_secret[JWT_SECRET_KEY]'
        end
        if test("! grep -q SECRET_KEY_BASE #{release_path.join('.env')}")
            execute :rake, 'env:generate_secret[SECRET_KEY_BASE]'
        end     
        end
    end
    end
    after :updated, :generate_sceret_key
end
</code></pre>

<h3>Master端配置</h3>

<p>采用RestClient与Agent端进行通信，需要在请求的头部加入JWT Token以通过Agent端验证。</p>

<pre><code>#sync with agent
def sync
    res = site['sync.json'].get
    json =  JSON::parse(res.body)
    puts json
end

#generate jwt token
def generate_token
    unless self.secret_key.nil?
        self.token = JWT.encode("something_to_secret", self.secret_key)
    end
end

private
    def site
        @_site ||= RestClient::Resource.new(self.endpoint, :headers =&gt; {"Authorization" =&gt; "Bearer #{self.token}"})
    end
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://blog.yanted.com/2014/02/13/jwt-based-authentication-with-ember-js-and-rails/">JWT based authentication with Ember.js and Rails</a></li>
<li><a href="https://github.com/bkeepers/dotenv">Loads environment variables from &lsquo;.env&rsquo;</a></li>
<li><a href="http://www.jamesbadger.ca/2012/12/18/generate-new-secret-token/">Generate a New Secret Token for Rails Apps</a></li>
<li><a href="http://daniel.fone.net.nz/blog/2013/05/20/a-better-way-to-manage-the-rails-secret-token/">A better way to manage the Rails secret token</a></li>
<li><a href="http://edgeguides.rubyonrails.org/4_1_release_notes.html#config/secrets.yml">Rails 4.1 generates a new secrets.yml file in the config folder</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将Git提交版本号作为Rails应用版本号]]></title>
    <link href="http://codelife.me/blog/2014/05/17/using-git-commit-version-as-version-number-of-rails-app/"/>
    <updated>2014-05-17T14:02:04+08:00</updated>
    <id>http://codelife.me/blog/2014/05/17/using-git-commit-version-as-version-number-of-rails-app</id>
    <content type="html"><![CDATA[<blockquote><p>应用的版本管理和代码的版本管理通常是分开的，作为两套独立的版本系统来维护。对于小型应用来说有些浪费精力。最早在<a href="https://www.gitlab.com/">GitLab</a>这款开源软件上看到其使用Git的提交版本号作为版本号，本文将借鉴这种做法。</p></blockquote>

<h3>获得Git版本号</h3>

<ol>
<li>开发环境，当前的工作目录里包含了<code>.git</code>目录，直接执行下面的命令<code>git describe --always</code>。该命令通常返回形如<code>1f36a3b</code>的SHA-1短序列，但是如果该提交版本有对应的Tag的话，将返回该Tag名称。真实应用发布场景显得非常有用，毕竟随机序列不如自定义的有意义的名称便于记忆、沟通和传播。</li>
<li>对于<a href="http://capistranorb.com/">Capistrano</a>工具发布的生产环境，应用根目录不包含<code>.git</code>目录，所以如果通过<code>git</code>命令直接获得代码版本号，好在Capistrano发布时会自动生成<code>REVISION</code>文件，其内容为代码版本号。</li>
</ol>


<p>综合两种情况的代码如下</p>

<pre><code>if File.exist? 'REVISION' then `cat REVISION`.chomp else `git describe --always` end
</code></pre>

<!-- more -->


<h3>版本号作为静态变量</h3>

<p>上面我们讨论了在rails应用里通过代码获得版本号，但是版本号在应用系统相当于静态变量，在启动时候初始化，通过更有意义的名称（app_version）来引用会方便一些。</p>

<p>下面我们介绍如何结合<a href="https://github.com/binarylogic/settingslogic">settingslogic</a>，将版本号变成应用级的全局变量（通过<code>Settings.app_version</code>引用）。</p>

<p>在<code>Gemfile</code>里添加下面一行</p>

<pre><code>gem 'settingslogic'
</code></pre>

<p>然后执行<code>bundle install</code>.</p>

<p>向<code>config/application.yml</code>文件添加如下内容：</p>

<pre><code>#config/application.yml
defaults: &amp;defaults
    app_version: &lt;%= `git describe --always`%&gt;

development:
    &lt;&lt;: *defaults

test:
    &lt;&lt;: *defaults

production:
    &lt;&lt;: *defaults
</code></pre>

<p>修改<code>config/application.rb</code>文件
在<code>module AppName</code>（AppName 随应用名称而变）行之后添加</p>

<pre><code>class Settings &lt; Settingslogic
    source File.expand_path("../application.yml", __FILE__)
    namespace Rails.env
end
</code></pre>

<h3>HTTP响应包含版本号</h3>

<p>用Rails实现一个纯API应用，仅接受和响应JSON格式数据，将版本号添加到响应头部是一种不错的方法。</p>

<p>编辑<code>config/application.rb</code>在<code>class Application &lt; Rails::Application</code>里面加入</p>

<pre><code>config.action_dispatch.default_headers.merge!({ 
    'X-App-Version' =&gt; Settings.app_version 
})
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://blog.danielpietzsch.com/post/1209091430/show-the-version-number-of-your-rails-app-using-git">Show the version number of your Rails app using Git</a></li>
<li><a href="http://chriszetter.com/blog/2013/10/04/setting-headers-in-rails-4/">Setting headers in Rails 4</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Token的认证和基于声明的标识]]></title>
    <link href="http://codelife.me/blog/2014/03/26/token-based-authentication-and-claims-based-identity/"/>
    <updated>2014-03-26T14:12:05+08:00</updated>
    <id>http://codelife.me/blog/2014/03/26/token-based-authentication-and-claims-based-identity</id>
    <content type="html"><![CDATA[<blockquote><p>OpenID解决跨站点的认证问题，OAuth解决跨站点的授权问题。认证和授权是密不可分的。而OpenID和OAuth这两套协议出自两个不同的组织，协议上有相似和重合的之处，所以想将二者整合有些难度。好在OpenID Connect作为OpenID的下一版本，在OAuth 2.0的协议基础上进行扩展，很好的解决了认证和授权的统一，给开发者带来的便利。在学习和研究OpenID Connect协议时，遇上两个概念基于Token的认证（token based authentication）和基于声明的标识（claims based identity）。本文就这两个概念展开讨论，为了更好的理解OpenID Connect协议的原理。</p></blockquote>

<h3>基于Cookie的认证和基于Token的认证</h3>

<p>有两种不同的方法实现服务端的认证</p>

<ul>
<li>常见方式是<strong>基于Cookie的认证</strong>,每个请求中携带Cookie信息以便于服务端识别</li>
<li>另一种新方法，<strong>基于Token的认证</strong>，在每个请求中携带被签名过Token信息传送到服务端</li>
</ul>


<p><a href="https://docs.google.com/drawings/d/1IPgSFz2loaOIrnIKinGyrSoRm54slHFi8d_oRJ7BGPc/edit?usp=sharing"><img src="http://codelife.me/images/post/2014-03-26/cookie-based-auth-vs-token-based-auth.png" alt="Cookie-based Auth vs Token-based Auth" /></a></p>

<!-- more -->


<p>相比Cookie，基于Token的认证有如下好处：</p>

<ul>
<li><strong>跨域</strong>: cookies在跨域场景表现并不好。基于Token的方法允许你向任何不同域名的服务器发送Ajax请求，因为你可以通过HTTP头传递用户信息。</li>
<li><strong>无状态</strong>（或者 服务端可扩展）：无须再存储Session，由于Token已经自包含了所有的用户信息。</li>
<li><strong>内容分发</strong>：你可以将所有的静态资源（例如：脚本，HTML，图片等）分发到CDN服务上，你的服务器仅仅提供API。<a href="http://www.internap.com/cdn-services-content-delivery-network/cdn-user-authentication/">某些CDN服务商</a>提供了基于Token验证的安全服务。</li>
<li><strong>解耦</strong>：无须被绑定在一个特定的验证方案。</li>
<li><strong>移动支持</strong>：在移动设备的原生平台，使用cookie作为安全认证并不是好主意。采用基于Token的方法会简单得多。</li>
<li><strong>跨站点脚本攻击</strong>：由于没有基于cookie技术，你不再需要考虑跨站点请求的安全性问题。</li>
<li><strong>性能</strong>：虽然没有做严格的性能测试，但是还原session所做的数据库查询往返的性能损耗要大于<code>HMACSH256</code>算法验证和解析Token。</li>
<li><strong>基于标准</strong>：JWT(<a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token">JSON Web Token</a>)作为Token的标准已经被广泛的接受。主流语言（.NET, Ruby, Java, Python, PHP）都有相应支持JWT标准的工具包。</li>
</ul>


<h3>JWT格式</h3>

<p><abbr title="JSON Web Token">JWT</abbr>是一种紧凑的URL安全表示格式，适用于空格受限制的场景，比如HTTP授权头部和请求参数。JWT使用JSON格式表示一组声明，该JSON被编码成<abbr title="JSON Web Signature">JWS</abbr>或<abbr title="JSON Web Encryption">JWE</abbr>结构。</p>

<p>JWT是一段被base64url编码过的字符序列（去除了尾部的“=”），并用点号分隔。</p>

<p>下面是一个JWT头部的</p>

<div><script src='https://gist.github.com/9976068.js?file=headers.json'></script>
<noscript><pre><code>{
  &quot;typ&quot;: &quot;JWT&quot;,
  &quot;alg&quot;: &quot;HS256&quot;
}</code></pre></noscript></div>


<p>使用base64url编码以后</p>

<div><script src='https://gist.github.com/9976068.js?file=header_encoded'></script>
<noscript><pre><code>eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9</code></pre></noscript></div>


<p>下面是一个JWT的消息体其中包含声明集合</p>

<div><script src='https://gist.github.com/9976068.js?file=payload.json'></script>
<noscript><pre><code>{
  &quot;user_id&quot;: 1
}</code></pre></noscript></div>


<p>使用base64url编码以后</p>

<div><script src='https://gist.github.com/9976068.js?file=payload_encoded'></script>
<noscript><pre><code>eyJ1c2VyX2lkIjogMX0</code></pre></noscript></div>


<p>将上面编码过的JWS头部和JWS消息体使用HMAC SHA-256算法，并结合私钥计算得到的MAC，再经过base64url编码获得的字符序列成为JWS签名</p>

<div><script src='https://gist.github.com/9976068.js?file=signature'></script>
<noscript><pre><code>BSf1w1blYKcbxVlyOtUogUsozH2clY34xxYPd8lQIlQ</code></pre></noscript></div>


<p>将编码过的头部，消息体和JWS签名通过&#8217;.&lsquo;号连接起来，就获得JWT</p>

<div><script src='https://gist.github.com/9976068.js?file=jwt'></script>
<noscript><pre><code>eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJ1c2VyX2lkIjogMX0.BSf1w1blYKcbxVlyOtUogUsozH2clY34xxYPd8lQIlQ</code></pre></noscript></div>


<p>关于JWT的更多技术细节，请阅读<a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token">JWT规范</a>.</p>

<h3>基于声明的标识</h3>

<p>Cookie在请求和响应之间反复传递，对于无状态的HTTP协议，在Cookie里加入一个会话ID，以标识一组请求和响应属于同一会话。通常会话与用户是多对一关系，也就是说一个会话只会属于一个用户。所以通过Cookie技术就可以标识出用户。通常Cookie里也会携带一些额外的信息，但是考虑Cookie容易被截获和篡改，所以Cookie里并不适合放置用户的基本信息。</p>

<p>Token其实和Cookie类似是一段序列化字符串，作为HTTP请求头的一部分，发送到服务端。但是Token加入了签名机制，可以防篡改。所以Token可以包含用户信息发送给不同域的应用服务作为身份标识，只要相应的应用服务能识别其有效性。</p>

<p>Token仅仅是某种信息的承载形式，基于Token的认证有一个更宽泛的概念：基于声明的标识</p>

<p><a href="https://docs.google.com/drawings/d/1bSBW-rNfOUA4jsWVABXyuJklNY-hXI8QRMRtarh5Ek4/edit?usp=sharing"><img src="http://codelife.me/images/post/2014-03-26/claims-based-identity.png" alt="Claims based Identity" /></a></p>

<p>基于声明的标识其实无处不在，举个我们很熟悉的例子。</p>

<p>每次机场登机前过安检时，你不能简单地走到门口，并出示身份证。相反，必须先办理登机手续柜台。如果出国，还需要出示护照。安检人员先验证证件头像与你本人是否一致，然后核实您的信息，并确认您已经购买了机票。假设一切顺利，您将获得登机牌。</p>

<p>登机牌上包括知道您的姓名，航班号和座位号等常规信息。安检人员可以从登机牌上获得足够的信息以配合他们的工作。</p>

<p>登机牌上还有一些特殊信息，包含在条形码和背面的磁条里，以证明该登机牌是由航空公司签发的，而不是伪造的。</p>

<p>从本质上说，登机牌是一个由航空公司签发的关于你的一组信息。它表明你被允许某时登上某飞机坐在某个座位。当然，安检人员不必深入地理解这些。他们只需验证您的登机牌，读取其中的信息，然后让你登机。</p>

<p>同样值得注意的是，可能有不止一种方法获得您的登机牌。可能去机场售票柜台领取，或者在家里从航空公司网站下载并打印。安检人员不在乎的登机牌是如何获得的 。他们只关心登机牌是否真实的。</p>

<p>登机牌就是一张包含了一组声明信息的卡片，是Token的一种实体形式。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://book.douban.com/subject/5303216/">《A Guide to Claims-Based Identity and Access Control》</a></li>
<li><a href="http://dotnetcodr.com/2014/01/20/introduction-to-oauth2-json-web-tokens/">Introduction to OAuth2: Json Web Tokens</a></li>
<li><a href="http://www.layer7tech.com/blogs/index.php/give-me-a-jwt-ill-give-you-an-access-token/">Give Me a JWT, I’ll Give You an Access Token</a></li>
<li><a href="http://en.wikipedia.org/wiki/Claims-based_identity">Claims-based identity</a></li>
<li><a href="http://blog.auth0.com/2014/01/07/angularjs-authentication-with-cookies-vs-token/">Cookies vs Tokens. Getting auth right with Angular.JS</a></li>
<li><a href="http://jpadilla.com/post/73791304724/auth-with-json-web-tokens">Auth with JSON Web Tokens</a></li>
<li><a href="http://openid.net/specs/draft-jones-json-web-token-07.html">JSON Web Token (JWT) draft-jones-json-web-token-07</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java泛型让声明方法返回子类型]]></title>
    <link href="http://codelife.me/blog/2014/03/05/returning-subtype-of-declared-type-from-method-by-java-generics/"/>
    <updated>2014-03-05T11:11:45+08:00</updated>
    <id>http://codelife.me/blog/2014/03/05/returning-subtype-of-declared-type-from-method-by-java-generics</id>
    <content type="html"><![CDATA[<blockquote><p>泛型典型的使用场景是集合。考虑到大多数情况下集合是同质的（同一类型），通过声明参数类型，可免去类型转换的麻烦。本文将讨论本人阅读Spring Security源码时遇到的一个关于<strong><em>泛型递归模式</em></strong>的问题。</p></blockquote>

<h3>声明方法返回子类型</h3>

<p>在Spring Security的源码里有一个<code>ProviderManagerBuilder</code>接口，声明如下</p>

<pre><code>public interface ProviderManagerBuilder&lt;B extends ProviderManagerBuilder&lt;B&gt;&gt; extends SecurityBuilder&lt;AuthenticationManager&gt; {
    B authenticationProvider(AuthenticationProvider authenticationProvider);
}
</code></pre>

<p>其实现类<code>AuthenticationManagerBuilder</code></p>

<pre><code>public class AuthenticationManagerBuilder extends AbstractConfiguredSecurityBuilder&lt;AuthenticationManager, AuthenticationManagerBuilder&gt; implements ProviderManagerBuilder&lt;AuthenticationManagerBuilder&gt; {

    //...

    public AuthenticationManagerBuilder authenticationProvider(
        AuthenticationProvider authenticationProvider) {
        this.authenticationProviders.add(authenticationProvider);
        return this;
    }

    //...

}
</code></pre>

<p>上面有很多干扰项，我们来简化一下</p>

<!-- more -->


<p>接口<code>A</code>定义如下</p>

<pre><code>public interface A&lt;T extends A&lt;T&gt;&gt; {

    T add();

}
</code></pre>

<blockquote><p>说明：<code>A</code>接口只有一个<code>add</code>方法，返回泛型<code>T</code>。<code>T</code>的声明有些饶<code>&lt;T extends A&lt;T&gt;&gt;</code>。</p></blockquote>

<p><code>A</code>接口的实现类<code>B</code></p>

<pre><code>public class B implements A&lt;B&gt; {

    @Override
    public B add() {
        return null;
    }

}
</code></pre>

<p>注意，此处类<code>B</code>里的add方法返回类型<code>B</code>。也就是说，接口<code>A</code>里声明的方法时并不知道子类型<code>B</code>的存在，通过继承和泛型，可以放返回值动态的适配子类型，这一切都要归功于<code>&lt;T extends A&lt;T&gt;&gt;</code></p>

<h3>泛型递归模式（Recurring Generic Pattern）</h3>

<p><code>public interface A&lt;T extends A&lt;T&gt;&gt;</code>对于参数类型<code>T</code>是递归定义的。有如GNU的定义“GNU&rsquo;s Not Unix!”。</p>

<p>典型的例子是<code>java.lang.Enum</code></p>

<pre><code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;
    implements Comparable&lt;E&gt;, Serializable {
    //...
}
</code></pre>

<blockquote><p>java所有的枚举类型都隐式的继承<code>java.lang.Enum</code>，不允许通过现实的继承声明枚举类型，甚至集成<code>java.lang.Enum</code>也是编译器所不允许的。</p></blockquote>

<p>假设有一个枚举类<code>StatusCode</code>,其等价的声明如下</p>

<pre><code>public class StatusCode extends Enum&lt;StatusCode&gt;
</code></pre>

<p>现在我们来验证一下泛型约束，</p>

<ol>
<li>因为<code>Enum&lt;StatusCode&gt;</code>,所以<code>E=StatusCode</code></li>
<li>根据<code>&lt;E extend Enum&lt;E&gt;&gt;</code> 和 <code>E=StatusCode</code> 可得，<code>&lt;StatusCode extend Enum&lt;StatusCode&gt;&gt;</code>，</li>
<li>由于<code>public class StatusCode extends Enum&lt;StatusCode&gt;</code>第二步的结论显然成立。</li>
</ol>


<h4>为什么Enum的声明这么绕？直接Enum<E>不行么？</h4>

<p>因为<code>Enum&lt;E&gt;</code>实现了<code>Comparable&lt;E&gt;</code>接口，该接口有一个<code>compareTo</code>方法</p>

<pre><code>public int compareTo(E o) {}
</code></pre>

<p><E extend Enum<E>>强制约束了进行<code>compareTo</code>的调用对象类型和参数类型都严格一致，不会出现子类和超类或者兄弟类之间的比较。</p>

<h3>泛型递归模式与继承</h3>

<p>泛型递归模式<code>interface A&lt;T extend A&lt;T&gt;&gt;</code>用于约束参数类型T，要求其为类型<code>A</code>的子类。考虑到继承和实现<code>B implements A&lt;B&gt;</code>,参数类型和实体类型是一致的。这样类<code>A</code>中方法签名里涉及到参数类型<code>T</code>的地方，在实现类里会为实现类本身，这让类型系统更加的严谨。</p>

<h3>参考文献</h3>

<ol>
<li><a href="http://stackoverflow.com/questions/211143/java-enum-definition">Java Enum definition</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html">Java Toturial &ndash; Enum Types</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL Select和关系操作]]></title>
    <link href="http://codelife.me/blog/2014/02/23/sql-select-and-relational-operations/"/>
    <updated>2014-02-23T19:55:31+08:00</updated>
    <id>http://codelife.me/blog/2014/02/23/sql-select-and-relational-operations</id>
    <content type="html"><![CDATA[<blockquote><p>没有系统的学习过关系数据库，所以对SQL Select的理解有些浅薄，特别是group by和having语句。<a href="http://book.douban.com/subject/7061934/">《SQLite 权威指南（第二版）》</a>的第三章SQLite中的SQL，让我对Select，乃至SQL语言和关系数据库有了全新的认识。一时间激起了对关系数据库和理论的兴趣，到豆瓣上淘了一本绝版的<a href="http://book.douban.com/subject/2122940/">《深度探索关系数据库》</a>，可惜基础太差，读了一半实在读不下去了，作罢。</p></blockquote>

<p>最大的收获和发现莫过于下面这幅图了，</p>

<p><img src="http://codelife.me/images/post/2014-02-23/select.png" alt="select处理过程" /></p>

<!-- more -->


<p>说明：</p>

<ul>
<li>多张表通过笛卡尔积（Cartesian Production）或者连接（Join）产生R1</li>
<li>R1到R2的过程称作限制（Restriction），即过滤掉不符合条件的行（元组）</li>
<li>R4到R5的过程称作投影（Projection），即选择出需要的列（属性）</li>
</ul>


<h3>参考阅读</h3>

<ol>
<li><a href="http://book.douban.com/subject/7061934/">《SQLite 权威指南（第二版）》</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将Gemfile模板文件的source改成淘宝源]]></title>
    <link href="http://codelife.me/blog/2014/02/03/modify-source-of-the-gemfile-template/"/>
    <updated>2014-02-03T21:54:20+08:00</updated>
    <id>http://codelife.me/blog/2014/02/03/modify-source-of-the-gemfile-template</id>
    <content type="html"><![CDATA[<blockquote><p>由于国内网络原因（你懂的），导致rubygems.org存放在Amazon S3上面的资源文件间歇性连接失败。所有你会遇到<code>gem install rack</code>或<code>bundle install</code>的时候半天没有响应。将默认源改成国内的淘宝源(<a href="http://ruby.taobao.org">http://ruby.taobao.org</a>)可以解决该问题。</p></blockquote>

<p>对于Rails项目通常需要将Gemfile的第一行改为</p>

<pre><code>    source 'http://ruby.taobao.org/'
</code></pre>

<p>但是通过<code>rails new my_project</code>创建项目时，由于Gemfile生成以后立即执行<code>bundle install</code>，此时source尚未修改，所以项目创建的过程仍然很慢。</p>

<p>解决rails new 卡住的问题，有如下两种方法</p>

<!-- more -->


<h3>使用<code>--skip-bundle</code>参数</h3>

<pre><code>rails new app1 --skip-bundle
</code></pre>

<p>通过设置<code>--skip-bundle</code>参数，<code>rails new</code> 命令创建完成项目骨架以后，不会执行<code>bundle install</code>。于是可以修改Gemfile行首的source，然后再执行<code>bundle install</code>。</p>

<h3>修改Gemfile模板</h3>

<p>使用如下命令，修改Gemfile模板文件，一劳永逸</p>

<h4>For Mac</h4>

<pre><code>/usr/bin/sed -i .bak 's!https://rubygems.org!http://ruby.taobao.org!' `rvm info homes | grep gem: | awk '{print $2}' | tr -d '"'`/gems/railties-`gem list | grep railties | awk '{print $2}'| tr -d '()'`/lib/rails/generators/rails/app/templates/Gemfile
</code></pre>

<h4>For Linux</h4>

<pre><code>sed -i 's!https://rubygems.org!http://ruby.taobao.org!' `rvm info homes | grep gem: | awk '{print $2}' | tr -d '"'`/gems/railties-`gem list | grep railties | awk '{print $2}'| tr -d '()'`/lib/rails/generators/rails/app/templates/Gemfile
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://ruby.taobao.org/">RubyGems 镜像 &ndash; 淘宝网</a></li>
<li><a href="http://snails.github.io/2012/06/04/Modify-the-Gemfile-Template/">修改Rails默认生成的Gemfile的source</a></li>
<li><a href="http://ruby-china.org/topics/914">run bundle install 卡住很久</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将树莓派配置成时间胶囊]]></title>
    <link href="http://codelife.me/blog/2013/12/21/raspberry-pi-as-time-capsule/"/>
    <updated>2013-12-21T21:00:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/21/raspberry-pi-as-time-capsule</id>
    <content type="html"><![CDATA[<blockquote><p>MacBookAir的SSD坏了两次以后，发现TimeMachine真的很有必要。外插个尿袋子真的不方便。AirPort Time Capsule 2T版本价格买到了$299，觉得有些不值。$25的树莓派+一块移动硬盘DIY一个Time Capsule即经济又有趣。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-12-21/raspberry-pi-as-time-capsule.png" alt="Raspberry Pi as TimeCapsule" /></p>

<!-- more -->


<h3>组件清单</h3>

<p><img src="http://codelife.me/images/post/2013-12-21/component-of-time-capsule.png" alt="Component of TimeCapsule" /></p>

<ul>
<li>树莓派

<ul>
<li>TF卡 + 卡套</li>
<li>USB WiFi 网卡</li>
<li>5V电源 + MicroUSB 电源线</li>
</ul>
</li>
<li>移动硬盘

<ul>
<li>2.5寸 500G SATA 硬盘</li>
<li>USB3.0 硬盘电路板</li>
<li>USB3.0 数据线</li>
</ul>
</li>
</ul>


<h3>安装HFS+文件系统工具</h3>

<pre><code>sudo apt-get install hfsplus hfsutils hfsprogs
</code></pre>

<h3>准备HFS+设备</h3>

<p>列出所有块设备</p>

<pre><code>sudo blkid
</code></pre>

<p>返回如下</p>

<pre><code>/dev/mmcblk0p1: LABEL="RECOVERY" UUID="F69B-A989" TYPE="vfat"
/dev/mmcblk0p3: LABEL="SETTINGS" UUID="7f8a9faf-84a1-4062-ab9c-b2e6115035ce" TYPE="ext4"
/dev/mmcblk0p5: LABEL="BOOT" UUID="03D6-2985" TYPE="vfat"
/dev/mmcblk0p6: LABEL="root" UUID="e2a46600-20ca-42f4-8ec8-aa52d258aad2" TYPE="ext4"
/dev/sda1: UUID="943f46c5-2de2-3ef9-8494-46c3cf8bd915" LABEL="Time Capsule" TYPE="hfsplus"
</code></pre>

<p>包含TYPE=“hfsplus”的即是。</p>

<p>如果希望把一个新的分区格式化为HFS+，使用如下命令</p>

<pre><code>sudo mkfs.hfsplus -v "Time Capsule" /dev/sda1
</code></pre>

<p><strong>建议使用全新的hfs+分区</strong>
把一块已经做过TimeMachine的hfs+分区，可能导致原有的备份数据丢失</p>

<h3>挂载</h3>

<pre><code>sudo mkidr /media/TimeCapsule
sudo mount -t hfsplus -o force /dev/sda1 /media/TimeCapsule
sudo chown -R pi:pi /media/TimeCapsule
</code></pre>

<h3>安装配置netatalk服务</h3>

<pre><code>sudo apt-get install netatalk
sudo echo "/media/TimeCapsule \"Time Capsule\" options:tm" &gt;&gt; /etc/netatalk/AppleVolumes.default
sudo service netatalk restart
</code></pre>

<p>接下来就可以从Mac的Time Machine里找到这块磁盘 <br/>
<img src="http://codelife.me/images/post/2013-12-21/avaliable-disk.png" alt="选择Time Machine磁盘" /></p>

<h3>配置Avahi</h3>

<p>安装<code>avahi-daemon</code>和<code>libnss-mdns</code></p>

<pre><code>sudo apt-get install avahi-daemon libnss-mdns
</code></pre>

<p>配置nsswitch.conf</p>

<p>在<code>hosts:</code>后添加“mdns”</p>

<pre><code>hosts:      files mdns4_minimal [NOTFOUND=return] dns mdns4 mdns
</code></pre>

<p>接下来让Avahi在局域网广播AFP共享</p>

<p>添加如下文件<code>/etc/avahi/services/afpd.service</code>内容如下：</p>

<pre><code>&lt;?xml version="1.0" standalone='no'?&gt;&lt;!--*-nxml-*--&gt;
&lt;!DOCTYPE service-group SYSTEM "avahi-service.dtd"&gt;
&lt;service-group&gt;
    &lt;name replace-wildcards="yes"&gt;%h&lt;/name&gt;
    &lt;service&gt;
        &lt;type&gt;_afpovertcp._tcp&lt;/type&gt;
        &lt;port&gt;548&lt;/port&gt;
    &lt;/service&gt;
    &lt;service&gt;
        &lt;type&gt;_device-info._tcp&lt;/type&gt;
       &lt;port&gt;0&lt;/port&gt;
        &lt;txt-record&gt;model=Xserve&lt;/txt-record&gt;
    &lt;/service&gt;
&lt;/service-group&gt;
</code></pre>

<p>重启服务</p>

<pre><code>sudo /etc/init.d/avahi-daemon restart
</code></pre>

<p>在findler的左侧可以看到共享的文件系统</p>

<p><img src="http://codelife.me/images/post/2013-12-21/share.png" alt="共享" /></p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.zisoft.de/elektronik/raspberrypi/timecapsule.html">Raspberry Pi als TimeCapsule</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=36&amp;t=47029">Use rPi as a Time Capsule &ndash; another method</a></li>
<li><a href="http://garmoncheg.blogspot.jp/2012/11/time-capsule-for-25.html">Time Capsule for $25</a></li>
<li><a href="http://andadapt.com/raspberry-pi-raspbian-hfs-afp-and-time-machine/">Raspberry Pi, Raspbian, HFS+, AFP and Time Machine</a></li>
<li><a href="http://kremalicious.com/ubuntu-as-mac-file-server-and-time-machine-volume/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+kremalicious+(kremalicious">HowTo: Make Ubuntu a Perfect Mac File Server and Time Machine Volume</a>)</li>
<li><a href="http://www.andyibanez.com/260-linux-file-server-os-x-mavericks">Making A Linux File Server That Interacts With OS X Mavericks</a></li>
<li><a href="http://netatalk.sourceforge.net/wiki/index.php/Install_Netatalk_v3_on_Debian">Install Netatalk v3 on Debian</a></li>
<li><a href="http://superuser.com/questions/558150/how-to-write-to-hfs-through-afp-netatalk-without-permission-denied-and-cnid-met">How to write to HFS+ through AFP/Netatalk without permission denied and cnid_metad error?</a></li>
<li><a href="http://www.afp548.com/2013/05/06/afp-services-on-a-linux-server/">Using Netatalk: AFP Services on a Linux Server</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pcDuino上手记]]></title>
    <link href="http://codelife.me/blog/2013/12/19/beginner-of-pcduino/"/>
    <updated>2013-12-19T15:05:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/19/beginner-of-pcduino</id>
    <content type="html"><![CDATA[<blockquote><p>感谢刘博士送的这块pcDuino板。入Raspberry Pi前，优先考虑过pcDuino。在OSChina源创会上海站被刘博士打动过。买Raspberry Pi是为了DIY一个Mac的Time Capsule。随便Google了一下，找到了Raspberry实现Time Capsule的相关资料，而pcDuino的相关资料没有找到，于是作罢。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-12-19/pcduinov2.jpg" alt="pcDuino V2" /></p>

<p>由于Raspberry Pi的先入为主，上手pcDuino碰到写问题，下面一一列出</p>

<!-- more -->


<h3>选什么TF卡</h3>

<p>关于如何选购Raspberry Pi的SD卡，我好生下了功夫，最后还是有不好收获的。没有话冤枉钱买极速的。</p>

<p><strong>兼容列表</strong> <br/>
pcDuino支持哪些TF卡，网上找不到兼容列表。可能是都支持吧，不需要。</p>

<p><strong>读写速度</strong> <br/>
最大支持到少读写速度也找不到资料。</p>

<p>后来得知板载的2G闪存里内置了ubuntu系统，于是TF卡的问题就先悬着吧，等搞清楚再做决定。</p>

<h3>启动pcDuino</h3>

<p>插上网线，pcDuino的网线口比Raspberry Pi的要小巧，但是有些过紧，拔出网线时候要小心，别弄断了。
插上电源线，指示灯亮了。</p>

<p>没有显示器，IP地址默认应该是DHCP的，先要找到IP地址。</p>

<p><strong>找到IP地址</strong></p>

<pre><code>arp-scan --localnet
</code></pre>

<p>如果发现主机名ubuntu，那就是了。要是没有就找Unknow的逐个ssh测试，能连接上的就是。</p>

<h3>初始化系统</h3>

<p>ssh登录系统以后先执行系统初始化</p>

<pre><code>sudo board-config.sh
</code></pre>

<h3>安装Vim</h3>

<p>一直不习惯原生的vi，对方向键支持不好。</p>

<pre><code>sudo apt-get install vim
</code></pre>

<p>安装不成功，返回如下</p>

<pre><code>Reading package lists... Done
Building dependency tree
Reading state information... Done

....省去若干行

Failed to fetch http://ports.ubuntu.com/ubuntu-ports/pool/main/p/python2.7/libpython2.7_2.7.3-0ubuntu3.2_armhf.deb  404  Not Found
E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?
</code></pre>

<p>一大堆404，提示先<code>apt-get update</code>,好吧</p>

<pre><code>sudo apt-get update
</code></pre>

<p>返回如下</p>

<pre><code>....省去若干行

Get:20 http://ports.ubuntu.com precise-updates/universe Translation-en [132 kB]
Fetched 2681 kB in 21s (123 kB/s)
Reading package lists... Done
W: Conflicting distribution: http://www.wiimu.com pcduino Release (expected pcduino but got )
</code></pre>

<p>编辑器打开<code>/etc/apt/sources.list</code>,注释掉最后两行</p>

<pre><code>#deb http://www.wiimu.com:8020/pcduino/ pcuino main
#deb-src http://www.wimu.com:8020/pcduion/ pcduino main
</code></pre>

<p>然后在<code>sudo apt-get update</code>就正常了。</p>

<h3>VNC远程桌面</h3>

<h4>设置vnc密码</h4>

<pre><code>sudo x11vnc -storepasswd
sudo x11vnc -storepasswd in /etc/x11vnc.pass
sudo cp .vnc/passwd /etc/x11vnc.pass
</code></pre>

<h4>启动桌面</h4>

<pre><code>sudo start lightdm
</code></pre>

<h4>连接</h4>

<p>在mac终端敲入</p>

<pre><code>open vnc://&lt;ip_of_pcduino&gt;
</code></pre>

<h4>已知问题</h4>

<p><code>sudo stop lightdm</code>再次<code>sudo start lightdm</code>启动后，客户端无法连接上VNC服务器。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.cnblogs.com/iscode/p/3200503.html">pcDuino 刷系统-卡刷</a></li>
<li><a href="http://www.cnblogs.com/iscode/p/3200558.html">pcDuino无显示器刷机与使用</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kindle PaperWhite作为树莓派的命令终端]]></title>
    <link href="http://codelife.me/blog/2013/12/17/kindle-pw-as-a-terminal-connect-to-raspberry-pi/"/>
    <updated>2013-12-17T03:14:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/17/kindle-pw-as-a-terminal-connect-to-raspberry-pi</id>
    <content type="html"><![CDATA[<blockquote><p>网上有大牛把Kindle作为树莓派的显示屏，外带一个Mac蓝牙键盘，实用移动电源供给。一个台低功耗的可移动主机，酷极了。手上真好有一台Kindle PaperWhite，于是开始折腾。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-12-17/kindle-berry.png" alt="KindleBerry" /></p>

<h3>准备工作</h3>

<ol>
<li>Raspberry Pi 一台</li>
<li>Kindle PaperWhite 一台（已<a href="http://www.mobileread.com/forums/showthread.php?t=198446">越狱</a>）</li>
<li>USB转microUSB数据线2根，一根给Raspberry Pi供电，一根作为Kindle和Raspberry Pi的连接线</li>
</ol>


<!-- more -->


<h3>安装USBNetwork</h3>

<p><a href="http://www.mobileread.com/forums/showthread.php?t=186645">USBNetwork</a>工具可以通过usb数据线连接kindle和另一台电脑，实现ssh登录。</p>

<p>安装步骤如下</p>

<ol>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=116323&amp;d=1386361702">Kindle-usbnet-0.1.5N.zip</a>，解压以后仔细阅读<code>README_FIRST.txt</code>文件</li>
<li>将update_usbnet_0.15.N_install_touch_pw.bin拷贝到Kindle根目录</li>
<li><p>Kindle里工具栏菜单[设置]&ndash;> 工具栏菜单[更新您的Kindle]，安装完成后会重启</p>

<p> <img src="http://codelife.me/images/post/2013-12-17/kindle_install_sw.png" alt="安装Kindle应用" /></p></li>
<li>安装完成以后Kindle更目录会多出一个<code>usbnet</code>目录和<code>extensions\usbnet</code>目录</li>
<li><p>编辑<code>usbnet\etc\config</code>文件，修改如下</p>

<pre><code> USE_WIFI="true"
 USE_OPENSSH="true"
</code></pre></li>
</ol>


<p><strong>开关USBNetwork模式</strong></p>

<blockquote><p>在Kindle的搜索框内，输入<code>;usbnetwork</code>或者<code>;un</code>。再输入一个可以切换。</p></blockquote>

<p><strong>查看网络状态</strong></p>

<blockquote><p>在Kindle的搜索框内，输入<code>;711</code>。可以查到当前无线网卡的IP地址</p></blockquote>

<h4>Mac通过USB线登录Kindle</h4>

<ol>
<li>用USB线连接Mac和Kindle</li>
<li>默认Kindle会被挂载成存储设备，先弹出该设备</li>
<li>然后开启Kindle的USBNetwork模式</li>
<li><p>Mac[系统偏好设置]&ndash;>[网络] 新建一个RNDIS/Ethernet Gadget链接配置如下</p>

<pre><code> ip:     192.168.15.201
 mask:   255.255.255.0
 router: 192.168.15.244
</code></pre>

<ul>
<li>如果无法创建RNDIS连接，可能需要安装<a href="http://joshuawise.com/horndis">HoRNDIS</a></li>
<li>router的地址要Kindle的<code>/usbnet/etc/config</code>文件里<code>KINDLE_IP</code>项一致</li>
</ul>
</li>
<li><p>终端SSH连接</p>

<pre><code> ssh root@192.168.15.244
</code></pre></li>
</ol>


<h4>通过WiFi登录Kindle</h4>

<ol>
<li>在Kindle的搜索框内，输入<code>;711</code>查找Kindle无线网卡IP</li>
<li>通过终端SSH连接即可</li>
</ol>


<p>到此Kindle的Network算配置完毕，下来我们来配置Kindle的Kterm</p>

<h3>安装KUAL和Kterm</h3>

<h4>KUAL</h4>

<p><a href="http://www.mobileread.com/forums/showthread.php?t=203326">KUAL</a>是Kindle Unified Application Launcher的缩写，其作用是为越狱的Kindle启动第三方应用。简单的说通过一本特殊的书籍来统一实现启动触发器。</p>

<ol>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=115571&amp;d=1385111909">prerequisites-all-supported-devices.zip</a></li>
<li>解压后将update_kindlet-dev-20130710-k5-ALL_install.bin文件拷贝到Kindle根目录，Kindle安装.bin文件的方法都是一样的，Kindle里点击[更新您的Kindle],然后会显示安装进度，自动重启后完成。</li>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=109526&amp;d=1376691043">KUAL.V.2.2.zip</a></li>
<li>解压后将KindleLauncher-2.0.azw2文件拷贝到Kindle的<code>/documents</code>目录</li>
<li>断开连接后Kindle里多了一本《Kindle Launcher》的书，点开有一排可以启动的应用列表。 <br/>
 <img src="http://codelife.me/images/post/2013-12-17/kindle_launcher.png" alt="Kindle Launcher" /><img src="http://codelife.me/images/post/2013-12-17/kindle_launcher_opened.png" alt="Kindle Launcher打开以后的效果" /></li>
</ol>


<h4>Extend</h4>

<p><code>Extend</code>是一组扩展的预编译好的linux命令行工具，让Kindle可以运行一些常用的linux命令，如：openssh，nano，screen，irssi，php，bash，rsync等。</p>

<ol>
<li>下载<a href="http://ge.tt/9Qoa9YD/v/0?c">optware_img_60m.zip</a>和<a href="http://ge.tt/9Qoa9YD/v/2?c">kindle_extend-1.1.zip</a></li>
<li>解压kindle_extend-1.1.zip到kindle_extend-1.1目录</li>
<li>解压optware_img_60m.zip将<code>optware.img</code>文件替换<code>kindle_extend-1.1/extend/optware.img</code>文件</li>
<li>将<code>kindle_extend-1.1</code>目录下的<code>extend</code>和<code>extensions</code>子目录拷贝到Kindle更目录</li>
<li><p>然后通过SSH登录Kindle执行如下命令</p>

<pre><code> mntroot rw
 mkdir /mnt/us/circles
 cp /mnt/us/extend/mountd /mnt/us/circles
 ln -s /mnt/us/circles/mountd /etc/rc5.d/S101mountd
 mntroot ro
 /mnt/us/install.sh
 /mnt/us/mount.sh
</code></pre></li>
</ol>


<h4>Kterm</h4>

<p><a href="http://www.fabiszewski.net/kindle-terminal/">Kterm</a>是一个内置虚拟键盘的GTK+的Kindle终端模拟器</p>

<p><img src="http://codelife.me/images/post/2013-12-17/kterm.gif" alt="Kterm效果图" /></p>

<ol>
<li>下载<a href="http://www.fabiszewski.net/kindle-terminal/kterm-0.7.zip">Kerm 0.7</a></li>
<li>解压后将<a href="https://dl.dropbox.com/s/tagzqiz06fbdltz/kterm-landscape-enabled.zip?token_hash=AAH5k68xlwcYqi065-n5Bu5XaoiEXB12zCDjj50udrRg_w&amp;dl=1">此文件</a>替换<code>kterm/bin/kterm</code>文件。具体看<a href="https://github.com/bfabiszewski/kterm/issues/2#issuecomment-14204814">这里</a></li>
<li>然后将<code>kterm</code>文件夹拷贝到Kindle的<code>extensions</code>目录下</li>
<li>断开Kindle与电脑的链接，通过KUAL打开Kterm，随便Ping台机器试试。</li>
</ol>


<h3>配置Raspberry Pi的USB网络连接</h3>

<p>安装了USBNetwork，Kindle已经可以通过数据线和Mac电脑连网，接下来配置Raspberry Pi的USB网络链接，使Kindle插入Raspberry Pi以后可以自动建立网络连接。</p>

<pre><code>sudo vim /etc/network/interfaces
</code></pre>

<p>添加如下内容</p>

<pre><code>#USB tethering
allow-hotplug usb0
iface usb0 inet static
    address 192.168.15.1
    netmask 255.255.255.0
    broadcast 192.168.15.255
    up iptables -I INPUT 1 -s 192.168.15.1 -j ACCEPT
    up eject /dev/sda1
</code></pre>

<ul>
<li><code>allow-hotplug usb0</code>表示插入USB后自动加载网络配置</li>
<li><code>up eject /dev/sda1</code>表示弹出Kindle自动挂载的磁盘分区</li>
</ul>


<p>重启网络</p>

<pre><code>sudo service networking reload
</code></pre>

<h3>见证奇迹的时刻</h3>

<ol>
<li>使用数据线连接Kindle和Raspberry Pi</li>
<li>开启USBNetwork模式，Kindle的搜索框内，输入<code>;un</code>然后回车</li>
<li><p>打开Kterm键入</p>

<p> ssh <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#112;&#105;&#64;&#49;&#57;&#50;&#46;&#49;&#x36;&#56;&#46;&#49;&#x35;&#x2e;&#49;">&#x70;&#x69;&#x40;&#49;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#x2e;&#x31;&#53;&#x2e;&#x31;</a></p></li>
</ol>


<p>若提示输入密码或者保存密钥指纹，说明大功告成。</p>

<p><strong>Kindle作为跳板机</strong></p>

<p>Kindle和Raspberry Pi顺利创建连接之后，Mac OS可以通过Kindle的Wifi连接SSH登录进Kindle，然后再次SSH登录进入Raspberry Pi。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.ponnuki.net/2012/09/kindleberry-pi/">KindleBerry Pi</a></li>
<li><a href="https://gist.github.com/rvagg/5095506">Kindleberry &ldquo;Paperwhite&rdquo; Pi</a></li>
<li><a href="http://wiki.mobileread.com/wiki/Kindle_Touch_Hacking#GUI_launcher">Kindle Touch Hacking</a></li>
<li><a href="http://maxogden.com/kindleberry-wireless.html">Kindleberry Wireless: A Portable Outdoor Hackstation</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何找到树莓派通过DHCP获得的IP地址]]></title>
    <link href="http://codelife.me/blog/2013/12/17/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp/"/>
    <updated>2013-12-17T03:08:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/17/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp</id>
    <content type="html"><![CDATA[<blockquote><p>小巧的树莓派配一个硕大的显示器，很不协调。本文介绍如何获得树莓派通过DHCP动态分配的IP地址。</p></blockquote>

<h3>几种有趣的方法</h3>

<p>mathworks论坛提到了几种有意思的方法</p>

<ol>
<li><p>通过Matlab命令行</p>

<pre><code> h = raspberrypi(‘raspberrypi-ah')
 h.openShell(‘ssh')
</code></pre></li>
<li>安装一个启动过程中能读出IP的软件，该软件也是MathWork出品的</li>
<li>通过DDNS（Dynamic DNS）</li>
<li>启动时发邮件通知</li>
</ol>


<p>就个人而言，上面的方法觉得都不够好。</p>

<ol>
<li>需要安装Matlab，一个好几G的工具软件就是为了找个IP用，有些蛋疼</li>
<li>要插个耳机或者音响什么的</li>
<li>需要互联网环境</li>
<li>需要互联网环境</li>
</ol>


<p>下面我介绍一个简单实用的方法，通过arp协议获得IP</p>

<!-- more -->


<h3>通过arp-scan获得树莓派IP</h3>

<p>arp协议是一个数据链路层协议，负责IP地址和Mac地址的转换。下面我们介绍一个arp-scan工具扫出局域网所有的IP地址</p>

<h4>安装arp-scan</h4>

<p>Mac OS</p>

<pre><code>brew install arp-scan
</code></pre>

<p>Ubuntu</p>

<pre><code>sudo apt-get arp-scan
</code></pre>

<h4>扫描以太网IP地址</h4>

<pre><code>arp-scan --interface en0 --localnet  
</code></pre>

<p>此处en0是网卡的设备名称，可以通过ifconfig命令获得，有多种网卡时注意不要写错</p>

<p>扫描结果如下</p>

<pre><code>nterface: en0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.8 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
192.168.199.1   d4:ee:07:04:0d:e6   (Unknown)
192.168.199.239 e8:8d:28:06:db:2f   (Unknown)
192.168.199.107 b8:27:eb:96:c4:2f  (Unknown)

513 packets received by filter, 0 packets dropped by kernel
Ending arp-scan 1.8: 256 hosts scanned in 1.242 seconds (206.12 hosts/sec). 2 responded
</code></pre>

<p>由于arp-scan的版本比较低，所以主机名为Unknown,不过没有关系，由于树莓派的Mac地址都是<code>b8:27:3b</code>开头的。所以<code>192.168.199.107</code>就是树莓派的IP地址</p>

<h4>One line Command</h4>

<pre><code>arp-scan --interface en0 --localnet | grep grep b8:27:eb
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://blog.remibergsma.com/2013/05/03/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp/">HOWTO discover the ip address of a Raspberry Pi</a></li>
<li><a href="http://www.mathworks.cn/cn/help/simulink/ug/get-the-ip-address-of-the-raspberry_pi-hardware.html">Get IP Address of Raspberry Pi Hardware</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?t=55804">FYI: via Raspi&rsquo;s IP address with &lsquo;arp-scan&rsquo;</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspbian成功驱动TP-Link TL-WN725N V2版无线网卡]]></title>
    <link href="http://codelife.me/blog/2013/12/14/tp-link-wn725n-v2-works-on-raspbian/"/>
    <updated>2013-12-14T00:03:00+08:00</updated>
    <id>http://codelife.me/blog/2013/12/14/tp-link-wn725n-v2-works-on-raspbian</id>
    <content type="html"><![CDATA[<blockquote><p>淘宝双12搞活动，225入了一台英国产2代B型512M RaspBerry Pi，英国产的相对便宜，但是不带外壳，另外加12块，搞了个带固定螺丝的亚克力外壳。话说这个外壳裁剪的相对不错，花了老半天才装好。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-12-14/4-items.jpg" alt="配件合集" /></p>

<p><img src="http://codelife.me/images/post/2013-12-14/raspberry.jpg" alt="组装成品" /></p>

<p><img src="http://codelife.me/images/post/2013-12-14/pi-with-tl-wn725n.jpg" alt="TP-Link TL-WN725N V2" /></p>

<!-- more -->


<h3>如何选SD卡</h3>

<p>先罗嗦一段SD卡的选取过程。其实想买开树莓的板子很长时间了，但是如何选SD卡一直犹豫不决。主要考虑两个因素：</p>

<ul>
<li>SD卡的兼容性，某些SD卡树莓派无法识别；</li>
<li>SD卡的读写速度，市面上的Class 10卡从20M/s到UHS-I卡95M/s的价格相差很大。</li>
</ul>


<p>一开始很想选 <a href="http://item.jd.com/530220.html">闪迪（SanDisk）至尊超极速SDHC存储卡 8G-Class10-95MB/s</a> 查了<a href="http://elinux.org/RPi_SD_cards">树莓的SD卡兼容列表</a>显示可以识别，但159元的价格让我犹豫了。</p>

<p>研究了一段时间，发现有网友称树莓派对UHS-I类型的SD支持不好，目前树莓的控制器读取SD卡速度也就20-30M/s。后来选了 <a href="http://item.jd.com/679771.html">闪迪（SanDisk）至尊高速MicroSDHC（TF）存储卡 8G-Class10-30MB/s</a>， 39元搞定。</p>

<h3>安装rtl8188eu驱动模块</h3>

<p>现在进入正题，安装这块无线网卡的驱动是个痛苦的精力，虽然树莓派的官方论坛已经有几篇关于驱动TL-WN725N的帖子：</p>

<ul>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=66&amp;t=55779&amp;sid=946c22c3b95fea0e73539828e33018b1">Getting TL-WN725N working</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=28&amp;t=52932">TL-WN725N V2, raspbian driver update</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=91&amp;t=29752">TP-Link TL-WN725N V2 works out of the box on Raspbian</a></li>
</ul>


<p>但由于Raspbian的版本在不断的升级，生搬帖子上的步骤不起效果。</p>

<p>因为我的这个 <a href="http://item.jd.com/618066.html">TP-LINK TL-WN725N 微型150M无线USB网卡</a> 是先于树莓派购买闲置的。如果买新的话，强烈建议买免驱的无线网卡，省得折腾。比如说这款 <a href="http://item.jd.com/509932.html">EDUP EP-N8508GS黄金版 迷你USB无线网卡</a>.这里有一份<a href="http://elinux.org/RPi_USB_Wi-Fi_Adapters">树莓派支持的无线网卡清单</a></p>

<p>下的步骤是综合了上面的帖子及其引用，不断试错总结出来的步骤。</p>

<h4>确定网卡的版本</h4>

<p>TP-LINK TL-WN725N分<a href="http://wikidevi.com/wiki/TP-LINK_TL-WN725N_v1">V1</a>, <a href="http://wikidevi.com/wiki/TP-LINK_TL-WN725N_v2">V2</a>版本。 <br/>
<img src="http://codelife.me/images/post/2013-12-14/tl-wn725n.jpg" alt="" /></p>

<p>将无线网卡插上树莓的USB接口，执行<code>lsusb</code>返回如下</p>

<blockquote><p>Bus 001 Device 004: ID 0bda:8179 Realtek Semiconductor Corp.</p></blockquote>

<p>因为V1和V2的ID代号分别是0bda:8176、0bda:8179。</p>

<p>本文只针对V2版本，V1版本未经测试。</p>

<h4>升级内核</h4>

<pre><code>sudo rpi-update
</code></pre>

<p>升级后执行<code>uname -a</code>的结果是</p>

<blockquote><p>Linux raspberrypi 3.10.24+ #610 PREEMPT Thu Dec 12 13:12:09 GMT 2013 armv6l GNU/Linux</p></blockquote>

<h4>编辑驱动模块</h4>

<pre><code>git clone --depth 1 git://github.com/raspberrypi/linux.git rpi-linux

git clone --depth 1 git://github.com/raspberrypi/firmware.git rpi-firmware

git clone git://github.com/lwfinger/rtl8188eu.git rtl8188eu

cd rpi-linux

make mrproper

zcat /proc/config.gz &gt; .config

make modules_prepare

cp ../rpi-firmware/extra/Module.symvers .

cd ../rtl8188eu

CONFIG_RTL8188EU=m make -C ../rpi-linux M=`pwd`

sudo cp rtl8188eufw.bin /lib/firmware/rtlwifi

sudo install -p -m 644 8188eu.ko /lib/modules/`uname -r`/kernel/drivers/net/wireless

sudo insmod /lib/modules/`uname -r`/kernel/drivers/net/wireless/8188eu.ko

sudo depmod -a
</code></pre>

<h4>验证网卡是否识别</h4>

<p>若上面的命令执行过程没有报错，执行<code>iwconfig</code>的结果如下</p>

<pre><code>wlan0     IEEE 802.11bgn  ESSID:"22_1707"  Nickname:"&lt;WIFI@REALTEK&gt;"
          Mode:Managed  Frequency:2.457 GHz  Access Point: D4:EE:07:04:0D:E6
          Bit Rate:150 Mb/s   Sensitivity:0/0
          Retry:off   RTS thr:off   Fragment thr:off
          Power Management:off
         Link Quality=0/100  Signal level=15/100  Noise level=0/100
         Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
         Tx excessive retries:0  Invalid misc:0   Missed beacon:0

lo        no wireless extensions.

eth0      no wireless extensions.
</code></pre>

<p>证明无线网卡已被识别，下面我们来配置网络参数。</p>

<h4>配置无线网络参数</h4>

<p>打开/etc/wpa_supplicant/wpa_supplicant.conf文件，添加如下内容</p>

<pre><code>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid="NETWORK_NAME"
    psk="NETWORK_PASSWORD"
}
</code></pre>

<p>上面的方法psk是明文，如果觉得敏感，可以使用下面的命令生成密文</p>

<pre><code>wpa_passphrase ssid pass_phrase
</code></pre>

<p>输出如下</p>

<pre><code>network={
        ssid="myrouter"
        #psk="thisisalongpassphrasenobodycanguess"
        psk=fd50e5fb2b66493702338dd5175241d2e8dd7dd42fc292bbb7c56b01f9e9fdc0
}
</code></pre>

<p>将输出结果添加到/etc/wpa_supplicant/wpa_supplicant.conf文件。</p>

<p>重启网络服务<code>sudo service networking reload</code>后</p>

<p>执行<code>ifconfig</code>，如果wlan0获得IP就可以使用了</p>

<pre><code>wlan0     Link encap:Ethernet  HWaddr 14:cf:92:b5:59:6d
          inet addr:192.168.199.109  Bcast:192.168.199.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8805 errors:0 dropped:15 overruns:0 frame:0
          TX packets:600 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:2542242 (2.4 MiB)  TX bytes:82318 (80.3 KiB)
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://smhaziq.blogspot.co.at/2013/06/compiling-tp-link-wn725n-v2-driver-in.html">Compiling TP-LINK WN725N V2 driver in Raspbmc with 3.6.11 kernel</a></li>
<li><a href="https://github.com/liwei/rpi-rtl8188eu">Linux driver for tplink-wn725n nano wireless adapter</a></li>
<li><a href="http://blog.pi3g.com/2013/10/easy-tp-link-tl-wn725-driver-installation/">Easy TP-Link TL-WN725 driver installation</a></li>
<li><a href="http://www.fars-robotics.net/">Fars Robotics Website</a></li>
<li><a href="http://undiff.com/2008/08/wireless-with-wpa_supplicant-easier-then-you-think/">Wireless with wpasupplicant easier then you think</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google屏蔽Linode的IPv6导致SSH隧道不可用]]></title>
    <link href="http://codelife.me/blog/2013/11/16/google-block-linode-traffic-over-ipv6/"/>
    <updated>2013-11-16T01:48:00+08:00</updated>
    <id>http://codelife.me/blog/2013/11/16/google-block-linode-traffic-over-ipv6</id>
    <content type="html"><![CDATA[<blockquote><p>最近几个月通过linode的SSH隧道访问Google都会报出类似“We‘re sorry”或者“unusual traffic”的错误，有时需要输入验证码，但大多数时候直接不可用。一段时间使用GoAgent比较多，可惜GoAgent有时不太稳定。</p></blockquote>

<p>Google了一番，才知道是因为Google屏蔽了Linode服务器的IPv6协议导致SSH隧道出问题的。
下面我们就来关闭Ubuntu的IPv6</p>

<h3>关闭Ubuntu的IPv6</h3>

<ul>
<li><p>编辑 <code>/etc/sysctl.conf</code>,添加如下内容</p>

<p>  net.ipv6.conf.all.disable_ipv6=1<br/>
  net.ipv6.conf.default.disable_ipv6=1<br/>
  net.ipv6.conf.lo.disable_ipv6=1</p></li>
</ul>


<p>如上修改虽然是永久性的需要重启网卡才能生效<code>/etc/init.d/networking restart</code></p>

<ul>
<li><p>实时生效</p>

<p>  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/lo/disable_ipv6<br/>
  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/lo/disable_ipv6<br/>
  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/all/disable_ipv6<br/>
  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/default/disable_ipv6</p></li>
</ul>


<p>再试试通过SSH隧道搜索Google，是不是已经好了，^_^。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="https://forum.linode.com/viewtopic.php?f=20&amp;t=10436">Intermittent &ldquo;We&rsquo;re sorry&rdquo; error accessing Google via IPv6</a></li>
<li><a href="http://en.kioskea.net/faq/759-ubuntu-disabling-ipv6-support">Ubuntu &ndash; Disabling IPv6 support</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS X替换Razer的状态栏图标]]></title>
    <link href="http://codelife.me/blog/2013/11/16/replace-razer-status-bar-icon-in-macos/"/>
    <updated>2013-11-16T01:37:00+08:00</updated>
    <id>http://codelife.me/blog/2013/11/16/replace-razer-status-bar-icon-in-macos</id>
    <content type="html"><![CDATA[<blockquote><p>心爱的QeathAdder炼狱蝰蛇变形金刚款，用了300多天左键坏了，联系易迅给换了个QeathAdder炼狱蝰蛇2013款。虽然黑色的外观不如变形金刚款银色的配MacBook，但是6400dpi的分辨率，着实给力。CS:GO的甩狙命中率显著提升，开始以为年纪大了水平下降了，换鼠标后，发现还是鼠标的问题。话说Razer鼠标的管理界面支持登录以后保存鼠标配置的功能很好，就是状态栏的蓝色图标和Mac OS统一的暗灰色图标比起来太不协调了。</p></blockquote>

<p>默认效果</p>

<p><img src="http://codelife.me/images/post/2013-11-16/replace_before.png" alt="" /></p>

<p>替换后的效果</p>

<p><img src="http://codelife.me/images/post/2013-11-16/replace_after.png" alt="" /></p>

<p>替换图标</p>

<p><img src="http://codelife.me/images/post/2013-11-16/Status.png" alt="" /></p>

<h3>替换图标</h3>

<ol>
<li>在Finder里找到<code>/Library/Application Support/Razer/RzUpdater.app</code>
Command+Shift+G打开GO to对话框，输入<code>/Library/Application Support/Razer</code></li>
<li>右键RzUpdater.app显示包内容</li>
<li>然后再进入<code>Contents/Resources</code>目录</li>
<li>用上面的图标替换Status.png文件即可。</li>
<li>重启系统或者杀掉RzUpdater进程</li>
</ol>


<h3>参考阅读</h3>

<ol>
<li><a href="http://forums.macrumors.com/showthread.php?t=1432198">Razer DeathAdder Icon in Menubar (Synapse 2.0)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Mac正确的识别Noppoo Chic Mini84]]></title>
    <link href="http://codelife.me/blog/2013/11/13/noppoo-chic-mini84-osx-support/"/>
    <updated>2013-11-13T14:44:00+08:00</updated>
    <id>http://codelife.me/blog/2013/11/13/noppoo-chic-mini84-osx-support</id>
    <content type="html"><![CDATA[<blockquote><p>半年前入了一把Noppoo的84键茶轴机械键盘，这把键盘的手感真心不错，也非常的小巧，很短，放在桌上也一点都不占位置。唯一的缺点就是不支持Mac系统。官方未提供mac版本的驱动程序，在mac系统下有部分键不好用。网上倒是提供了两种解决方案：一种是usb转ps2，再ps2转usb两次转换以后就好用了（依靠转换器里的芯片）；另一个种是安装Github上的<a href="https://github.com/thefloweringash/iousbhiddriver-descriptor-override">第三方驱动</a>。</p></blockquote>

<p><img src="http://codelife.me/images/post/2013-11-13/noppoo-chic-mini84.jpg" alt="Noppoo Chic Mini84" /></p>

<p>两种方法都有试过，两次转换可以免去装驱动的麻烦，但是由于接了两个转换器，有时候会接触不好。最后选用了加装驱动的方案。</p>

<!-- more -->


<h3>加装驱动</h3>

<ul>
<li><p>pkg安装包 <a href="https://thefloweringash.com/iousbhiddriver-descriptor-override/downloads/IOUSBHIDDriverDescriptorOverride-2013-04-21-b545d15.pkg">https://thefloweringash.com/iousbhiddriver-descriptor-override/downloads/IOUSBHIDDriverDescriptorOverride-2013-04-21-b545d15.pkg</a></p></li>
<li><p>编译安装</p>

<ol>
<li> 下载源码 <a href="https://github.com/thefloweringash/iousbhiddriver-descriptor-override/archive/master.zip">https://github.com/thefloweringash/iousbhiddriver-descriptor-override/archive/master.zip</a></li>
<li> 编译</li>
</ol>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># dependencies
</span><span class='line'>gem install bundler
</span><span class='line'>bundle install --without scan
</span><span class='line'>
</span><span class='line'># build
</span><span class='line'>xcodebuild
</span><span class='line'>sudo cp -r build/Release/IOUSBHIDDriverDescriptorOverride.kext \
</span><span class='line'>    /System/Library/Extensions
</span><span class='line'>sudo kextutil \
</span><span class='line'>    /System/Library/Extensions/IOUSBHIDDriverDescriptorOverride.kext</span></code></pre></td></tr></table></div></figure>


<pre><code>3. 启动时加载，把com.apple.IOUSBHIDDriverDescriptorOverride.plist复制到/Library/LaunchDaemons/下面
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>launchctl load -w /Library/LaunchDaemons/com.apple.IOUSBHIDDriverDescriptorOverride.plist
</span><span class='line'>launchctl list | grep om.apple.IOUSBHIDDriverDescriptorOverride</span></code></pre></td></tr></table></div></figure>


<h3>安装KeyRemap4MacBook</h3>

<p>下载地址 <a href="https://pqrs.org/macosx/keyremap4macbook/">https://pqrs.org/macosx/keyremap4macbook/</a></p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://likidu.com/noppoo-chic-mini84-osx-support/">Noppoo Chic Mini 84支持Mac OS X</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个优雅的Mac OS服务管理程序launchctl的包装工具]]></title>
    <link href="http://codelife.me/blog/2013/11/09/a-nice-launchctl-wrapper-for-macos-deamon-management/"/>
    <updated>2013-11-09T17:32:00+08:00</updated>
    <id>http://codelife.me/blog/2013/11/09/a-nice-launchctl-wrapper-for-macos-deamon-management</id>
    <content type="html"><![CDATA[<blockquote><p>launchctl是mac os平台的服务管理程序，相当于linux平台的service。但是launchctl真心难用，比如不支持重启服务，关闭服务需要指定配置文件plist的全路径。<a href="https://github.com/mperham/lunchy">lunchy</a>是一个launchctl的包装程序，大大简化了agent的管理。</p></blockquote>

<h3>安装</h3>

<p>lunchy是一个ruby程序，可以通过gem直接安装</p>

<pre><code>gem install lunchy
</code></pre>

<h3>命令</h3>

<ul>
<li>ls [pattern]</li>
<li>start [pattern]</li>
<li>stop [pattern]</li>
<li>restart [pattern]</li>
<li>status [pattern]</li>
<li>install [file]</li>
<li>show [pattern]</li>
<li>edit [pattern]</li>
</ul>


<p>lunchy的一个重要功能改进是支持通配，除了安装install agent需要指定完整的文件路径外，其他命令只需要输入特征词即可。</p>

<p>比如启动redis服务</p>

<pre><code>launchctl load ~/Library/LaunchAgents/io.redis.redis-server.plist
</code></pre>

<p>使用lunchy非常简单</p>

<pre><code>lunchy start redis
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://v2ex.com/t/88644">OS X 下使用 lunchy 替换 launchctl 管理 daemon apps</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac OS里配置Apache+PHP+Mysql环境]]></title>
    <link href="http://codelife.me/blog/2013/11/08/config-apache-php-mysql-on-mac-os/"/>
    <updated>2013-11-08T21:54:00+08:00</updated>
    <id>http://codelife.me/blog/2013/11/08/config-apache-php-mysql-on-mac-os</id>
    <content type="html"><![CDATA[<blockquote><p>Apache+PHP+Mysql是PHP开发的标配，Windows系统可以安装<a href="www.easyphp.org">EasyPHP</a>集成包。Mac系统也有相应的集成包<a href="http://www.mamp.info/en/index.html">MAMP</a>。但是考虑到Mac OS已经自带了Apache和PHP环境，重复安装Apache和PHP有些冗余，所有本文介绍如何使用homebrew安装Mysql并且集成原有的Apache和PHP环境。</p></blockquote>

<h3>启动Apache</h3>

<p>打开Terminal，然后运行</p>

<pre><code>sudo apachectl start
</code></pre>

<p>查看Mac OS X的Apache版本</p>

<pre><code>sudo apachectl -v
</code></pre>

<p>Mac OS X 10.9的返回结果是</p>

<blockquote><p>Server version: Apache/2.2.24 (Unix) <br/>
Server built:   Aug 24 2013 21:10:43</p></blockquote>

<p>如此在浏览器中输入<code>http://localhost</code>，就可以看到一个内容为“It works!”的页面，其位于<code>/Library（资源库）/WebServer/Documents/</code>下，这就是Apache的默认根目录。</p>

<p>另外，用户可以通过<code>http://[本地IP]/~[用户名]</code>来访问<code>/Users/[用户名]/Sites/</code>目录</p>

<h3>开启PHP支持</h3>

<ol>
<li>在终端中运行<code>sudo vi /etc/apache2/httpd.conf</code>，打开Apache的配置文件。</li>
<li>找到<code>#LoadModule php5_module libexec/apache2/libphp5.so</code>，把前面的#号去掉，保存（在命令行输入:w）并退出vi（在命令行输入:q）。</li>
<li><p>运行<code>sudo cp /etc/php.ini.default /etc/php.ini</code>，这样就可以运行<code>sudo vi /etc/php.ini</code>来编辑php.ini配置各种功能了。比如：</p>

<p> ;通过下面两项来调整PHP提交文件的最大值，如phpMyAdmin中导入数据的最大值
 upload_max_filesize = 2M
 post_max_size = 8M
 ;通过display_errors来控制是否显示PHP程序的报错信息，这在调试PHP程序时非常有用
 display_errors = Off</p></li>
<li>运行“sudo apachectl restart”，重启Apache，这样PHP就可以用了。</li>
</ol>


<h3>安装Xdebug</h3>

<ol>
<li>在终端执行<code>php -i | pbcopy</code>，php的输出信息会被拷贝的剪切板。</li>
<li>打开<a href="http://xdebug.org/wizard.php">xdebug安装在线向导</a>,在文本框内Command+V，将剪切板内的内容拷贝到文本框，然后点击“Analyse my phpinfo() output”按钮。</li>
<li>根据生成的步骤安装即可。</li>
</ol>


<h3>安装Mysql</h3>

<p>这一步最简单了，前提是已安装了<a href="http://brew.sh">HomeBrew</a>。
在命令行执行</p>

<pre><code>brew install mysql
</code></pre>

<p>安装完成以后,启动mysql服务</p>

<pre><code>mysql.server start
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://dancewithnet.com/2010/05/09/run-apache-php-mysql-in-mac-os-x/">在Mac OS X中配置Apache ＋ PHP ＋ MySQL</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[致青春]]></title>
    <link href="http://codelife.me/blog/2013/09/19/for-youth/"/>
    <updated>2013-09-19T03:04:00+08:00</updated>
    <id>http://codelife.me/blog/2013/09/19/for-youth</id>
    <content type="html"><![CDATA[<blockquote><p>送给那些而立之年的伙伴们</p></blockquote>

<p>年华易逝，岁月如歌，<br/>
而立之年，青春渐远。</p>

<p>《那些年，我們一起追的女孩 》和《致青春》触动了我们，80后开始集体怀旧。</p>

<p>那些野蛮生长日子里，<br/>
有过期许，<br/>
有过慌张，<br/>
也曾意气风发，<br/>
也曾年少轻狂。</p>

<p>其实每一代人都有怀旧情结，人们之所以怀念过去，往往不是因为追忆的年代比当下更美好，而是那时正值青春。</p>

<p>青春是美好的，<br/>
青春是奔放的，<br/>
青春是热烈的，<br/>
青春是短暂的，<br/>
如花如雨，<br/>
如烟如梦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决国内rubygems速度慢的问题]]></title>
    <link href="http://codelife.me/blog/2013/09/18/installing-rubygems-faster/"/>
    <updated>2013-09-18T14:50:00+08:00</updated>
    <id>http://codelife.me/blog/2013/09/18/installing-rubygems-faster</id>
    <content type="html"><![CDATA[<blockquote><p>国内访问rubygems那个慢呀，尤其是走https协议。</p></blockquote>

<h3>借用bash的http代理</h3>

<p>一般来说通过翻墙代理访问的速度要更快一点。ruby遵守unix环境变量约定，支持http_proxy和https_proxy。</p>

<p>在执行<code>bundle install</code>之前先执行</p>

<pre><code>$ export http_proxy=http://127.0.0.1:xxxxx/
$ export https_proxy=http://127.0.0.1:xxxxx/
</code></pre>

<p>当然前提是，系统有一个本地可用的http或者https代理。关于bash里使用http代理的细节参见<a href="http://codelife.me/blog/2012/09/02/how-to-set-proxy-for-terminal/">《如何为MacOS X终端设置代理》</a></p>

<h3>改用国内的镜像</h3>

<pre><code>$ gem sources –r http://rubygems.org/
$ gem sources -a http://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***

http://ruby.taobao.org

# 请确保只有 ruby.taobao.org
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://ruby-china.org/topics/288">国内访问rubygems.org好慢啊，大家有没有提速的方法？</a></li>
<li><a href="http://tec.liux.in/28">解决rubygems速度慢的Tips</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
