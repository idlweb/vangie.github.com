<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Code Life]]></title>
  <link href="http://vangie.github.com/atom.xml" rel="self"/>
  <link href="http://vangie.github.com/"/>
  <updated>2014-04-06T01:02:55+08:00</updated>
  <id>http://vangie.github.com/</id>
  <author>
    <name><![CDATA[Vangie Du]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于Token的认证和基于声明的标识]]></title>
    <link href="http://vangie.github.com/blog/2014/03/26/token-based-authentication-and-claims-based-identity/"/>
    <updated>2014-03-26T14:12:05+08:00</updated>
    <id>http://vangie.github.com/blog/2014/03/26/token-based-authentication-and-claims-based-identity</id>
    <content type="html"><![CDATA[<blockquote><p>OpenID解决跨站点的认证问题，OAuth解决跨站点的授权问题。认证和授权是密不可分的。而OpenID和OAuth这两套协议出自两个不同的组织，协议上有相似和重合的之处，所以想将二者整合有些难度。好在OpenID Connect作为OpenID的下一版本，在OAuth 2.0的协议基础上进行扩展，很好的解决了认证和授权的统一，给开发者带来的便利。在学习和研究OpenID Connect协议时，遇上两个概念基于Token的认证（token based authentication）和基于声明的标识（claims based identity）。本文就这两个概念展开讨论，为了更好的理解OpenID Connect协议的原理。</p></blockquote>

<h3>基于Cookie的认证和基于Token的认证</h3>

<p>有两种不同的方法实现服务端的认证</p>

<ul>
<li>常见方式是<strong>基于Cookie的认证</strong>,每个请求中携带Cookie信息以便于服务端识别</li>
<li>另一种新方法，<strong>基于Token的认证</strong>，在每个请求中携带被签名过Token信息传送到服务端</li>
</ul>


<p><a href="https://docs.google.com/drawings/d/1IPgSFz2loaOIrnIKinGyrSoRm54slHFi8d_oRJ7BGPc/edit?usp=sharing"><img src="http://vangie.github.com/images/post/2014-03-26/cookie-based-auth-vs-token-based-auth.png" alt="Cookie-based Auth vs Token-based Auth" /></a></p>

<!-- more -->


<p>相比Cookie，基于Token的认证有如下好处：</p>

<ul>
<li><strong>跨域</strong>: cookies在跨域场景表现并不好。基于Token的方法允许你向任何不同域名的服务器发送Ajax请求，因为你可以通过HTTP头传递用户信息。</li>
<li><strong>无状态</strong>（或者 服务端可扩展）：无须再存储Session，由于Token已经自包含了所有的用户信息。</li>
<li><strong>内容分发</strong>：你可以将所有的静态资源（例如：脚本，HTML，图片等）分发到CDN服务上，你的服务器仅仅提供API。<a href="http://www.internap.com/cdn-services-content-delivery-network/cdn-user-authentication/">某些CDN服务商</a>提供了基于Token验证的安全服务。</li>
<li><strong>解耦</strong>：无须被绑定在一个特定的验证方案。</li>
<li><strong>移动支持</strong>：在移动设备的原生平台，使用cookie作为安全认证并不是好主意。采用基于Token的方法会简单得多。</li>
<li><strong>跨站点脚本攻击</strong>：由于没有基于cookie技术，你不再需要考虑跨站点请求的安全性问题。</li>
<li><strong>性能</strong>：虽然没有做严格的性能测试，但是还原session所做的数据库查询往返的性能损耗要大于<code>HMACSH256</code>算法验证和解析Token。</li>
<li><strong>基于标准</strong>：JWT(<a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token">JSON Web Token</a>)作为Token的标准已经被广泛的接受。主流语言（.NET, Ruby, Java, Python, PHP）都有相应支持JWT标准的工具包。</li>
</ul>


<h3>JWT格式</h3>

<p><abbr title="JSON Web Token">JWT</abbr>是一种紧凑的URL安全表示格式，适用于空格受限制的场景，比如HTTP授权头部和请求参数。JWT使用JSON格式表示一组声明，该JSON被编码成<abbr title="JSON Web Signature">JWS</abbr>或<abbr title="JSON Web Encryption">JWE</abbr>结构。</p>

<p>JWT是一段被base64url编码过的字符序列（去除了尾部的“=”），并用点号分隔。</p>

<p>下面是一个JWT头部的</p>

<div><script src='https://gist.github.com/9976068.js?file=headers.json'></script>
<noscript><pre><code>{
  &quot;typ&quot;: &quot;JWT&quot;,
  &quot;alg&quot;: &quot;HS256&quot;
}</code></pre></noscript></div>


<p>使用base64url编码以后</p>

<div><script src='https://gist.github.com/9976068.js?file=header_encoded'></script>
<noscript><pre><code>eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9</code></pre></noscript></div>


<p>下面是一个JWT的消息体其中包含声明集合</p>

<div><script src='https://gist.github.com/9976068.js?file=payload.json'></script>
<noscript><pre><code>{
  &quot;user_id&quot;: 1
}</code></pre></noscript></div>


<p>使用base64url编码以后</p>

<div><script src='https://gist.github.com/9976068.js?file=payload_encoded'></script>
<noscript><pre><code>eyJ1c2VyX2lkIjogMX0</code></pre></noscript></div>


<p>将上面编码过的JWS头部和JWS消息体使用HMAC SHA-256算法，并结合私钥计算得到的MAC，再经过base64url编码获得的字符序列成为JWS签名</p>

<div><script src='https://gist.github.com/9976068.js?file=signature'></script>
<noscript><pre><code>BSf1w1blYKcbxVlyOtUogUsozH2clY34xxYPd8lQIlQ</code></pre></noscript></div>


<p>将编码过的头部，消息体和JWS签名通过&#8217;.&lsquo;号连接起来，就获得JWT</p>

<div><script src='https://gist.github.com/9976068.js?file=jwt'></script>
<noscript><pre><code>eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJ1c2VyX2lkIjogMX0.BSf1w1blYKcbxVlyOtUogUsozH2clY34xxYPd8lQIlQ</code></pre></noscript></div>


<p>关于JWT的更多技术细节，请阅读<a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token">JWT规范</a>.</p>

<h3>基于声明的标识</h3>

<p>Cookie在请求和响应之间反复传递，对于无状态的HTTP协议，在Cookie里加入一个会话ID，以标识一组请求和响应属于同一会话。通常会话与用户是多对一关系，也就是说一个会话只会属于一个用户。所以通过Cookie技术就可以标识出用户。通常Cookie里也会携带一些额外的信息，但是考虑Cookie容易被截获和篡改，所以Cookie里并不适合放置用户的基本信息。</p>

<p>Token其实和Cookie类似是一段序列化字符串，作为HTTP请求头的一部分，发送到服务端。但是Token加入了签名机制，可以防篡改。所以Token可以包含用户信息发送给不同域的应用服务作为身份标识，只要相应的应用服务能识别其有效性。</p>

<p>Token仅仅是某种信息的承载形式，基于Token的认证有一个更宽泛的概念：基于声明的标识</p>

<p><a href="https://docs.google.com/drawings/d/1bSBW-rNfOUA4jsWVABXyuJklNY-hXI8QRMRtarh5Ek4/edit?usp=sharing"><img src="http://vangie.github.com/images/post/2014-03-26/claims-based-identity.png" alt="Claims based Identity" /></a></p>

<p>基于声明的标识其实无处不在，举个我们很熟悉的例子。</p>

<p>每次机场登机前过安检时，你不能简单地走到门口，并出示身份证。相反，必须先办理登机手续柜台。如果出国，还需要出示护照。安检人员先验证证件头像与你本人是否一致，然后核实您的信息，并确认您已经购买了机票。假设一切顺利，您将获得登机牌。</p>

<p>登机牌上包括知道您的姓名，航班号和座位号等常规信息。安检人员可以从登机牌上获得足够的信息以配合他们的工作。</p>

<p>登机牌上还有一些特殊信息，包含在条形码和背面的磁条里，以证明该登机牌是由航空公司签发的，而不是伪造的。</p>

<p>从本质上说，登机牌是一个由航空公司签发的关于你的一组信息。它表明你被允许某时登上某飞机坐在某个座位。当然，安检人员不必深入地理解这些。他们只需验证您的登机牌，读取其中的信息，然后让你登机。</p>

<p>同样值得注意的是，可能有不止一种方法获得您的登机牌。可能去机场售票柜台领取，或者在家里从航空公司网站下载并打印。安检人员不在乎的登机牌是如何获得的 。他们只关心登机牌是否真实的。</p>

<p>登机牌就是一张包含了一组声明信息的卡片，是Token的一种实体形式。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://book.douban.com/subject/5303216/">《A Guide to Claims-Based Identity and Access Control》</a></li>
<li><a href="http://dotnetcodr.com/2014/01/20/introduction-to-oauth2-json-web-tokens/">Introduction to OAuth2: Json Web Tokens</a></li>
<li><a href="http://www.layer7tech.com/blogs/index.php/give-me-a-jwt-ill-give-you-an-access-token/">Give Me a JWT, I’ll Give You an Access Token</a></li>
<li><a href="http://en.wikipedia.org/wiki/Claims-based_identity">Claims-based identity</a></li>
<li><a href="http://blog.auth0.com/2014/01/07/angularjs-authentication-with-cookies-vs-token/">Cookies vs Tokens. Getting auth right with Angular.JS</a></li>
<li><a href="http://jpadilla.com/post/73791304724/auth-with-json-web-tokens">Auth with JSON Web Tokens</a></li>
<li><a href="http://openid.net/specs/draft-jones-json-web-token-07.html">JSON Web Token (JWT) draft-jones-json-web-token-07</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java泛型让声明方法返回子类型]]></title>
    <link href="http://vangie.github.com/blog/2014/03/05/returning-subtype-of-declared-type-from-method-by-java-generics/"/>
    <updated>2014-03-05T11:11:45+08:00</updated>
    <id>http://vangie.github.com/blog/2014/03/05/returning-subtype-of-declared-type-from-method-by-java-generics</id>
    <content type="html"><![CDATA[<blockquote><p>泛型典型的使用场景是集合。考虑到大多数情况下集合是同质的（同一类型），通过声明参数类型，可免去类型转换的麻烦。本文将讨论本人阅读Spring Security源码时遇到的一个关于<strong><em>泛型递归模式</em></strong>的问题。</p></blockquote>

<h3>声明方法返回子类型</h3>

<p>在Spring Security的源码里有一个<code>ProviderManagerBuilder</code>接口，声明如下</p>

<pre><code>public interface ProviderManagerBuilder&lt;B extends ProviderManagerBuilder&lt;B&gt;&gt; extends SecurityBuilder&lt;AuthenticationManager&gt; {
    B authenticationProvider(AuthenticationProvider authenticationProvider);
}
</code></pre>

<p>其实现类<code>AuthenticationManagerBuilder</code></p>

<pre><code>public class AuthenticationManagerBuilder extends AbstractConfiguredSecurityBuilder&lt;AuthenticationManager, AuthenticationManagerBuilder&gt; implements ProviderManagerBuilder&lt;AuthenticationManagerBuilder&gt; {

    //...

    public AuthenticationManagerBuilder authenticationProvider(
        AuthenticationProvider authenticationProvider) {
        this.authenticationProviders.add(authenticationProvider);
        return this;
    }

    //...

}
</code></pre>

<p>上面有很多干扰项，我们来简化一下</p>

<!-- more -->


<p>接口<code>A</code>定义如下</p>

<pre><code>public interface A&lt;T extends A&lt;T&gt;&gt; {

    T add();

}
</code></pre>

<blockquote><p>说明：<code>A</code>接口只有一个<code>add</code>方法，返回泛型<code>T</code>。<code>T</code>的声明有些饶<code>&lt;T extends A&lt;T&gt;&gt;</code>。</p></blockquote>

<p><code>A</code>接口的实现类<code>B</code></p>

<pre><code>public class B implements A&lt;B&gt; {

    @Override
    public B add() {
        return null;
    }

}
</code></pre>

<p>注意，此处类<code>B</code>里的add方法返回类型<code>B</code>。也就是说，接口<code>A</code>里声明的方法时并不知道子类型<code>B</code>的存在，通过继承和泛型，可以放返回值动态的适配子类型，这一切都要归功于<code>&lt;T extends A&lt;T&gt;&gt;</code></p>

<h3>泛型递归模式（Recurring Generic Pattern）</h3>

<p><code>public interface A&lt;T extends A&lt;T&gt;&gt;</code>对于参数类型<code>T</code>是递归定义的。有如GNU的定义“GNU&rsquo;s Not Unix!”。</p>

<p>典型的例子是<code>java.lang.Enum</code></p>

<pre><code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;
    implements Comparable&lt;E&gt;, Serializable {
    //...
}
</code></pre>

<blockquote><p>java所有的枚举类型都隐式的继承<code>java.lang.Enum</code>，不允许通过现实的继承声明枚举类型，甚至集成<code>java.lang.Enum</code>也是编译器所不允许的。</p></blockquote>

<p>假设有一个枚举类<code>StatusCode</code>,其等价的声明如下</p>

<pre><code>public class StatusCode extends Enum&lt;StatusCode&gt;
</code></pre>

<p>现在我们来验证一下泛型约束，</p>

<ol>
<li>因为<code>Enum&lt;StatusCode&gt;</code>,所以<code>E=StatusCode</code></li>
<li>根据<code>&lt;E extend Enum&lt;E&gt;&gt;</code> 和 <code>E=StatusCode</code> 可得，<code>&lt;StatusCode extend Enum&lt;StatusCode&gt;&gt;</code>，</li>
<li>由于<code>public class StatusCode extends Enum&lt;StatusCode&gt;</code>第二步的结论显然成立。</li>
</ol>


<h4>为什么Enum的声明这么绕？直接Enum<E>不行么？</h4>

<p>因为<code>Enum&lt;E&gt;</code>实现了<code>Comparable&lt;E&gt;</code>接口，该接口有一个<code>compareTo</code>方法</p>

<pre><code>public int compareTo(E o) {}
</code></pre>

<p><E extend Enum<E>>强制约束了进行<code>compareTo</code>的调用对象类型和参数类型都严格一致，不会出现子类和超类或者兄弟类之间的比较。</p>

<h3>泛型递归模式与继承</h3>

<p>泛型递归模式<code>interface A&lt;T extend A&lt;T&gt;&gt;</code>用于约束参数类型T，要求其为类型<code>A</code>的子类。考虑到继承和实现<code>B implements A&lt;B&gt;</code>,参数类型和实体类型是一致的。这样类<code>A</code>中方法签名里涉及到参数类型<code>T</code>的地方，在实现类里会为实现类本身，这让类型系统更加的严谨。</p>

<h3>参考文献</h3>

<ol>
<li><a href="http://stackoverflow.com/questions/211143/java-enum-definition">Java Enum definition</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html">Java Toturial &ndash; Enum Types</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL Select和关系操作]]></title>
    <link href="http://vangie.github.com/blog/2014/02/23/sql-select-and-relational-operations/"/>
    <updated>2014-02-23T19:55:31+08:00</updated>
    <id>http://vangie.github.com/blog/2014/02/23/sql-select-and-relational-operations</id>
    <content type="html"><![CDATA[<blockquote><p>没有系统的学习过关系数据库，所以对SQL Select的理解有些浅薄，特别是group by和having语句。<a href="http://book.douban.com/subject/7061934/">《SQLite 权威指南（第二版）》</a>的第三章SQLite中的SQL，让我对Select，乃至SQL语言和关系数据库有了全新的认识。一时间激起了对关系数据库和理论的兴趣，到豆瓣上淘了一本绝版的<a href="http://book.douban.com/subject/2122940/">《深度探索关系数据库》</a>，可惜基础太差，读了一半实在读不下去了，作罢。</p></blockquote>

<p>最大的收获和发现莫过于下面这幅图了，</p>

<p><img src="http://vangie.github.com/images/post/2014-02-23/select.png" alt="select处理过程" /></p>

<!-- more -->


<p>说明：</p>

<ul>
<li>多张表通过笛卡尔积（Cartesian Production）或者连接（Join）产生R1</li>
<li>R1到R2的过程称作限制（Restriction），即过滤掉不符合条件的行（元组）</li>
<li>R4到R5的过程称作投影（Projection），即选择出需要的列（属性）</li>
</ul>


<h3>参考阅读</h3>

<ol>
<li><a href="http://book.douban.com/subject/7061934/">《SQLite 权威指南（第二版）》</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将Gemfile模板文件的source改成淘宝源]]></title>
    <link href="http://vangie.github.com/blog/2014/02/03/modify-source-of-the-gemfile-template/"/>
    <updated>2014-02-03T21:54:20+08:00</updated>
    <id>http://vangie.github.com/blog/2014/02/03/modify-source-of-the-gemfile-template</id>
    <content type="html"><![CDATA[<blockquote><p>由于国内网络原因（你懂的），导致rubygems.org存放在Amazon S3上面的资源文件间歇性连接失败。所有你会遇到<code>gem install rack</code>或<code>bundle install</code>的时候半天没有响应。将默认源改成国内的淘宝源(<a href="http://ruby.taobao.org">http://ruby.taobao.org</a>)可以解决该问题。</p></blockquote>

<p>对于Rails项目通常需要将Gemfile的第一行改为</p>

<pre><code>    source 'http://ruby.taobao.org/'
</code></pre>

<p>但是通过<code>rails new my_project</code>创建项目时，由于Gemfile生成以后立即执行<code>bundle install</code>，此时source尚未修改，所以项目创建的过程仍然很慢。</p>

<p>解决rails new 卡住的问题，有如下两种方法</p>

<!-- more -->


<h3>使用<code>--skip-bundle</code>参数</h3>

<pre><code>rails new app1 --skip-bundle
</code></pre>

<p>通过设置<code>--skip-bundle</code>参数，<code>rails new</code> 命令创建完成项目骨架以后，不会执行<code>bundle install</code>。于是可以修改Gemfile行首的source，然后再执行<code>bundle install</code>。</p>

<h3>修改Gemfile模板</h3>

<p>使用如下命令，修改Gemfile模板文件，一劳永逸</p>

<h4>For Mac</h4>

<pre><code>/usr/bin/sed -i .bak 's!https://rubygems.org!http://ruby.taobao.org!' `rvm info homes | grep gem: | awk '{print $2}' | tr -d '"'`/gems/railties-`gem list | grep railties | awk '{print $2}'| tr -d '()'`/lib/rails/generators/rails/app/templates/Gemfile
</code></pre>

<h4>For Linux</h4>

<pre><code>sed -i 's!https://rubygems.org!http://ruby.taobao.org!' `rvm info homes | grep gem: | awk '{print $2}' | tr -d '"'`/gems/railties-`gem list | grep railties | awk '{print $2}'| tr -d '()'`/lib/rails/generators/rails/app/templates/Gemfile
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://ruby.taobao.org/">RubyGems 镜像 &ndash; 淘宝网</a></li>
<li><a href="http://snails.github.io/2012/06/04/Modify-the-Gemfile-Template/">修改Rails默认生成的Gemfile的source</a></li>
<li><a href="http://ruby-china.org/topics/914">run bundle install 卡住很久</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将树莓派配置成时间胶囊]]></title>
    <link href="http://vangie.github.com/blog/2013/12/21/raspberry-pi-as-time-capsule/"/>
    <updated>2013-12-21T21:00:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/21/raspberry-pi-as-time-capsule</id>
    <content type="html"><![CDATA[<blockquote><p>MacBookAir的SSD坏了两次以后，发现TimeMachine真的很有必要。外插个尿袋子真的不方便。AirPort Time Capsule 2T版本价格买到了$299，觉得有些不值。$25的树莓派+一块移动硬盘DIY一个Time Capsule即经济又有趣。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-12-21/raspberry-pi-as-time-capsule.png" alt="Raspberry Pi as TimeCapsule" /></p>

<!-- more -->


<h3>组件清单</h3>

<p><img src="http://vangie.github.com/images/post/2013-12-21/component-of-time-capsule.png" alt="Component of TimeCapsule" /></p>

<ul>
<li>树莓派

<ul>
<li>TF卡 + 卡套</li>
<li>USB WiFi 网卡</li>
<li>5V电源 + MicroUSB 电源线</li>
</ul>
</li>
<li>移动硬盘

<ul>
<li>2.5寸 500G SATA 硬盘</li>
<li>USB3.0 硬盘电路板</li>
<li>USB3.0 数据线</li>
</ul>
</li>
</ul>


<h3>安装HFS+文件系统工具</h3>

<pre><code>sudo apt-get install hfsplus hfsutils hfsprogs
</code></pre>

<h3>准备HFS+设备</h3>

<p>列出所有块设备</p>

<pre><code>sudo blkid
</code></pre>

<p>返回如下</p>

<pre><code>/dev/mmcblk0p1: LABEL="RECOVERY" UUID="F69B-A989" TYPE="vfat"
/dev/mmcblk0p3: LABEL="SETTINGS" UUID="7f8a9faf-84a1-4062-ab9c-b2e6115035ce" TYPE="ext4"
/dev/mmcblk0p5: LABEL="BOOT" UUID="03D6-2985" TYPE="vfat"
/dev/mmcblk0p6: LABEL="root" UUID="e2a46600-20ca-42f4-8ec8-aa52d258aad2" TYPE="ext4"
/dev/sda1: UUID="943f46c5-2de2-3ef9-8494-46c3cf8bd915" LABEL="Time Capsule" TYPE="hfsplus"
</code></pre>

<p>包含TYPE=“hfsplus”的即是。</p>

<p>如果希望把一个新的分区格式化为HFS+，使用如下命令</p>

<pre><code>sudo mkfs.hfsplus -v "Time Capsule" /dev/sda1
</code></pre>

<p><strong>建议使用全新的hfs+分区</strong>
把一块已经做过TimeMachine的hfs+分区，可能导致原有的备份数据丢失</p>

<h3>挂载</h3>

<pre><code>sudo mkidr /media/TimeCapsule
sudo mount -t hfsplus -o force /dev/sda1 /media/TimeCapsule
sudo chown -R pi:pi /media/TimeCapsule
</code></pre>

<h3>安装配置netatalk服务</h3>

<pre><code>sudo apt-get install netatalk
sudo echo "/media/TimeCapsule \"Time Capsule\" options:tm" &gt;&gt; /etc/netatalk/AppleVolumes.default
sudo service netatalk restart
</code></pre>

<p>接下来就可以从Mac的Time Machine里找到这块磁盘 <br/>
<img src="http://vangie.github.com/images/post/2013-12-21/avaliable-disk.png" alt="选择Time Machine磁盘" /></p>

<h3>配置Avahi</h3>

<p>安装<code>avahi-daemon</code>和<code>libnss-mdns</code></p>

<pre><code>sudo apt-get install avahi-daemon libnss-mdns
</code></pre>

<p>配置nsswitch.conf</p>

<p>在<code>hosts:</code>后添加“mdns”</p>

<pre><code>hosts:      files mdns4_minimal [NOTFOUND=return] dns mdns4 mdns
</code></pre>

<p>接下来让Avahi在局域网广播AFP共享</p>

<p>添加如下文件<code>/etc/avahi/services/afpd.service</code>内容如下：</p>

<pre><code>&lt;?xml version="1.0" standalone='no'?&gt;&lt;!--*-nxml-*--&gt;
&lt;!DOCTYPE service-group SYSTEM "avahi-service.dtd"&gt;
&lt;service-group&gt;
    &lt;name replace-wildcards="yes"&gt;%h&lt;/name&gt;
    &lt;service&gt;
        &lt;type&gt;_afpovertcp._tcp&lt;/type&gt;
        &lt;port&gt;548&lt;/port&gt;
    &lt;/service&gt;
    &lt;service&gt;
        &lt;type&gt;_device-info._tcp&lt;/type&gt;
       &lt;port&gt;0&lt;/port&gt;
        &lt;txt-record&gt;model=Xserve&lt;/txt-record&gt;
    &lt;/service&gt;
&lt;/service-group&gt;
</code></pre>

<p>重启服务</p>

<pre><code>sudo /etc/init.d/avahi-daemon restart
</code></pre>

<p>在findler的左侧可以看到共享的文件系统</p>

<p><img src="http://vangie.github.com/images/post/2013-12-21/share.png" alt="共享" /></p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.zisoft.de/elektronik/raspberrypi/timecapsule.html">Raspberry Pi als TimeCapsule</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=36&amp;t=47029">Use rPi as a Time Capsule &ndash; another method</a></li>
<li><a href="http://garmoncheg.blogspot.jp/2012/11/time-capsule-for-25.html">Time Capsule for $25</a></li>
<li><a href="http://andadapt.com/raspberry-pi-raspbian-hfs-afp-and-time-machine/">Raspberry Pi, Raspbian, HFS+, AFP and Time Machine</a></li>
<li><a href="http://kremalicious.com/ubuntu-as-mac-file-server-and-time-machine-volume/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+kremalicious+(kremalicious">HowTo: Make Ubuntu a Perfect Mac File Server and Time Machine Volume</a>)</li>
<li><a href="http://www.andyibanez.com/260-linux-file-server-os-x-mavericks">Making A Linux File Server That Interacts With OS X Mavericks</a></li>
<li><a href="http://netatalk.sourceforge.net/wiki/index.php/Install_Netatalk_v3_on_Debian">Install Netatalk v3 on Debian</a></li>
<li><a href="http://superuser.com/questions/558150/how-to-write-to-hfs-through-afp-netatalk-without-permission-denied-and-cnid-met">How to write to HFS+ through AFP/Netatalk without permission denied and cnid_metad error?</a></li>
<li><a href="http://www.afp548.com/2013/05/06/afp-services-on-a-linux-server/">Using Netatalk: AFP Services on a Linux Server</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pcDuino上手记]]></title>
    <link href="http://vangie.github.com/blog/2013/12/19/beginner-of-pcduino/"/>
    <updated>2013-12-19T15:05:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/19/beginner-of-pcduino</id>
    <content type="html"><![CDATA[<blockquote><p>感谢刘博士送的这块pcDuino板。入Raspberry Pi前，优先考虑过pcDuino。在OSChina源创会上海站被刘博士打动过。买Raspberry Pi是为了DIY一个Mac的Time Capsule。随便Google了一下，找到了Raspberry实现Time Capsule的相关资料，而pcDuino的相关资料没有找到，于是作罢。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-12-19/pcduinov2.jpg" alt="pcDuino V2" /></p>

<p>由于Raspberry Pi的先入为主，上手pcDuino碰到写问题，下面一一列出</p>

<!-- more -->


<h3>选什么TF卡</h3>

<p>关于如何选购Raspberry Pi的SD卡，我好生下了功夫，最后还是有不好收获的。没有话冤枉钱买极速的。</p>

<p><strong>兼容列表</strong> <br/>
pcDuino支持哪些TF卡，网上找不到兼容列表。可能是都支持吧，不需要。</p>

<p><strong>读写速度</strong> <br/>
最大支持到少读写速度也找不到资料。</p>

<p>后来得知板载的2G闪存里内置了ubuntu系统，于是TF卡的问题就先悬着吧，等搞清楚再做决定。</p>

<h3>启动pcDuino</h3>

<p>插上网线，pcDuino的网线口比Raspberry Pi的要小巧，但是有些过紧，拔出网线时候要小心，别弄断了。
插上电源线，指示灯亮了。</p>

<p>没有显示器，IP地址默认应该是DHCP的，先要找到IP地址。</p>

<p><strong>找到IP地址</strong></p>

<pre><code>arp-scan --localnet
</code></pre>

<p>如果发现主机名ubuntu，那就是了。要是没有就找Unknow的逐个ssh测试，能连接上的就是。</p>

<h3>初始化系统</h3>

<p>ssh登录系统以后先执行系统初始化</p>

<pre><code>sudo board-config.sh
</code></pre>

<h3>安装Vim</h3>

<p>一直不习惯原生的vi，对方向键支持不好。</p>

<pre><code>sudo apt-get install vim
</code></pre>

<p>安装不成功，返回如下</p>

<pre><code>Reading package lists... Done
Building dependency tree
Reading state information... Done

....省去若干行

Failed to fetch http://ports.ubuntu.com/ubuntu-ports/pool/main/p/python2.7/libpython2.7_2.7.3-0ubuntu3.2_armhf.deb  404  Not Found
E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?
</code></pre>

<p>一大堆404，提示先<code>apt-get update</code>,好吧</p>

<pre><code>sudo apt-get update
</code></pre>

<p>返回如下</p>

<pre><code>....省去若干行

Get:20 http://ports.ubuntu.com precise-updates/universe Translation-en [132 kB]
Fetched 2681 kB in 21s (123 kB/s)
Reading package lists... Done
W: Conflicting distribution: http://www.wiimu.com pcduino Release (expected pcduino but got )
</code></pre>

<p>编辑器打开<code>/etc/apt/sources.list</code>,注释掉最后两行</p>

<pre><code>#deb http://www.wiimu.com:8020/pcduino/ pcuino main
#deb-src http://www.wimu.com:8020/pcduion/ pcduino main
</code></pre>

<p>然后在<code>sudo apt-get update</code>就正常了。</p>

<h3>VNC远程桌面</h3>

<h4>设置vnc密码</h4>

<pre><code>sudo x11vnc -storepasswd
sudo x11vnc -storepasswd in /etc/x11vnc.pass
sudo cp .vnc/passwd /etc/x11vnc.pass
</code></pre>

<h4>启动桌面</h4>

<pre><code>sudo start lightdm
</code></pre>

<h4>连接</h4>

<p>在mac终端敲入</p>

<pre><code>open vnc://&lt;ip_of_pcduino&gt;
</code></pre>

<h4>已知问题</h4>

<p><code>sudo stop lightdm</code>再次<code>sudo start lightdm</code>启动后，客户端无法连接上VNC服务器。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.cnblogs.com/iscode/p/3200503.html">pcDuino 刷系统-卡刷</a></li>
<li><a href="http://www.cnblogs.com/iscode/p/3200558.html">pcDuino无显示器刷机与使用</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kindle PaperWhite作为树莓派的命令终端]]></title>
    <link href="http://vangie.github.com/blog/2013/12/17/kindle-pw-as-a-terminal-connect-to-raspberry-pi/"/>
    <updated>2013-12-17T03:14:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/17/kindle-pw-as-a-terminal-connect-to-raspberry-pi</id>
    <content type="html"><![CDATA[<blockquote><p>网上有大牛把Kindle作为树莓派的显示屏，外带一个Mac蓝牙键盘，实用移动电源供给。一个台低功耗的可移动主机，酷极了。手上真好有一台Kindle PaperWhite，于是开始折腾。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-12-17/kindle-berry.png" alt="KindleBerry" /></p>

<h3>准备工作</h3>

<ol>
<li>Raspberry Pi 一台</li>
<li>Kindle PaperWhite 一台（已<a href="http://www.mobileread.com/forums/showthread.php?t=198446">越狱</a>）</li>
<li>USB转microUSB数据线2根，一根给Raspberry Pi供电，一根作为Kindle和Raspberry Pi的连接线</li>
</ol>


<!-- more -->


<h3>安装USBNetwork</h3>

<p><a href="http://www.mobileread.com/forums/showthread.php?t=186645">USBNetwork</a>工具可以通过usb数据线连接kindle和另一台电脑，实现ssh登录。</p>

<p>安装步骤如下</p>

<ol>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=116323&amp;d=1386361702">Kindle-usbnet-0.1.5N.zip</a>，解压以后仔细阅读<code>README_FIRST.txt</code>文件</li>
<li>将update_usbnet_0.15.N_install_touch_pw.bin拷贝到Kindle根目录</li>
<li><p>Kindle里工具栏菜单[设置]&ndash;> 工具栏菜单[更新您的Kindle]，安装完成后会重启</p>

<p> <img src="http://vangie.github.com/images/post/2013-12-17/kindle_install_sw.png" alt="安装Kindle应用" /></p></li>
<li>安装完成以后Kindle更目录会多出一个<code>usbnet</code>目录和<code>extensions\usbnet</code>目录</li>
<li><p>编辑<code>usbnet\etc\config</code>文件，修改如下</p>

<pre><code> USE_WIFI="true"
 USE_OPENSSH="true"
</code></pre></li>
</ol>


<p><strong>开关USBNetwork模式</strong></p>

<blockquote><p>在Kindle的搜索框内，输入<code>;usbnetwork</code>或者<code>;un</code>。再输入一个可以切换。</p></blockquote>

<p><strong>查看网络状态</strong></p>

<blockquote><p>在Kindle的搜索框内，输入<code>;711</code>。可以查到当前无线网卡的IP地址</p></blockquote>

<h4>Mac通过USB线登录Kindle</h4>

<ol>
<li>用USB线连接Mac和Kindle</li>
<li>默认Kindle会被挂载成存储设备，先弹出该设备</li>
<li>然后开启Kindle的USBNetwork模式</li>
<li><p>Mac[系统偏好设置]&ndash;>[网络] 新建一个RNDIS/Ethernet Gadget链接配置如下</p>

<pre><code> ip:     192.168.15.201
 mask:   255.255.255.0
 router: 192.168.15.244
</code></pre>

<ul>
<li>如果无法创建RNDIS连接，可能需要安装<a href="http://joshuawise.com/horndis">HoRNDIS</a></li>
<li>router的地址要Kindle的<code>/usbnet/etc/config</code>文件里<code>KINDLE_IP</code>项一致</li>
</ul>
</li>
<li><p>终端SSH连接</p>

<pre><code> ssh root@192.168.15.244
</code></pre></li>
</ol>


<h4>通过WiFi登录Kindle</h4>

<ol>
<li>在Kindle的搜索框内，输入<code>;711</code>查找Kindle无线网卡IP</li>
<li>通过终端SSH连接即可</li>
</ol>


<p>到此Kindle的Network算配置完毕，下来我们来配置Kindle的Kterm</p>

<h3>安装KUAL和Kterm</h3>

<h4>KUAL</h4>

<p><a href="http://www.mobileread.com/forums/showthread.php?t=203326">KUAL</a>是Kindle Unified Application Launcher的缩写，其作用是为越狱的Kindle启动第三方应用。简单的说通过一本特殊的书籍来统一实现启动触发器。</p>

<ol>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=115571&amp;d=1385111909">prerequisites-all-supported-devices.zip</a></li>
<li>解压后将update_kindlet-dev-20130710-k5-ALL_install.bin文件拷贝到Kindle根目录，Kindle安装.bin文件的方法都是一样的，Kindle里点击[更新您的Kindle],然后会显示安装进度，自动重启后完成。</li>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=109526&amp;d=1376691043">KUAL.V.2.2.zip</a></li>
<li>解压后将KindleLauncher-2.0.azw2文件拷贝到Kindle的<code>/documents</code>目录</li>
<li>断开连接后Kindle里多了一本《Kindle Launcher》的书，点开有一排可以启动的应用列表。 <br/>
 <img src="http://vangie.github.com/images/post/2013-12-17/kindle_launcher.png" alt="Kindle Launcher" /><img src="http://vangie.github.com/images/post/2013-12-17/kindle_launcher_opened.png" alt="Kindle Launcher打开以后的效果" /></li>
</ol>


<h4>Extend</h4>

<p><code>Extend</code>是一组扩展的预编译好的linux命令行工具，让Kindle可以运行一些常用的linux命令，如：openssh，nano，screen，irssi，php，bash，rsync等。</p>

<ol>
<li>下载<a href="http://ge.tt/9Qoa9YD/v/0?c">optware_img_60m.zip</a>和<a href="http://ge.tt/9Qoa9YD/v/2?c">kindle_extend-1.1.zip</a></li>
<li>解压kindle_extend-1.1.zip到kindle_extend-1.1目录</li>
<li>解压optware_img_60m.zip将<code>optware.img</code>文件替换<code>kindle_extend-1.1/extend/optware.img</code>文件</li>
<li>将<code>kindle_extend-1.1</code>目录下的<code>extend</code>和<code>extensions</code>子目录拷贝到Kindle更目录</li>
<li><p>然后通过SSH登录Kindle执行如下命令</p>

<pre><code> mntroot rw
 mkdir /mnt/us/circles
 cp /mnt/us/extend/mountd /mnt/us/circles
 ln -s /mnt/us/circles/mountd /etc/rc5.d/S101mountd
 mntroot ro
 /mnt/us/install.sh
 /mnt/us/mount.sh
</code></pre></li>
</ol>


<h4>Kterm</h4>

<p><a href="http://www.fabiszewski.net/kindle-terminal/">Kterm</a>是一个内置虚拟键盘的GTK+的Kindle终端模拟器</p>

<p><img src="http://vangie.github.com/images/post/2013-12-17/kterm.gif" alt="Kterm效果图" /></p>

<ol>
<li>下载<a href="http://www.fabiszewski.net/kindle-terminal/kterm-0.7.zip">Kerm 0.7</a></li>
<li>解压后将<a href="https://dl.dropbox.com/s/tagzqiz06fbdltz/kterm-landscape-enabled.zip?token_hash=AAH5k68xlwcYqi065-n5Bu5XaoiEXB12zCDjj50udrRg_w&amp;dl=1">此文件</a>替换<code>kterm/bin/kterm</code>文件。具体看<a href="https://github.com/bfabiszewski/kterm/issues/2#issuecomment-14204814">这里</a></li>
<li>然后将<code>kterm</code>文件夹拷贝到Kindle的<code>extensions</code>目录下</li>
<li>断开Kindle与电脑的链接，通过KUAL打开Kterm，随便Ping台机器试试。</li>
</ol>


<h3>配置Raspberry Pi的USB网络连接</h3>

<p>安装了USBNetwork，Kindle已经可以通过数据线和Mac电脑连网，接下来配置Raspberry Pi的USB网络链接，使Kindle插入Raspberry Pi以后可以自动建立网络连接。</p>

<pre><code>sudo vim /etc/network/interfaces
</code></pre>

<p>添加如下内容</p>

<pre><code>#USB tethering
allow-hotplug usb0
iface usb0 inet static
    address 192.168.15.1
    netmask 255.255.255.0
    broadcast 192.168.15.255
    up iptables -I INPUT 1 -s 192.168.15.1 -j ACCEPT
    up eject /dev/sda1
</code></pre>

<ul>
<li><code>allow-hotplug usb0</code>表示插入USB后自动加载网络配置</li>
<li><code>up eject /dev/sda1</code>表示弹出Kindle自动挂载的磁盘分区</li>
</ul>


<p>重启网络</p>

<pre><code>sudo service networking reload
</code></pre>

<h3>见证奇迹的时刻</h3>

<ol>
<li>使用数据线连接Kindle和Raspberry Pi</li>
<li>开启USBNetwork模式，Kindle的搜索框内，输入<code>;un</code>然后回车</li>
<li><p>打开Kterm键入</p>

<p> ssh <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x70;&#105;&#64;&#x31;&#x39;&#x32;&#46;&#x31;&#x36;&#56;&#46;&#49;&#x35;&#46;&#49;">&#x70;&#x69;&#64;&#x31;&#57;&#50;&#x2e;&#49;&#54;&#56;&#x2e;&#49;&#53;&#46;&#49;</a></p></li>
</ol>


<p>若提示输入密码或者保存密钥指纹，说明大功告成。</p>

<p><strong>Kindle作为跳板机</strong></p>

<p>Kindle和Raspberry Pi顺利创建连接之后，Mac OS可以通过Kindle的Wifi连接SSH登录进Kindle，然后再次SSH登录进入Raspberry Pi。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.ponnuki.net/2012/09/kindleberry-pi/">KindleBerry Pi</a></li>
<li><a href="https://gist.github.com/rvagg/5095506">Kindleberry &ldquo;Paperwhite&rdquo; Pi</a></li>
<li><a href="http://wiki.mobileread.com/wiki/Kindle_Touch_Hacking#GUI_launcher">Kindle Touch Hacking</a></li>
<li><a href="http://maxogden.com/kindleberry-wireless.html">Kindleberry Wireless: A Portable Outdoor Hackstation</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何找到树莓派通过DHCP获得的IP地址]]></title>
    <link href="http://vangie.github.com/blog/2013/12/17/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp/"/>
    <updated>2013-12-17T03:08:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/17/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp</id>
    <content type="html"><![CDATA[<blockquote><p>小巧的树莓派配一个硕大的显示器，很不协调。本文介绍如何获得树莓派通过DHCP动态分配的IP地址。</p></blockquote>

<h3>几种有趣的方法</h3>

<p>mathworks论坛提到了几种有意思的方法</p>

<ol>
<li><p>通过Matlab命令行</p>

<pre><code> h = raspberrypi(‘raspberrypi-ah')
 h.openShell(‘ssh')
</code></pre></li>
<li>安装一个启动过程中能读出IP的软件，该软件也是MathWork出品的</li>
<li>通过DDNS（Dynamic DNS）</li>
<li>启动时发邮件通知</li>
</ol>


<p>就个人而言，上面的方法觉得都不够好。</p>

<ol>
<li>需要安装Matlab，一个好几G的工具软件就是为了找个IP用，有些蛋疼</li>
<li>要插个耳机或者音响什么的</li>
<li>需要互联网环境</li>
<li>需要互联网环境</li>
</ol>


<p>下面我介绍一个简单实用的方法，通过arp协议获得IP</p>

<!-- more -->


<h3>通过arp-scan获得树莓派IP</h3>

<p>arp协议是一个数据链路层协议，负责IP地址和Mac地址的转换。下面我们介绍一个arp-scan工具扫出局域网所有的IP地址</p>

<h4>安装arp-scan</h4>

<p>Mac OS</p>

<pre><code>brew install arp-scan
</code></pre>

<p>Ubuntu</p>

<pre><code>sudo apt-get arp-scan
</code></pre>

<h4>扫描以太网IP地址</h4>

<pre><code>arp-scan --interface en0 --localnet  
</code></pre>

<p>此处en0是网卡的设备名称，可以通过ifconfig命令获得，有多种网卡时注意不要写错</p>

<p>扫描结果如下</p>

<pre><code>nterface: en0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.8 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
192.168.199.1   d4:ee:07:04:0d:e6   (Unknown)
192.168.199.239 e8:8d:28:06:db:2f   (Unknown)
192.168.199.107 b8:27:eb:96:c4:2f  (Unknown)

513 packets received by filter, 0 packets dropped by kernel
Ending arp-scan 1.8: 256 hosts scanned in 1.242 seconds (206.12 hosts/sec). 2 responded
</code></pre>

<p>由于arp-scan的版本比较低，所以主机名为Unknown,不过没有关系，由于树莓派的Mac地址都是<code>b8:27:3b</code>开头的。所以<code>192.168.199.107</code>就是树莓派的IP地址</p>

<h4>One line Command</h4>

<pre><code>arp-scan --interface en0 --localnet | grep grep b8:27:eb
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://blog.remibergsma.com/2013/05/03/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp/">HOWTO discover the ip address of a Raspberry Pi</a></li>
<li><a href="http://www.mathworks.cn/cn/help/simulink/ug/get-the-ip-address-of-the-raspberry_pi-hardware.html">Get IP Address of Raspberry Pi Hardware</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?t=55804">FYI: via Raspi&rsquo;s IP address with &lsquo;arp-scan&rsquo;</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspbian成功驱动TP-Link TL-WN725N V2版无线网卡]]></title>
    <link href="http://vangie.github.com/blog/2013/12/14/tp-link-wn725n-v2-works-on-raspbian/"/>
    <updated>2013-12-14T00:03:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/14/tp-link-wn725n-v2-works-on-raspbian</id>
    <content type="html"><![CDATA[<blockquote><p>淘宝双12搞活动，225入了一台英国产2代B型512M RaspBerry Pi，英国产的相对便宜，但是不带外壳，另外加12块，搞了个带固定螺丝的亚克力外壳。话说这个外壳裁剪的相对不错，花了老半天才装好。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-12-14/4-items.jpg" alt="配件合集" /></p>

<p><img src="http://vangie.github.com/images/post/2013-12-14/raspberry.jpg" alt="组装成品" /></p>

<p><img src="http://vangie.github.com/images/post/2013-12-14/pi-with-tl-wn725n.jpg" alt="TP-Link TL-WN725N V2" /></p>

<!-- more -->


<h3>如何选SD卡</h3>

<p>先罗嗦一段SD卡的选取过程。其实想买开树莓的板子很长时间了，但是如何选SD卡一直犹豫不决。主要考虑两个因素：</p>

<ul>
<li>SD卡的兼容性，某些SD卡树莓派无法识别；</li>
<li>SD卡的读写速度，市面上的Class 10卡从20M/s到UHS-I卡95M/s的价格相差很大。</li>
</ul>


<p>一开始很想选 <a href="http://item.jd.com/530220.html">闪迪（SanDisk）至尊超极速SDHC存储卡 8G-Class10-95MB/s</a> 查了<a href="http://elinux.org/RPi_SD_cards">树莓的SD卡兼容列表</a>显示可以识别，但159元的价格让我犹豫了。</p>

<p>研究了一段时间，发现有网友称树莓派对UHS-I类型的SD支持不好，目前树莓的控制器读取SD卡速度也就20-30M/s。后来选了 <a href="http://item.jd.com/679771.html">闪迪（SanDisk）至尊高速MicroSDHC（TF）存储卡 8G-Class10-30MB/s</a>， 39元搞定。</p>

<h3>安装rtl8188eu驱动模块</h3>

<p>现在进入正题，安装这块无线网卡的驱动是个痛苦的精力，虽然树莓派的官方论坛已经有几篇关于驱动TL-WN725N的帖子：</p>

<ul>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=66&amp;t=55779&amp;sid=946c22c3b95fea0e73539828e33018b1">Getting TL-WN725N working</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=28&amp;t=52932">TL-WN725N V2, raspbian driver update</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=91&amp;t=29752">TP-Link TL-WN725N V2 works out of the box on Raspbian</a></li>
</ul>


<p>但由于Raspbian的版本在不断的升级，生搬帖子上的步骤不起效果。</p>

<p>因为我的这个 <a href="http://item.jd.com/618066.html">TP-LINK TL-WN725N 微型150M无线USB网卡</a> 是先于树莓派购买闲置的。如果买新的话，强烈建议买免驱的无线网卡，省得折腾。比如说这款 <a href="http://item.jd.com/509932.html">EDUP EP-N8508GS黄金版 迷你USB无线网卡</a>.这里有一份<a href="http://elinux.org/RPi_USB_Wi-Fi_Adapters">树莓派支持的无线网卡清单</a></p>

<p>下的步骤是综合了上面的帖子及其引用，不断试错总结出来的步骤。</p>

<h4>确定网卡的版本</h4>

<p>TP-LINK TL-WN725N分<a href="http://wikidevi.com/wiki/TP-LINK_TL-WN725N_v1">V1</a>, <a href="http://wikidevi.com/wiki/TP-LINK_TL-WN725N_v2">V2</a>版本。 <br/>
<img src="http://vangie.github.com/images/post/2013-12-14/tl-wn725n.jpg" alt="" /></p>

<p>将无线网卡插上树莓的USB接口，执行<code>lsusb</code>返回如下</p>

<blockquote><p>Bus 001 Device 004: ID 0bda:8179 Realtek Semiconductor Corp.</p></blockquote>

<p>因为V1和V2的ID代号分别是0bda:8176、0bda:8179。</p>

<p>本文只针对V2版本，V1版本未经测试。</p>

<h4>升级内核</h4>

<pre><code>sudo rpi-update
</code></pre>

<p>升级后执行<code>uname -a</code>的结果是</p>

<blockquote><p>Linux raspberrypi 3.10.24+ #610 PREEMPT Thu Dec 12 13:12:09 GMT 2013 armv6l GNU/Linux</p></blockquote>

<h4>编辑驱动模块</h4>

<pre><code>git clone --depth 1 git://github.com/raspberrypi/linux.git rpi-linux

git clone --depth 1 git://github.com/raspberrypi/firmware.git rpi-firmware

git clone git://github.com/lwfinger/rtl8188eu.git rtl8188eu

cd rpi-linux

make mrproper

zcat /proc/config.gz &gt; .config

make modules_prepare

cp ../rpi-firmware/extra/Module.symvers .

cd ../rtl8188eu

CONFIG_RTL8188EU=m make -C ../rpi-linux M=`pwd`

sudo cp rtl8188eufw.bin /lib/firmware/rtlwifi

sudo install -p -m 644 8188eu.ko /lib/modules/`uname -r`/kernel/drivers/net/wireless

sudo insmod /lib/modules/`uname -r`/kernel/drivers/net/wireless/8188eu.ko

sudo depmod -a
</code></pre>

<h4>验证网卡是否识别</h4>

<p>若上面的命令执行过程没有报错，执行<code>iwconfig</code>的结果如下</p>

<pre><code>wlan0     IEEE 802.11bgn  ESSID:"22_1707"  Nickname:"&lt;WIFI@REALTEK&gt;"
          Mode:Managed  Frequency:2.457 GHz  Access Point: D4:EE:07:04:0D:E6
          Bit Rate:150 Mb/s   Sensitivity:0/0
          Retry:off   RTS thr:off   Fragment thr:off
          Power Management:off
         Link Quality=0/100  Signal level=15/100  Noise level=0/100
         Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
         Tx excessive retries:0  Invalid misc:0   Missed beacon:0

lo        no wireless extensions.

eth0      no wireless extensions.
</code></pre>

<p>证明无线网卡已被识别，下面我们来配置网络参数。</p>

<h4>配置无线网络参数</h4>

<p>打开/etc/wpa_supplicant/wpa_supplicant.conf文件，添加如下内容</p>

<pre><code>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid="NETWORK_NAME"
    psk="NETWORK_PASSWORD"
}
</code></pre>

<p>上面的方法psk是明文，如果觉得敏感，可以使用下面的命令生成密文</p>

<pre><code>wpa_passphrase ssid pass_phrase
</code></pre>

<p>输出如下</p>

<pre><code>network={
        ssid="myrouter"
        #psk="thisisalongpassphrasenobodycanguess"
        psk=fd50e5fb2b66493702338dd5175241d2e8dd7dd42fc292bbb7c56b01f9e9fdc0
}
</code></pre>

<p>将输出结果添加到/etc/wpa_supplicant/wpa_supplicant.conf文件。</p>

<p>重启网络服务<code>sudo service networking reload</code>后</p>

<p>执行<code>ifconfig</code>，如果wlan0获得IP就可以使用了</p>

<pre><code>wlan0     Link encap:Ethernet  HWaddr 14:cf:92:b5:59:6d
          inet addr:192.168.199.109  Bcast:192.168.199.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8805 errors:0 dropped:15 overruns:0 frame:0
          TX packets:600 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:2542242 (2.4 MiB)  TX bytes:82318 (80.3 KiB)
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://smhaziq.blogspot.co.at/2013/06/compiling-tp-link-wn725n-v2-driver-in.html">Compiling TP-LINK WN725N V2 driver in Raspbmc with 3.6.11 kernel</a></li>
<li><a href="https://github.com/liwei/rpi-rtl8188eu">Linux driver for tplink-wn725n nano wireless adapter</a></li>
<li><a href="http://blog.pi3g.com/2013/10/easy-tp-link-tl-wn725-driver-installation/">Easy TP-Link TL-WN725 driver installation</a></li>
<li><a href="http://www.fars-robotics.net/">Fars Robotics Website</a></li>
<li><a href="http://undiff.com/2008/08/wireless-with-wpa_supplicant-easier-then-you-think/">Wireless with wpasupplicant easier then you think</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google屏蔽Linode的IPv6导致SSH隧道不可用]]></title>
    <link href="http://vangie.github.com/blog/2013/11/16/google-block-linode-traffic-over-ipv6/"/>
    <updated>2013-11-16T01:48:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/16/google-block-linode-traffic-over-ipv6</id>
    <content type="html"><![CDATA[<blockquote><p>最近几个月通过linode的SSH隧道访问Google都会报出类似“We‘re sorry”或者“unusual traffic”的错误，有时需要输入验证码，但大多数时候直接不可用。一段时间使用GoAgent比较多，可惜GoAgent有时不太稳定。</p></blockquote>

<p>Google了一番，才知道是因为Google屏蔽了Linode服务器的IPv6协议导致SSH隧道出问题的。
下面我们就来关闭Ubuntu的IPv6</p>

<h3>关闭Ubuntu的IPv6</h3>

<ul>
<li><p>编辑 <code>/etc/sysctl.conf</code>,添加如下内容</p>

<p>  net.ipv6.conf.all.disable_ipv6=1<br/>
  net.ipv6.conf.default.disable_ipv6=1<br/>
  net.ipv6.conf.lo.disable_ipv6=1</p></li>
</ul>


<p>如上修改虽然是永久性的需要重启网卡才能生效<code>/etc/init.d/networking restart</code></p>

<ul>
<li><p>实时生效</p>

<p>  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/lo/disable_ipv6<br/>
  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/lo/disable_ipv6<br/>
  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/all/disable_ipv6<br/>
  echo &lsquo;1&rsquo; > /proc/sys/net/ipv6/conf/default/disable_ipv6</p></li>
</ul>


<p>再试试通过SSH隧道搜索Google，是不是已经好了，^_^。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="https://forum.linode.com/viewtopic.php?f=20&amp;t=10436">Intermittent &ldquo;We&rsquo;re sorry&rdquo; error accessing Google via IPv6</a></li>
<li><a href="http://en.kioskea.net/faq/759-ubuntu-disabling-ipv6-support">Ubuntu &ndash; Disabling IPv6 support</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS X替换Razer的状态栏图标]]></title>
    <link href="http://vangie.github.com/blog/2013/11/16/replace-razer-status-bar-icon-in-macos/"/>
    <updated>2013-11-16T01:37:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/16/replace-razer-status-bar-icon-in-macos</id>
    <content type="html"><![CDATA[<blockquote><p>心爱的QeathAdder炼狱蝰蛇变形金刚款，用了300多天左键坏了，联系易迅给换了个QeathAdder炼狱蝰蛇2013款。虽然黑色的外观不如变形金刚款银色的配MacBook，但是6400dpi的分辨率，着实给力。CS:GO的甩狙命中率显著提升，开始以为年纪大了水平下降了，换鼠标后，发现还是鼠标的问题。话说Razer鼠标的管理界面支持登录以后保存鼠标配置的功能很好，就是状态栏的蓝色图标和Mac OS统一的暗灰色图标比起来太不协调了。</p></blockquote>

<p>默认效果</p>

<p><img src="http://vangie.github.com/images/post/2013-11-16/replace_before.png" alt="" /></p>

<p>替换后的效果</p>

<p><img src="http://vangie.github.com/images/post/2013-11-16/replace_after.png" alt="" /></p>

<p>替换图标</p>

<p><img src="http://vangie.github.com/images/post/2013-11-16/Status.png" alt="" /></p>

<h3>替换图标</h3>

<ol>
<li>在Finder里找到<code>/Library/Application Support/Razer/RzUpdater.app</code>
Command+Shift+G打开GO to对话框，输入<code>/Library/Application Support/Razer</code></li>
<li>右键RzUpdater.app显示包内容</li>
<li>然后再进入<code>Contents/Resources</code>目录</li>
<li>用上面的图标替换Status.png文件即可。</li>
<li>重启系统或者杀掉RzUpdater进程</li>
</ol>


<h3>参考阅读</h3>

<ol>
<li><a href="http://forums.macrumors.com/showthread.php?t=1432198">Razer DeathAdder Icon in Menubar (Synapse 2.0)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Mac正确的识别Noppoo Chic Mini84]]></title>
    <link href="http://vangie.github.com/blog/2013/11/13/noppoo-chic-mini84-osx-support/"/>
    <updated>2013-11-13T14:44:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/13/noppoo-chic-mini84-osx-support</id>
    <content type="html"><![CDATA[<blockquote><p>半年前入了一把Noppoo的84键茶轴机械键盘，这把键盘的手感真心不错，也非常的小巧，很短，放在桌上也一点都不占位置。唯一的缺点就是不支持Mac系统。官方未提供mac版本的驱动程序，在mac系统下有部分键不好用。网上倒是提供了两种解决方案：一种是usb转ps2，再ps2转usb两次转换以后就好用了（依靠转换器里的芯片）；另一个种是安装Github上的<a href="https://github.com/thefloweringash/iousbhiddriver-descriptor-override">第三方驱动</a>。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-11-13/noppoo-chic-mini84.jpg" alt="Noppoo Chic Mini84" /></p>

<p>两种方法都有试过，两次转换可以免去装驱动的麻烦，但是由于接了两个转换器，有时候会接触不好。最后选用了加装驱动的方案。</p>

<!-- more -->


<h3>加装驱动</h3>

<ul>
<li><p>pkg安装包 <a href="https://thefloweringash.com/iousbhiddriver-descriptor-override/downloads/IOUSBHIDDriverDescriptorOverride-2013-04-21-b545d15.pkg">https://thefloweringash.com/iousbhiddriver-descriptor-override/downloads/IOUSBHIDDriverDescriptorOverride-2013-04-21-b545d15.pkg</a></p></li>
<li><p>编译安装</p>

<ol>
<li> 下载源码 <a href="https://github.com/thefloweringash/iousbhiddriver-descriptor-override/archive/master.zip">https://github.com/thefloweringash/iousbhiddriver-descriptor-override/archive/master.zip</a></li>
<li> 编译</li>
</ol>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># dependencies
</span><span class='line'>gem install bundler
</span><span class='line'>bundle install --without scan
</span><span class='line'>
</span><span class='line'># build
</span><span class='line'>xcodebuild
</span><span class='line'>sudo cp -r build/Release/IOUSBHIDDriverDescriptorOverride.kext \
</span><span class='line'>    /System/Library/Extensions
</span><span class='line'>sudo kextutil \
</span><span class='line'>    /System/Library/Extensions/IOUSBHIDDriverDescriptorOverride.kext</span></code></pre></td></tr></table></div></figure>


<pre><code>3. 启动时加载，把com.apple.IOUSBHIDDriverDescriptorOverride.plist复制到/Library/LaunchDaemons/下面
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>launchctl load -w /Library/LaunchDaemons/com.apple.IOUSBHIDDriverDescriptorOverride.plist
</span><span class='line'>launchctl list | grep om.apple.IOUSBHIDDriverDescriptorOverride</span></code></pre></td></tr></table></div></figure>


<h3>安装KeyRemap4MacBook</h3>

<p>下载地址 <a href="https://pqrs.org/macosx/keyremap4macbook/">https://pqrs.org/macosx/keyremap4macbook/</a></p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://likidu.com/noppoo-chic-mini84-osx-support/">Noppoo Chic Mini 84支持Mac OS X</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个优雅的Mac OS服务管理程序launchctl的包装工具]]></title>
    <link href="http://vangie.github.com/blog/2013/11/09/a-nice-launchctl-wrapper-for-macos-deamon-management/"/>
    <updated>2013-11-09T17:32:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/09/a-nice-launchctl-wrapper-for-macos-deamon-management</id>
    <content type="html"><![CDATA[<blockquote><p>launchctl是mac os平台的服务管理程序，相当于linux平台的service。但是launchctl真心难用，比如不支持重启服务，关闭服务需要指定配置文件plist的全路径。<a href="https://github.com/mperham/lunchy">lunchy</a>是一个launchctl的包装程序，大大简化了agent的管理。</p></blockquote>

<h3>安装</h3>

<p>lunchy是一个ruby程序，可以通过gem直接安装</p>

<pre><code>gem install lunchy
</code></pre>

<h3>命令</h3>

<ul>
<li>ls [pattern]</li>
<li>start [pattern]</li>
<li>stop [pattern]</li>
<li>restart [pattern]</li>
<li>status [pattern]</li>
<li>install [file]</li>
<li>show [pattern]</li>
<li>edit [pattern]</li>
</ul>


<p>lunchy的一个重要功能改进是支持通配，除了安装install agent需要指定完整的文件路径外，其他命令只需要输入特征词即可。</p>

<p>比如启动redis服务</p>

<pre><code>launchctl load ~/Library/LaunchAgents/io.redis.redis-server.plist
</code></pre>

<p>使用lunchy非常简单</p>

<pre><code>lunchy start redis
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://v2ex.com/t/88644">OS X 下使用 lunchy 替换 launchctl 管理 daemon apps</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac OS里配置Apache+PHP+Mysql环境]]></title>
    <link href="http://vangie.github.com/blog/2013/11/08/config-apache-php-mysql-on-mac-os/"/>
    <updated>2013-11-08T21:54:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/08/config-apache-php-mysql-on-mac-os</id>
    <content type="html"><![CDATA[<blockquote><p>Apache+PHP+Mysql是PHP开发的标配，Windows系统可以安装<a href="www.easyphp.org">EasyPHP</a>集成包。Mac系统也有相应的集成包<a href="http://www.mamp.info/en/index.html">MAMP</a>。但是考虑到Mac OS已经自带了Apache和PHP环境，重复安装Apache和PHP有些冗余，所有本文介绍如何使用homebrew安装Mysql并且集成原有的Apache和PHP环境。</p></blockquote>

<h3>启动Apache</h3>

<p>打开Terminal，然后运行</p>

<pre><code>sudo apachectl start
</code></pre>

<p>查看Mac OS X的Apache版本</p>

<pre><code>sudo apachectl -v
</code></pre>

<p>Mac OS X 10.9的返回结果是</p>

<blockquote><p>Server version: Apache/2.2.24 (Unix) <br/>
Server built:   Aug 24 2013 21:10:43</p></blockquote>

<p>如此在浏览器中输入<code>http://localhost</code>，就可以看到一个内容为“It works!”的页面，其位于<code>/Library（资源库）/WebServer/Documents/</code>下，这就是Apache的默认根目录。</p>

<p>另外，用户可以通过<code>http://[本地IP]/~[用户名]</code>来访问<code>/Users/[用户名]/Sites/</code>目录</p>

<h3>开启PHP支持</h3>

<ol>
<li>在终端中运行<code>sudo vi /etc/apache2/httpd.conf</code>，打开Apache的配置文件。</li>
<li>找到<code>#LoadModule php5_module libexec/apache2/libphp5.so</code>，把前面的#号去掉，保存（在命令行输入:w）并退出vi（在命令行输入:q）。</li>
<li><p>运行<code>sudo cp /etc/php.ini.default /etc/php.ini</code>，这样就可以运行<code>sudo vi /etc/php.ini</code>来编辑php.ini配置各种功能了。比如：</p>

<p> ;通过下面两项来调整PHP提交文件的最大值，如phpMyAdmin中导入数据的最大值
 upload_max_filesize = 2M
 post_max_size = 8M
 ;通过display_errors来控制是否显示PHP程序的报错信息，这在调试PHP程序时非常有用
 display_errors = Off</p></li>
<li>运行“sudo apachectl restart”，重启Apache，这样PHP就可以用了。</li>
</ol>


<h3>安装Xdebug</h3>

<ol>
<li>在终端执行<code>php -i | pbcopy</code>，php的输出信息会被拷贝的剪切板。</li>
<li>打开<a href="http://xdebug.org/wizard.php">xdebug安装在线向导</a>,在文本框内Command+V，将剪切板内的内容拷贝到文本框，然后点击“Analyse my phpinfo() output”按钮。</li>
<li>根据生成的步骤安装即可。</li>
</ol>


<h3>安装Mysql</h3>

<p>这一步最简单了，前提是已安装了<a href="http://brew.sh">HomeBrew</a>。
在命令行执行</p>

<pre><code>brew install mysql
</code></pre>

<p>安装完成以后,启动mysql服务</p>

<pre><code>mysql.server start
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://dancewithnet.com/2010/05/09/run-apache-php-mysql-in-mac-os-x/">在Mac OS X中配置Apache ＋ PHP ＋ MySQL</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[致青春]]></title>
    <link href="http://vangie.github.com/blog/2013/09/19/for-youth/"/>
    <updated>2013-09-19T03:04:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/19/for-youth</id>
    <content type="html"><![CDATA[<blockquote><p>送给那些而立之年的伙伴们</p></blockquote>

<p>年华易逝，岁月如歌，<br/>
而立之年，青春渐远。</p>

<p>《那些年，我們一起追的女孩 》和《致青春》触动了我们，80后开始集体怀旧。</p>

<p>那些野蛮生长日子里，<br/>
有过期许，<br/>
有过慌张，<br/>
也曾意气风发，<br/>
也曾年少轻狂。</p>

<p>其实每一代人都有怀旧情结，人们之所以怀念过去，往往不是因为追忆的年代比当下更美好，而是那时正值青春。</p>

<p>青春是美好的，<br/>
青春是奔放的，<br/>
青春是热烈的，<br/>
青春是短暂的，<br/>
如花如雨，<br/>
如烟如梦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决国内rubygems速度慢的问题]]></title>
    <link href="http://vangie.github.com/blog/2013/09/18/installing-rubygems-faster/"/>
    <updated>2013-09-18T14:50:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/18/installing-rubygems-faster</id>
    <content type="html"><![CDATA[<blockquote><p>国内访问rubygems那个慢呀，尤其是走https协议。</p></blockquote>

<h3>借用bash的http代理</h3>

<p>一般来说通过翻墙代理访问的速度要更快一点。ruby遵守unix环境变量约定，支持http_proxy和https_proxy。</p>

<p>在执行<code>bundle install</code>之前先执行</p>

<pre><code>$ export http_proxy=http://127.0.0.1:xxxxx/
$ export https_proxy=http://127.0.0.1:xxxxx/
</code></pre>

<p>当然前提是，系统有一个本地可用的http或者https代理。关于bash里使用http代理的细节参见<a href="http://codelife.me/blog/2012/09/02/how-to-set-proxy-for-terminal/">《如何为MacOS X终端设置代理》</a></p>

<h3>改用国内的镜像</h3>

<pre><code>$ gem sources –r http://rubygems.org/
$ gem sources -a http://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***

http://ruby.taobao.org

# 请确保只有 ruby.taobao.org
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://ruby-china.org/topics/288">国内访问rubygems.org好慢啊，大家有没有提速的方法？</a></li>
<li><a href="http://tec.liux.in/28">解决rubygems速度慢的Tips</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash如何创建随机文件名]]></title>
    <link href="http://vangie.github.com/blog/2013/09/16/how-to-create-temporary-random-file-name-in-bash/"/>
    <updated>2013-09-16T23:50:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/16/how-to-create-temporary-random-file-name-in-bash</id>
    <content type="html"><![CDATA[<blockquote><p>本文介绍3种不同的方法创建随机缓存文件名。在编写需要创建唯一的缓存文件的脚本时非常有用。</p></blockquote>

<h3>1.使用$RANDOM shell变量</h3>

<p>在控制台执行如下命令</p>

<pre><code>echo $RANDOM
</code></pre>

<p>每次都获得一个随机数，借用这个变量可用来生成一个随机的文件名</p>

<pre><code>#!/bin/bash
echo "List of temporary files : "
for i  in 1 2 3 4 5
do
    FILE="/tmp/$(basename $0).$RANDOM.txt"
    echo $FILE # show file name
    &gt; $FILE # create files
done 
</code></pre>

<h3>2.使用$$变量</h3>

<p>这是一个经典的方法，$$变量返回当前进程的进程号，对于整个系统来说这是一个唯一数字。</p>

<pre><code>#!/bin/bash
TFILE="/tmp/$(basename $0).$$.tmp"
ls &gt; $TFILE
echo "See diretory listing in $TFILE"
</code></pre>

<h3>3.使用mktemp和tempfile命令</h3>

<p>通过mktemp和tempfile命令是最佳的方式</p>

<pre><code>$ mktemp
</code></pre>

<p>输出</p>

<pre><code>/tmp/tmp.IAnO5O
</code></pre>

<p>或者</p>

<pre><code>$ tempfile
</code></pre>

<p>输出</p>

<pre><code>/tmp/IAnO5O
</code></pre>

<p>当然还能生成随机文件夹</p>

<pre><code>$ mktemp -d
$ tempfile -d
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.cyberciti.biz/tips/shell-scripting-bash-how-to-create-temporary-random-file-name.html">Shell scripting (BASH) : How to create temporary random file name</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx反向代理映射成子路径]]></title>
    <link href="http://vangie.github.com/blog/2013/09/12/reverse-proxy-for-a-subdirectory-in-nginx/"/>
    <updated>2013-09-12T17:41:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/12/reverse-proxy-for-a-subdirectory-in-nginx</id>
    <content type="html"><![CDATA[<blockquote><p>终于搞定了困扰已久的nginx反向代理子路径映射问题</p></blockquote>

<p>多个web应用共享一个域名和端口时，可以考虑把不同的web应用映射成不同的子路径，这个子路径在Java EE里称作ContextPath。下面的配置片段解决nginx作为前端，反向代理多个tomcat主机，通过不同子路径共享一个域名的情况。</p>

<pre><code>server {
    listen       80;
    server_name  _;
    index index.html index.htm index.php;
    root /home/dashboard;

    location /dashboard {
        rewrite /dashboard/(.*) /$1 break;
        rewrite ^/dashboard$ /dashboard/ permanent;
        proxy_pass http://127.0.0.1:9082;
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://wiki.apache.org/couchdb/Nginx_As_a_Reverse_Proxy">Nginx_As_a_Reverse_Proxy</a></li>
<li><a href="http://superuser.com/questions/603373/how-do-i-reverse-proxy-etherpad-lite-with-nginx-to-a-subdirectory">How do I reverse proxy etherpad-lite with nginx to a subdirectory</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩展Backbone.Router以支持window.history.back]]></title>
    <link href="http://vangie.github.com/blog/2013/09/02/extend-Backbone.Router-to-support-window.history.back/"/>
    <updated>2013-09-02T21:37:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/02/extend-Backbone.Router-to-support-window.history.back</id>
    <content type="html"><![CDATA[<blockquote><p>web应用程序重要的功能的URL通过需要达到可访问，可收藏和可分享的需求。Backbone.Router正是检测客户端url变化触发相应动作和事件的实现框架。对于没有实现HTML5 History API的浏览器，Router提供了优雅和透明的兼容实现，通过控制hash的变化。</p></blockquote>

<h3>Route的例子</h3>

<pre><code>var Workspace = Backbone.Router.extend({

    routes: {
        "help":                 "help",    // #help
        "search/:query":        "search",  // #search/kiwis
        "search/:query/p:page": "search"   // #search/kiwis/p7
    },

    help: function() {
        ...
    },

    search: function(query, page) {
        ...
    }

});
</code></pre>

<!-- more -->


<h3>Router的问题</h3>

<p>Router很好的解决了进入一个url能触发相应的方法的问题，但是如果在离开某个url想触发相应的方法，Router显得无能为力。通常如果想通过window.history.back()退回上一页面是，触发相应的方法，就需要Router支持leave方法。</p>

<p>下面我们介绍如何通过扩展Backbone.Router已支持leave。</p>

<h3>扩展Backbone.Router</h3>

<pre><code>class BaseRouter extends Backbone.Router
  route: (route, name, callback)-&gt;

    fn = callback

    route = this._routeToRegExp(route) unless _.isRegExp route

    if _.isFunction name
      callback = name
      name = ''

    fn = callback = this[name] unless callback

    if typeof callback == 'object'
      before = callback.before
      fn = callback.route
      after = callback.after

    Backbone.history.route(route, (fragment)=&gt;
      args = @_extractParameters(route, fragment)

      if leave
        if leave() is false
          return
        else
          leave = false

      return if before and before.apply(@, args) is false
      fn.apply(@, args) if fn
      return if after and after.apply(@, args) is false

      if typeof callback == 'object'
        leave = ((_this, args)-&gt;-&gt;callback.leave.apply(_this, args))(@, args)

      @trigger.apply(@, ["route:#{name}"].concat(args))
      @trigger('route', name, args)
      Backbone.history.trigger('route', @, name, args)
    )
    @
</code></pre>

<h3>编写Router</h3>

<pre><code>class extends Base.Router
  routes:
    "bsdn_editor_:uid/writer":    "fullscreen"
    #catch every url for leave
    "*splat": -&gt;

  fullscreen: {
    route: (uid)-&gt;
      $("#bsdn_editor_#{uid}").parent().editor('showFullscreen')
    leave: (uid)-&gt;
      $("#bsdn_editor_#{uid}").parent().editor('hideFullscreen')
  }
</code></pre>

<h3>参考阅读</h3>

<p>[1] <a href="https://gist.github.com/corpix/1972890">Backbone router before,after,leave</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在backbonejs里使用coffeescript实现mixin]]></title>
    <link href="http://vangie.github.com/blog/2013/07/26/using-mixins-in-backbonejs-by-coffeescript/"/>
    <updated>2013-07-26T09:08:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/07/26/using-mixins-in-backbonejs-by-coffeescript</id>
    <content type="html"><![CDATA[<blockquote><p>Mixin和Inheritance是两种主要的代码复用和封装的方式。Java流行的时候，大家都努力的把javascript写得像java，各大框架努力给javascript加上类继承的特性。当下是Ruby春暖花开的日子，coffeescript让开发者可以以更ruby的方式写js。javascript在不同的时期能适应潮流，足以见得原型链继承型语言的强大之处。</p></blockquote>

<h3>用coffeescript实现Mixin</h3>

<p>Coffescript原生并不支持Mixin，《CoffeeScript小书》第三章提到一种Mixin的实现方式</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">moduleKeywords = </span><span class="p">[</span><span class="s">&#39;extended&#39;</span><span class="p">,</span> <span class="s">&#39;included&#39;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nx">Module</span>
</span><span class='line'>  <span class="vi">@extend: </span><span class="nf">(obj) -&gt;</span>
</span><span class='line'>    <span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">obj</span> <span class="k">when</span> <span class="nx">key</span> <span class="o">not</span> <span class="k">in</span> <span class="nx">moduleKeywords</span>
</span><span class='line'>      <span class="nx">@</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">obj</span><span class="p">.</span><span class="nx">extended</span><span class="o">?</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">@</span><span class="p">)</span>
</span><span class='line'>    <span class="k">this</span>
</span><span class='line'>
</span><span class='line'>  <span class="vi">@include: </span><span class="nf">(obj) -&gt;</span>
</span><span class='line'>    <span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">obj</span> <span class="k">when</span> <span class="nx">key</span> <span class="o">not</span> <span class="k">in</span> <span class="nx">moduleKeywords</span>
</span><span class='line'>      <span class="c1"># Assign properties to the prototype</span>
</span><span class='line'>      <span class="nx">@</span><span class="o">::</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">obj</span><span class="p">.</span><span class="nx">included</span><span class="o">?</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">@</span><span class="p">)</span>
</span><span class='line'>    <span class="k">this</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>上面代码定义了一个Module类型，其包含@extend和@incude两个成员方法，@include方法继承的属性可被实例访问，@extend方法继承的属性可被类访问。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">classProperties = </span>
</span><span class='line'>  <span class="nv">find: </span><span class="nf">(id) -&gt;</span>
</span><span class='line'>  <span class="nv">create: </span><span class="nf">(attrs) -&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">instanceProperties =</span>
</span><span class='line'>  <span class="nv">save: </span><span class="o">-&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nx">User</span> <span class="k">extends</span> <span class="nx">Module</span>
</span><span class='line'>  <span class="nx">@extend</span> <span class="nx">classProperties</span>
</span><span class='line'>  <span class="nx">@include</span> <span class="nx">instanceProperties</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Usage:</span>
</span><span class='line'><span class="nv">user = </span><span class="nx">User</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nv">user = </span><span class="k">new</span> <span class="nx">User</span>
</span><span class='line'><span class="nx">user</span><span class="p">.</span><span class="nx">save</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3>胖箭头<code>=&gt;</code>和Mixin</h3>

<p>coffeescript里用<code>-&gt;</code>符号声明一个function，用<code>=&gt;</code>符号声明一个绑定上下文this的function。 <br/>
下面是一个使用胖箭头声明的function的例子</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">Mixin =</span>
</span><span class='line'>  <span class="nv">fun1 : </span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="o">=&gt;</span>
</span><span class='line'>    <span class="vi">@customer = </span><span class="nx">customer</span>
</span><span class='line'>    <span class="vi">@cart = </span><span class="nx">cart</span>
</span><span class='line'>
</span><span class='line'>  <span class="nv">fun2 : </span><span class="nf">(customer, cart) -&gt;</span>
</span><span class='line'>    <span class="vi">@customer = </span><span class="nx">customer</span>
</span><span class='line'>    <span class="vi">@cart = </span><span class="nx">cart</span>
</span></code></pre></td></tr></table></div></figure>


<p>翻译成javascript如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Mixin</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Mixin</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">fun1</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">_this</span><span class="p">.</span><span class="nx">customer</span> <span class="o">=</span> <span class="nx">customer</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">cart</span> <span class="o">=</span> <span class="nx">cart</span><span class="p">;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">fun2</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">customer</span> <span class="o">=</span> <span class="nx">customer</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cart</span> <span class="o">=</span> <span class="nx">cart</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面例子中，将Mixin声明为普通对象，由于<em>this并指向当前Mixin所在的上下文this，当<code>=&gt;</code>声明的方法fun1被include到其他类中，</em>this并不会指向新的对象，有悖于通常的面向对象语言中this的语义。 <br/>
<code>-&gt;</code>声明的方法虽然this没有被静态绑定，但是由于js中this指向执行时的上下文，所以在方法被外部调用时，不能执行声明方法的类对象。</p>

<p>再来看看把Mixin声明成class的情况</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">Mixin</span>
</span><span class='line'>  <span class="nv">fun1 : </span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="o">=&gt;</span>
</span><span class='line'>    <span class="vi">@customer = </span><span class="nx">customer</span>
</span><span class='line'>    <span class="vi">@cart = </span><span class="nx">cart</span>
</span><span class='line'>
</span><span class='line'>  <span class="nv">fun2 : </span><span class="nf">(customer, cart) -&gt;</span>
</span><span class='line'>    <span class="vi">@customer = </span><span class="nx">customer</span>
</span><span class='line'>    <span class="vi">@cart = </span><span class="nx">cart</span>
</span></code></pre></td></tr></table></div></figure>


<p>翻译成javascript如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Mixin</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">__bind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">me</span><span class="p">){</span> <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span> <span class="p">};</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Mixin</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">Mixin</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">fun1</span> <span class="o">=</span> <span class="nx">__bind</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">fun1</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">Mixin</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">fun1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">customer</span> <span class="o">=</span> <span class="nx">customer</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cart</span> <span class="o">=</span> <span class="nx">cart</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">Mixin</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">fun2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">customer</span> <span class="o">=</span> <span class="nx">customer</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cart</span> <span class="o">=</span> <span class="nx">cart</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">Mixin</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">})();</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果将Mixin声明为一个class，翻译成js以后，Mixin里声明的方法都被注册到Mixin.prototype上了。而且this的绑定被写在了Mixin的构造方法里，通过一个__bind包装函数进行晚绑定。如果不调用Mixin的构造方法，我们可以绑定派生类的this到方法上。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">Mixin</span>
</span><span class='line'>  <span class="nv">b: </span><span class="o">=&gt;</span> <span class="vi">@something = </span><span class="mi">2</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nx">Foo</span> <span class="k">extends</span> <span class="nx">Module</span>
</span><span class='line'>  <span class="nx">@include</span> <span class="nv">Mixin::</span>
</span><span class='line'>  <span class="nv">constructor: </span><span class="o">-&gt;</span>
</span><span class='line'>    <span class="k">for</span> <span class="nx">fname</span> <span class="k">in</span> <span class="nx">_</span><span class="p">.</span><span class="nx">functions</span> <span class="nx">Mixin</span>
</span><span class='line'>      <span class="nx">@</span><span class="p">[</span><span class="nx">fname</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">bind</span> <span class="nx">@</span><span class="p">[</span><span class="nx">fname</span><span class="p">],</span> <span class="nx">@</span>
</span><span class='line'>    <span class="k">super</span>
</span></code></pre></td></tr></table></div></figure>


<p>有两点需要注意 <br/>
1. @include Minxin.prototype
2. 构造方法中将从Mixin里继承的方法都重新绑定this</p>

<p>如果使用underscore的_.bindAll方法，绑定this可以简化成</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">bindAll</span> <span class="nx">@</span><span class="p">,</span> <span class="nx">_funcitons</span><span class="p">(</span><span class="nx">Mixin</span><span class="p">)...</span>
</span></code></pre></td></tr></table></div></figure>


<h3>结合backbonejs使用Mixin</h3>

<p>使用上面的方法，在coffeescript里使用mixin，已经完美的解决了<code>=&gt;</code>this绑定的问题。</p>

<p>先解决Backbone对象不支持include的问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">include</span> <span class="o">=</span>
</span><span class='line'>  <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">include</span> <span class="o">=</span>
</span><span class='line'>  <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">include</span> <span class="o">=</span>
</span><span class='line'>  <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Router</span><span class="p">.</span><span class="nx">include</span> <span class="o">=</span>
</span><span class='line'>  <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">_ref</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">value</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">!==</span> <span class="s1">&#39;included&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="nx">_ref</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">included</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">_ref</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="p">}).</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>声明一个Mixin类</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">Mixin</span>
</span><span class='line'>  <span class="nv">b: </span><span class="o">=&gt;</span> <span class="vi">@something = </span><span class="mi">2</span>  
</span></code></pre></td></tr></table></div></figure>


<p>include该Mixin类</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">FooView</span> <span class="k">extends</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span>
</span><span class='line'>  <span class="nx">@include</span> <span class="nx">Mixin</span>
</span><span class='line'>  <span class="nv">constructor: </span><span class="o">-&gt;</span>
</span><span class='line'>    <span class="nv">b: </span><span class="o">=&gt;</span> <span class="vi">@something = </span><span class="mi">2</span>
</span><span class='line'>    <span class="k">super</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考阅读</h3>

<ol>
<li><a href="https://gist.github.com/olivoil/1642328">Mixins/Modules behavior in coffeescript</a></li>
<li><a href="http://stackoverflow.com/questions/12839183/using-mixins-in-coffeescript">Using mixins in Coffeescript</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
