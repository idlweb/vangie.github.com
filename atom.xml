<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Code Life]]></title>
  <link href="http://vangie.github.com/atom.xml" rel="self"/>
  <link href="http://vangie.github.com/"/>
  <updated>2014-01-08T21:41:58+08:00</updated>
  <id>http://vangie.github.com/</id>
  <author>
    <name><![CDATA[Vangie Du]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[将树莓派配置成时间胶囊]]></title>
    <link href="http://vangie.github.com/blog/2013/12/21/raspberry-pi-as-time-capsule/"/>
    <updated>2013-12-21T21:00:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/21/raspberry-pi-as-time-capsule</id>
    <content type="html"><![CDATA[<blockquote><p>MacBookAir的SSD坏了两次以后，发现TimeMachine真的很有必要。外插个尿袋子真的不方便。AirPort Time Capsule 2T版本价格买到了$299，觉得有些不值。$25的树莓派+一块移动硬盘DIY一个Time Capsule即经济又有趣。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-12-21/raspberry-pi-as-time-capsule.png" alt="Raspberry Pi as TimeCapsule" /></p>

<!-- more -->


<h3>组件清单</h3>

<p><img src="http://vangie.github.com/images/post/2013-12-21/component-of-time-capsule.png" alt="Component of TimeCapsule" /></p>

<ul>
<li>树莓派

<ul>
<li>TF卡 + 卡套</li>
<li>USB WiFi 网卡</li>
<li>5V电源 + MicroUSB 电源线</li>
</ul>
</li>
<li>移动硬盘

<ul>
<li>2.5寸 500G SATA 硬盘</li>
<li>USB3.0 硬盘电路板</li>
<li>USB3.0 数据线</li>
</ul>
</li>
</ul>


<h3>安装HFS+文件系统工具</h3>

<pre><code>sudo apt-get install hfsplus hfsutils hfsprogs
</code></pre>

<h3>准备HFS+设备</h3>

<p>列出所有块设备</p>

<pre><code>sudo blkid
</code></pre>

<p>返回如下</p>

<pre><code>/dev/mmcblk0p1: LABEL="RECOVERY" UUID="F69B-A989" TYPE="vfat"
/dev/mmcblk0p3: LABEL="SETTINGS" UUID="7f8a9faf-84a1-4062-ab9c-b2e6115035ce" TYPE="ext4"
/dev/mmcblk0p5: LABEL="BOOT" UUID="03D6-2985" TYPE="vfat"
/dev/mmcblk0p6: LABEL="root" UUID="e2a46600-20ca-42f4-8ec8-aa52d258aad2" TYPE="ext4"
/dev/sda1: UUID="943f46c5-2de2-3ef9-8494-46c3cf8bd915" LABEL="Time Capsule" TYPE="hfsplus"
</code></pre>

<p>包含TYPE=“hfsplus”的即是。</p>

<p>如果希望把一个新的分区格式化为HFS+，使用如下命令</p>

<pre><code>sudo mkfs.hfsplus -v "Time Capsule" /dev/sda1
</code></pre>

<p><strong>建议使用全新的hfs+分区</strong>
把一块已经做过TimeMachine的hfs+分区，可能导致原有的备份数据丢失</p>

<h3>挂载</h3>

<pre><code>sudo mkidr /media/TimeCapsule
sudo mount -t hfsplus -o force /dev/sda1 /media/TimeCapsule
sudo chown -R pi:pi /media/TimeCapsule
</code></pre>

<h3>安装配置netatalk服务</h3>

<pre><code>sudo apt-get install netatalk
sudo echo "/media/TimeCapsule \"Time Capsule\" options:tm" &gt;&gt; /etc/netatalk/AppleVolumes.default
sudo service netatalk restart
</code></pre>

<p>接下来就可以从Mac的Time Machine里找到这块磁盘 <br/>
<img src="http://vangie.github.com/images/post/2013-12-21/avaliable-disk.png" alt="选择Time Machine磁盘" /></p>

<h3>配置Avahi</h3>

<p>安装<code>avahi-daemon</code>和<code>libnss-mdns</code></p>

<pre><code>sudo apt-get install avahi-daemon libnss-mdns
</code></pre>

<p>配置nsswitch.conf</p>

<p>在<code>hosts:</code>后添加“mdns”</p>

<pre><code>hosts:      files mdns4_minimal [NOTFOUND=return] dns mdns4 mdns
</code></pre>

<p>接下来让Avahi在局域网广播AFP共享</p>

<p>添加如下文件<code>/etc/avahi/services/afpd.service</code>内容如下：</p>

<pre><code>&lt;?xml version="1.0" standalone='no'?&gt;&lt;!--*-nxml-*--&gt;
&lt;!DOCTYPE service-group SYSTEM "avahi-service.dtd"&gt;
&lt;service-group&gt;
    &lt;name replace-wildcards="yes"&gt;%h&lt;/name&gt;
    &lt;service&gt;
        &lt;type&gt;_afpovertcp._tcp&lt;/type&gt;
        &lt;port&gt;548&lt;/port&gt;
    &lt;/service&gt;
    &lt;service&gt;
        &lt;type&gt;_device-info._tcp&lt;/type&gt;
       &lt;port&gt;0&lt;/port&gt;
        &lt;txt-record&gt;model=Xserve&lt;/txt-record&gt;
    &lt;/service&gt;
&lt;/service-group&gt;
</code></pre>

<p>重启服务</p>

<pre><code>sudo /etc/init.d/avahi-daemon restart
</code></pre>

<p>在findler的左侧可以看到共享的文件系统</p>

<p><img src="http://vangie.github.com/images/post/2013-12-21/share.png" alt="共享" /></p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.zisoft.de/elektronik/raspberrypi/timecapsule.html">Raspberry Pi als TimeCapsule</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=36&amp;t=47029">Use rPi as a Time Capsule - another method</a></li>
<li><a href="http://garmoncheg.blogspot.jp/2012/11/time-capsule-for-25.html">Time Capsule for $25</a></li>
<li><a href="http://andadapt.com/raspberry-pi-raspbian-hfs-afp-and-time-machine/">Raspberry Pi, Raspbian, HFS+, AFP and Time Machine</a></li>
<li><a href="http://kremalicious.com/ubuntu-as-mac-file-server-and-time-machine-volume/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+kremalicious+(kremalicious">HowTo: Make Ubuntu a Perfect Mac File Server and Time Machine Volume</a>)</li>
<li><a href="http://www.andyibanez.com/260-linux-file-server-os-x-mavericks">Making A Linux File Server That Interacts With OS X Mavericks</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pcDuino上手记]]></title>
    <link href="http://vangie.github.com/blog/2013/12/19/beginner-of-pcduino/"/>
    <updated>2013-12-19T15:05:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/19/beginner-of-pcduino</id>
    <content type="html"><![CDATA[<blockquote><p>感谢刘博士送的这块pcDuino板。入Raspberry Pi前，优先考虑过pcDuino。在OSChina源创会上海站被刘博士打动过。买Raspberry Pi是为了DIY一个Mac的Time Capsule。随便Google了一下，找到了Raspberry实现Time Capsule的相关资料，而pcDuino的相关资料没有找到，于是作罢。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-12-19/pcduinov2.jpg" alt="pcDuino V2" /></p>

<p>由于Raspberry Pi的先入为主，上手pcDuino碰到写问题，下面一一列出</p>

<!-- more -->


<h3>选什么TF卡</h3>

<p>关于如何选购Raspberry Pi的SD卡，我好生下了功夫，最后还是有不好收获的。没有话冤枉钱买极速的。</p>

<p><strong>兼容列表</strong> <br/>
pcDuino支持哪些TF卡，网上找不到兼容列表。可能是都支持吧，不需要。</p>

<p><strong>读写速度</strong> <br/>
最大支持到少读写速度也找不到资料。</p>

<p>后来得知板载的2G闪存里内置了ubuntu系统，于是TF卡的问题就先悬着吧，等搞清楚再做决定。</p>

<h3>启动pcDuino</h3>

<p>插上网线，pcDuino的网线口比Raspberry Pi的要小巧，但是有些过紧，拔出网线时候要小心，别弄断了。
插上电源线，指示灯亮了。</p>

<p>没有显示器，IP地址默认应该是DHCP的，先要找到IP地址。</p>

<p><strong>找到IP地址</strong></p>

<pre><code>arp-scan --localnet
</code></pre>

<p>如果发现主机名ubuntu，那就是了。要是没有就找Unknow的逐个ssh测试，能连接上的就是。</p>

<h3>初始化系统</h3>

<p>ssh登录系统以后先执行系统初始化</p>

<pre><code>sudo board-config.sh
</code></pre>

<h3>安装Vim</h3>

<p>一直不习惯原生的vi，对方向键支持不好。</p>

<pre><code>sudo apt-get install vim
</code></pre>

<p>安装不成功，返回如下</p>

<pre><code>Reading package lists... Done
Building dependency tree
Reading state information... Done

....省去若干行

Failed to fetch http://ports.ubuntu.com/ubuntu-ports/pool/main/p/python2.7/libpython2.7_2.7.3-0ubuntu3.2_armhf.deb  404  Not Found
E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?
</code></pre>

<p>一大堆404，提示先<code>apt-get update</code>,好吧</p>

<pre><code>sudo apt-get update
</code></pre>

<p>返回如下</p>

<pre><code>....省去若干行

Get:20 http://ports.ubuntu.com precise-updates/universe Translation-en [132 kB]
Fetched 2681 kB in 21s (123 kB/s)
Reading package lists... Done
W: Conflicting distribution: http://www.wiimu.com pcduino Release (expected pcduino but got )
</code></pre>

<p>编辑器打开<code>/etc/apt/sources.list</code>,注释掉最后两行</p>

<pre><code>#deb http://www.wiimu.com:8020/pcduino/ pcuino main
#deb-src http://www.wimu.com:8020/pcduion/ pcduino main
</code></pre>

<p>然后在<code>sudo apt-get update</code>就正常了。</p>

<h3>VNC远程桌面</h3>

<h4>设置vnc密码</h4>

<pre><code>sudo x11vnc -storepasswd
sudo x11vnc -storepasswd in /etc/x11vnc.pass
sudo cp .vnc/passwd /etc/x11vnc.pass
</code></pre>

<h4>启动桌面</h4>

<pre><code>sudo start lightdm
</code></pre>

<h4>连接</h4>

<p>在mac终端敲入</p>

<pre><code>open vnc://&lt;ip_of_pcduino&gt;
</code></pre>

<h4>已知问题</h4>

<p><code>sudo stop lightdm</code>再次<code>sudo start lightdm</code>启动后，客户端无法连接上VNC服务器。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.cnblogs.com/iscode/p/3200503.html">pcDuino 刷系统-卡刷</a></li>
<li><a href="http://www.cnblogs.com/iscode/p/3200558.html">pcDuino无显示器刷机与使用</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kindle PaperWhite作为树莓派的命令终端]]></title>
    <link href="http://vangie.github.com/blog/2013/12/17/kindle-pw-as-a-terminal-connect-to-raspberry-pi/"/>
    <updated>2013-12-17T03:14:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/17/kindle-pw-as-a-terminal-connect-to-raspberry-pi</id>
    <content type="html"><![CDATA[<blockquote><p>网上有大牛把Kindle作为树莓派的显示屏，外带一个Mac蓝牙键盘，实用移动电源供给。一个台低功耗的可移动主机，酷极了。手上真好有一台Kindle PaperWhite，于是开始折腾。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-12-17/kindle-berry.png" alt="KindleBerry" /></p>

<h3>准备工作</h3>

<ol>
<li>Raspberry Pi 一台</li>
<li>Kindle PaperWhite 一台（已<a href="http://www.mobileread.com/forums/showthread.php?t=198446">越狱</a>）</li>
<li>USB转microUSB数据线2根，一根给Raspberry Pi供电，一根作为Kindle和Raspberry Pi的连接线</li>
</ol>


<!-- more -->


<h3>安装USBNetwork</h3>

<p><a href="http://www.mobileread.com/forums/showthread.php?t=186645">USBNetwork</a>工具可以通过usb数据线连接kindle和另一台电脑，实现ssh登录。</p>

<p>安装步骤如下</p>

<ol>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=116323&amp;d=1386361702">Kindle-usbnet-0.1.5N.zip</a>，解压以后仔细阅读<code>README_FIRST.txt</code>文件</li>
<li>将update_usbnet_0.15.N_install_touch_pw.bin拷贝到Kindle根目录</li>
<li><p>Kindle里工具栏菜单[设置]-> 工具栏菜单[更新您的Kindle]，安装完成后会重启</p>

<p> <img src="http://vangie.github.com/images/post/2013-12-17/kindle_install_sw.png" alt="安装Kindle应用" /></p></li>
<li>安装完成以后Kindle更目录会多出一个<code>usbnet</code>目录和<code>extensions\usbnet</code>目录</li>
<li><p>编辑<code>usbnet\etc\config</code>文件，修改如下</p>

<pre><code> USE_WIFI="true"
 USE_OPENSSH="true"
</code></pre></li>
</ol>


<p><strong>开关USBNetwork模式</strong></p>

<blockquote><p>在Kindle的搜索框内，输入<code>;usbnetwork</code>或者<code>;un</code>。再输入一个可以切换。</p></blockquote>

<p><strong>查看网络状态</strong></p>

<blockquote><p>在Kindle的搜索框内，输入<code>;711</code>。可以查到当前无线网卡的IP地址</p></blockquote>

<h4>Mac通过USB线登录Kindle</h4>

<ol>
<li>用USB线连接Mac和Kindle</li>
<li>默认Kindle会被挂载成存储设备，先弹出该设备</li>
<li>然后开启Kindle的USBNetwork模式</li>
<li><p>Mac[系统偏好设置]->[网络] 新建一个RNDIS/Ethernet Gadget链接配置如下</p>

<pre><code> ip:     192.168.15.201
 mask:   255.255.255.0
 router: 192.168.15.244
</code></pre>

<ul>
<li>如果无法创建RNDIS连接，可能需要安装<a href="http://joshuawise.com/horndis">HoRNDIS</a></li>
<li>router的地址要Kindle的<code>/usbnet/etc/config</code>文件里<code>KINDLE_IP</code>项一致</li>
</ul>
</li>
<li><p>终端SSH连接</p>

<pre><code> ssh root@192.168.15.244
</code></pre></li>
</ol>


<h4>通过WiFi登录Kindle</h4>

<ol>
<li>在Kindle的搜索框内，输入<code>;711</code>查找Kindle无线网卡IP</li>
<li>通过终端SSH连接即可</li>
</ol>


<p>到此Kindle的Network算配置完毕，下来我们来配置Kindle的Kterm</p>

<h3>安装KUAL和Kterm</h3>

<h4>KUAL</h4>

<p><a href="http://www.mobileread.com/forums/showthread.php?t=203326">KUAL</a>是Kindle Unified Application Launcher的缩写，其作用是为越狱的Kindle启动第三方应用。简单的说通过一本特殊的书籍来统一实现启动触发器。</p>

<ol>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=115571&amp;d=1385111909">prerequisites-all-supported-devices.zip</a></li>
<li>解压后将update_kindlet-dev-20130710-k5-ALL_install.bin文件拷贝到Kindle根目录，Kindle安装.bin文件的方法都是一样的，Kindle里点击[更新您的Kindle],然后会显示安装进度，自动重启后完成。</li>
<li>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=109526&amp;d=1376691043">KUAL.V.2.2.zip</a></li>
<li>解压后将KindleLauncher-2.0.azw2文件拷贝到Kindle的<code>/documents</code>目录</li>
<li>断开连接后Kindle里多了一本《Kindle Launcher》的书，点开有一排可以启动的应用列表。 <br/>
 <img src="http://vangie.github.com/images/post/2013-12-17/kindle_launcher.png" alt="Kindle Launcher" /><img src="http://vangie.github.com/images/post/2013-12-17/kindle_launcher_opened.png" alt="Kindle Launcher打开以后的效果" /></li>
</ol>


<h4>Extend</h4>

<p><code>Extend</code>是一组扩展的预编译好的linux命令行工具，让Kindle可以运行一些常用的linux命令，如：openssh，nano，screen，irssi，php，bash，rsync等。</p>

<ol>
<li>下载<a href="http://ge.tt/9Qoa9YD/v/0?c">optware_img_60m.zip</a>和<a href="http://ge.tt/9Qoa9YD/v/2?c">kindle_extend-1.1.zip</a></li>
<li>解压kindle_extend-1.1.zip到kindle_extend-1.1目录</li>
<li>解压optware_img_60m.zip将<code>optware.img</code>文件替换<code>kindle_extend-1.1/extend/optware.img</code>文件</li>
<li>将<code>kindle_extend-1.1</code>目录下的<code>extend</code>和<code>extensions</code>子目录拷贝到Kindle更目录</li>
<li><p>然后通过SSH登录Kindle执行如下命令</p>

<pre><code> mntroot rw
 mkdir /mnt/us/circles
 cp /mnt/us/extend/mountd /mnt/us/circles
 ln -s /mnt/us/circles/mountd /etc/rc5.d/S101mountd
 mntroot ro
 ./mnt/us/install.sh
 ./mnt/us/mount.sh
</code></pre></li>
</ol>


<h4>Kterm</h4>

<p><a href="http://www.fabiszewski.net/kindle-terminal/">Kterm</a>是一个内置虚拟键盘的GTK+的Kindle终端模拟器</p>

<p><img src="http://vangie.github.com/images/post/2013-12-17/kterm.gif" alt="Kterm效果图" /></p>

<ol>
<li>下载<a href="http://www.fabiszewski.net/kindle-terminal/kterm-0.7.zip">Kerm 0.7</a></li>
<li>解压后将<a href="https://dl.dropbox.com/s/tagzqiz06fbdltz/kterm-landscape-enabled.zip?token_hash=AAH5k68xlwcYqi065-n5Bu5XaoiEXB12zCDjj50udrRg_w&amp;dl=1">此文件</a>替换<code>kterm/bin/kterm</code>文件。具体看<a href="https://github.com/bfabiszewski/kterm/issues/2#issuecomment-14204814">这里</a></li>
<li>然后将<code>kterm</code>文件夹拷贝到Kindle的<code>extensions</code>目录下</li>
<li>断开Kindle与电脑的链接，通过KUAL打开Kterm，随便Ping台机器试试。</li>
</ol>


<h3>配置Raspberry Pi的USB网络连接</h3>

<p>安装了USBNetwork，Kindle已经可以通过数据线和Mac电脑连网，接下来配置Raspberry Pi的USB网络链接，使Kindle插入Raspberry Pi以后可以自动建立网络连接。</p>

<pre><code>sudo vim /etc/network/interfaces
</code></pre>

<p>添加如下内容</p>

<pre><code>#USB tethering
allow-hotplug usb0
iface usb0 inet static
    address 192.168.15.1
    netmask 255.255.255.0
    broadcast 192.168.15.255
    up iptables -I INPUT 1 -s 192.168.15.1 -j ACCEPT
    up eject /dev/sda1
</code></pre>

<ul>
<li><code>allow-hotplug usb0</code>表示插入USB后自动加载网络配置</li>
<li><code>up eject /dev/sda1</code>表示弹出Kindle自动挂载的磁盘分区</li>
</ul>


<p>重启网络</p>

<pre><code>sudo service networking reload
</code></pre>

<h3>见证奇迹的时刻</h3>

<ol>
<li>使用数据线连接Kindle和Raspberry Pi</li>
<li>开启USBNetwork模式，Kindle的搜索框内，输入<code>;un</code>然后回车</li>
<li><p>打开Kterm键入</p>

<p> ssh pi@192.168.15.1</p></li>
</ol>


<p>若提示输入密码或者保存密钥指纹，说明大功告成。</p>

<p><strong>Kindle作为跳板机</strong></p>

<p>Kindle和Raspberry Pi顺利创建连接之后，Mac OS可以通过Kindle的Wifi连接SSH登录进Kindle，然后再次SSH登录进入Raspberry Pi。</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.ponnuki.net/2012/09/kindleberry-pi/">KindleBerry Pi</a></li>
<li><a href="https://gist.github.com/rvagg/5095506">Kindleberry &#8220;Paperwhite&#8221; Pi</a></li>
<li><a href="http://wiki.mobileread.com/wiki/Kindle_Touch_Hacking#GUI_launcher">Kindle Touch Hacking</a></li>
<li><a href="http://maxogden.com/kindleberry-wireless.html">Kindleberry Wireless: A Portable Outdoor Hackstation</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何找到树莓派通过DHCP获得的IP地址]]></title>
    <link href="http://vangie.github.com/blog/2013/12/17/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp/"/>
    <updated>2013-12-17T03:08:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/17/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp</id>
    <content type="html"><![CDATA[<blockquote><p>小巧的树莓派配一个硕大的显示器，很不协调。本文介绍如何获得树莓派通过DHCP动态分配的IP地址。</p></blockquote>

<h3>几种有趣的方法</h3>

<p>mathworks论坛提到了几种有意思的方法</p>

<ol>
<li><p>通过Matlab命令行</p>

<pre><code> h = raspberrypi(‘raspberrypi-ah')
 h.openShell(‘ssh')
</code></pre></li>
<li>安装一个启动过程中能读出IP的软件，该软件也是MathWork出品的</li>
<li>通过DDNS（Dynamic DNS）</li>
<li>启动时发邮件通知</li>
</ol>


<p>就个人而言，上面的方法觉得都不够好。</p>

<ol>
<li>需要安装Matlab，一个好几G的工具软件就是为了找个IP用，有些蛋疼</li>
<li>要插个耳机或者音响什么的</li>
<li>需要互联网环境</li>
<li>需要互联网环境</li>
</ol>


<p>下面我介绍一个简单实用的方法，通过arp协议获得IP</p>

<!-- more -->


<h3>通过arp-scan获得树莓派IP</h3>

<p>arp协议是一个数据链路层协议，负责IP地址和Mac地址的转换。下面我们介绍一个arp-scan工具扫出局域网所有的IP地址</p>

<h4>安装arp-scan</h4>

<p>Mac OS</p>

<pre><code>brew install arp-scan
</code></pre>

<p>Ubuntu</p>

<pre><code>sudo apt-get arp-scan
</code></pre>

<h4>扫描以太网IP地址</h4>

<pre><code>arp-scan --interface en0 --localnet  
</code></pre>

<p>此处en0是网卡的设备名称，可以通过ifconfig命令获得，有多种网卡时注意不要写错</p>

<p>扫描结果如下</p>

<pre><code>nterface: en0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.8 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
192.168.199.1   d4:ee:07:04:0d:e6   (Unknown)
192.168.199.239 e8:8d:28:06:db:2f   (Unknown)
192.168.199.107 b8:27:eb:96:c4:2f  (Unknown)

513 packets received by filter, 0 packets dropped by kernel
Ending arp-scan 1.8: 256 hosts scanned in 1.242 seconds (206.12 hosts/sec). 2 responded
</code></pre>

<p>由于arp-scan的版本比较低，所以主机名为Unknown,不过没有关系，由于树莓派的Mac地址都是<code>b8:27:3b</code>开头的。所以<code>192.168.199.107</code>就是树莓派的IP地址</p>

<h4>One line Command</h4>

<pre><code>arp-scan --interface en0 --localnet | grep grep b8:27:eb
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://blog.remibergsma.com/2013/05/03/howto-discover-the-ip-address-of-a-raspberry-pi-on-dhcp/">HOWTO discover the ip address of a Raspberry Pi</a></li>
<li><a href="http://www.mathworks.cn/cn/help/simulink/ug/get-the-ip-address-of-the-raspberry_pi-hardware.html">Get IP Address of Raspberry Pi Hardware</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?t=55804">FYI: via Raspi&#8217;s IP address with &#8216;arp-scan&#8217;</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspbian成功驱动TP-Link TL-WN725N V2版无线网卡]]></title>
    <link href="http://vangie.github.com/blog/2013/12/14/tp-link-wn725n-v2-works-on-raspbian/"/>
    <updated>2013-12-14T00:03:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/12/14/tp-link-wn725n-v2-works-on-raspbian</id>
    <content type="html"><![CDATA[<blockquote><p>淘宝双12搞活动，225入了一台英国产2代B型512M RaspBerry Pi，英国产的相对便宜，但是不带外壳，另外加12块，搞了个带固定螺丝的亚克力外壳。话说这个外壳裁剪的相对不错，花了老半天才装好。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-12-14/4-items.jpg" alt="配件合集" /></p>

<p><img src="http://vangie.github.com/images/post/2013-12-14/raspberry.jpg" alt="组装成品" /></p>

<p><img src="http://vangie.github.com/images/post/2013-12-14/pi-with-tl-wn725n.jpg" alt="TP-Link TL-WN725N V2" /></p>

<!-- more -->


<h3>如何选SD卡</h3>

<p>先罗嗦一段SD卡的选取过程。其实想买开树莓的板子很长时间了，但是如何选SD卡一直犹豫不决。主要考虑两个因素：</p>

<ul>
<li>SD卡的兼容性，某些SD卡树莓派无法识别；</li>
<li>SD卡的读写速度，市面上的Class 10卡从20M/s到UHS-I卡95M/s的价格相差很大。</li>
</ul>


<p>一开始很想选 <a href="http://item.jd.com/530220.html">闪迪（SanDisk）至尊超极速SDHC存储卡 8G-Class10-95MB/s</a> 查了<a href="http://elinux.org/RPi_SD_cards">树莓的SD卡兼容列表</a>显示可以识别，但159元的价格让我犹豫了。</p>

<p>研究了一段时间，发现有网友称树莓派对UHS-I类型的SD支持不好，目前树莓的控制器读取SD卡速度也就20-30M/s。后来选了 <a href="http://item.jd.com/679771.html">闪迪（SanDisk）至尊高速MicroSDHC（TF）存储卡 8G-Class10-30MB/s</a>， 39元搞定。</p>

<h3>安装rtl8188eu驱动模块</h3>

<p>现在进入正题，安装这块无线网卡的驱动是个痛苦的精力，虽然树莓派的官方论坛已经有几篇关于驱动TL-WN725N的帖子：</p>

<ul>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=66&amp;t=55779&amp;sid=946c22c3b95fea0e73539828e33018b1">Getting TL-WN725N working</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=28&amp;t=52932">TL-WN725N V2, raspbian driver update</a></li>
<li><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=91&amp;t=29752">TP-Link TL-WN725N V2 works out of the box on Raspbian</a></li>
</ul>


<p>但由于Raspbian的版本在不断的升级，生搬帖子上的步骤不起效果。</p>

<p>因为我的这个 <a href="http://item.jd.com/618066.html">TP-LINK TL-WN725N 微型150M无线USB网卡</a> 是先于树莓派购买闲置的。如果买新的话，强烈建议买免驱的无线网卡，省得折腾。比如说这款 <a href="http://item.jd.com/509932.html">EDUP EP-N8508GS黄金版 迷你USB无线网卡</a>.这里有一份<a href="http://elinux.org/RPi_USB_Wi-Fi_Adapters">树莓派支持的无线网卡清单</a></p>

<p>下的步骤是综合了上面的帖子及其引用，不断试错总结出来的步骤。</p>

<h4>确定网卡的版本</h4>

<p>TP-LINK TL-WN725N分<a href="http://wikidevi.com/wiki/TP-LINK_TL-WN725N_v1">V1</a>, <a href="http://wikidevi.com/wiki/TP-LINK_TL-WN725N_v2">V2</a>版本。 <br/>
<img src="http://vangie.github.com/images/post/2013-12-14/tl-wn725n.jpg" alt="" /></p>

<p>将无线网卡插上树莓的USB接口，执行<code>lsusb</code>返回如下</p>

<blockquote><p>Bus 001 Device 004: ID 0bda:8179 Realtek Semiconductor Corp.</p></blockquote>

<p>因为V1和V2的ID代号分别是0bda:8176、0bda:8179。</p>

<p>本文只针对V2版本，V1版本未经测试。</p>

<h4>升级内核</h4>

<pre><code>sudo rpi-update
</code></pre>

<p>升级后执行<code>uname -a</code>的结果是</p>

<blockquote><p>Linux raspberrypi 3.10.24+ #610 PREEMPT Thu Dec 12 13:12:09 GMT 2013 armv6l GNU/Linux</p></blockquote>

<h4>编辑驱动模块</h4>

<pre><code>git clone --depth 1 git://github.com/raspberrypi/linux.git rpi-linux

git clone --depth 1 git://github.com/raspberrypi/firmware.git rpi-firmware

git clone git://github.com/lwfinger/rtl8188eu.git rtl8188eu

cd rpi-linux

make mrproper

zcat /proc/config.gz &gt; .config

make modules_prepare

cp ../rpi-firmware/extra/Module.symvers .

cd ../rtl8188eu

CONFIG_RTL8188EU=m make -C ../rpi-linux M=`pwd`

sudo cp rtl8188eufw.bin /lib/firmware/rtlwifi

sudo install -p -m 644 8188eu.ko /lib/modules/`uname -r`/kernel/drivers/net/wireless

sudo insmod /lib/modules/`uname -r`/kernel/drivers/net/wireless/8188eu.ko

sudo depmod -a
</code></pre>

<h4>验证网卡是否识别</h4>

<p>若上面的命令执行过程没有报错，执行<code>iwconfig</code>的结果如下</p>

<pre><code>wlan0     IEEE 802.11bgn  ESSID:"22_1707"  Nickname:"&lt;WIFI@REALTEK&gt;"
          Mode:Managed  Frequency:2.457 GHz  Access Point: D4:EE:07:04:0D:E6
          Bit Rate:150 Mb/s   Sensitivity:0/0
          Retry:off   RTS thr:off   Fragment thr:off
          Power Management:off
         Link Quality=0/100  Signal level=15/100  Noise level=0/100
         Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
         Tx excessive retries:0  Invalid misc:0   Missed beacon:0

lo        no wireless extensions.

eth0      no wireless extensions.
</code></pre>

<p>证明无线网卡已被识别，下面我们来配置网络参数。</p>

<h4>配置无线网络参数</h4>

<p>打开/etc/wpa_supplicant/wpa_supplicant.conf文件，添加如下内容</p>

<pre><code>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid="NETWORK_NAME"
    psk="NETWORK_PASSWORD"
}
</code></pre>

<p>上面的方法psk是明文，如果觉得敏感，可以使用下面的命令生成密文</p>

<pre><code>wpa_passphrase ssid pass_phrase
</code></pre>

<p>输出如下</p>

<pre><code>network={
        ssid="myrouter"
        #psk="thisisalongpassphrasenobodycanguess"
        psk=fd50e5fb2b66493702338dd5175241d2e8dd7dd42fc292bbb7c56b01f9e9fdc0
}
</code></pre>

<p>将输出结果添加到/etc/wpa_supplicant/wpa_supplicant.conf文件。</p>

<p>重启网络服务<code>sudo service networking reload</code>后</p>

<p>执行<code>ifconfig</code>，如果wlan0获得IP就可以使用了</p>

<pre><code>wlan0     Link encap:Ethernet  HWaddr 14:cf:92:b5:59:6d
          inet addr:192.168.199.109  Bcast:192.168.199.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8805 errors:0 dropped:15 overruns:0 frame:0
          TX packets:600 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:2542242 (2.4 MiB)  TX bytes:82318 (80.3 KiB)
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://smhaziq.blogspot.co.at/2013/06/compiling-tp-link-wn725n-v2-driver-in.html">Compiling TP-LINK WN725N V2 driver in Raspbmc with 3.6.11 kernel</a></li>
<li><a href="https://github.com/liwei/rpi-rtl8188eu">Linux driver for tplink-wn725n nano wireless adapter</a></li>
<li><a href="http://blog.pi3g.com/2013/10/easy-tp-link-tl-wn725-driver-installation/">Easy TP-Link TL-WN725 driver installation</a></li>
<li><a href="http://www.fars-robotics.net/">Fars Robotics Website</a></li>
<li><a href="http://undiff.com/2008/08/wireless-with-wpa_supplicant-easier-then-you-think/">Wireless with wpasupplicant easier then you think</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google屏蔽Linode的IPv6导致SSH隧道不可用]]></title>
    <link href="http://vangie.github.com/blog/2013/11/16/google-block-linode-traffic-over-ipv6/"/>
    <updated>2013-11-16T01:48:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/16/google-block-linode-traffic-over-ipv6</id>
    <content type="html"><![CDATA[<blockquote><p>最近几个月通过linode的SSH隧道访问Google都会报出类似“We‘re sorry”或者“unusual traffic”的错误，有时需要输入验证码，但大多数时候直接不可用。一段时间使用GoAgent比较多，可惜GoAgent有时不太稳定。</p></blockquote>

<p>Google了一番，才知道是因为Google屏蔽了Linode服务器的IPv6协议导致SSH隧道出问题的。
下面我们就来关闭Ubuntu的IPv6</p>

<h3>关闭Ubuntu的IPv6</h3>

<ul>
<li><p>编辑 <code>/etc/sysctl.conf</code>,添加如下内容</p>

<p>  net.ipv6.conf.all.disable_ipv6=1<br/>
  net.ipv6.conf.default.disable_ipv6=1<br/>
  net.ipv6.conf.lo.disable_ipv6=1</p></li>
</ul>


<p>如上修改虽然是永久性的需要重启网卡才能生效<code>/etc/init.d/networking restart</code></p>

<ul>
<li><p>实时生效</p>

<p>  echo &#8216;1&#8217; > /proc/sys/net/ipv6/conf/lo/disable_ipv6<br/>
  echo &#8216;1&#8217; > /proc/sys/net/ipv6/conf/lo/disable_ipv6<br/>
  echo &#8216;1&#8217; > /proc/sys/net/ipv6/conf/all/disable_ipv6<br/>
  echo &#8216;1&#8217; > /proc/sys/net/ipv6/conf/default/disable_ipv6</p></li>
</ul>


<p>再试试通过SSH隧道搜索Google，是不是已经好了，<sup>_<sup>。</sup></sup></p>

<h3>参考阅读</h3>

<ol>
<li><a href="https://forum.linode.com/viewtopic.php?f=20&amp;t=10436">Intermittent &#8220;We&#8217;re sorry&#8221; error accessing Google via IPv6</a></li>
<li><a href="http://en.kioskea.net/faq/759-ubuntu-disabling-ipv6-support">Ubuntu - Disabling IPv6 support</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS X替换Razer的状态栏图标]]></title>
    <link href="http://vangie.github.com/blog/2013/11/16/replace-razer-status-bar-icon-in-macos/"/>
    <updated>2013-11-16T01:37:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/16/replace-razer-status-bar-icon-in-macos</id>
    <content type="html"><![CDATA[<blockquote><p>心爱的QeathAdder炼狱蝰蛇变形金刚款，用了300多天左键坏了，联系易迅给换了个QeathAdder炼狱蝰蛇2013款。虽然黑色的外观不如变形金刚款银色的配MacBook，但是6400dpi的分辨率，着实给力。CS:GO的甩狙命中率显著提升，开始以为年纪大了水平下降了，换鼠标后，发现还是鼠标的问题。话说Razer鼠标的管理界面支持登录以后保存鼠标配置的功能很好，就是状态栏的蓝色图标和Mac OS统一的暗灰色图标比起来太不协调了。</p></blockquote>

<p>默认效果</p>

<p><img src="http://vangie.github.com/images/post/2013-11-16/replace_before.png" alt="" /></p>

<p>替换后的效果</p>

<p><img src="http://vangie.github.com/images/post/2013-11-16/replace_after.png" alt="" /></p>

<p>替换图标</p>

<p><img src="http://vangie.github.com/images/post/2013-11-16/Status.png" alt="" /></p>

<h3>替换图标</h3>

<ol>
<li>在Finder里找到<code>/Library/Application Support/Razer/RzUpdater.app</code>
Command+Shift+G打开GO to对话框，输入<code>/Library/Application Support/Razer</code></li>
<li>右键RzUpdater.app显示包内容</li>
<li>然后再进入<code>Contents/Resources</code>目录</li>
<li>用上面的图标替换Status.png文件即可。</li>
<li>重启系统或者杀掉RzUpdater进程</li>
</ol>


<h3>参考阅读</h3>

<ol>
<li><a href="http://forums.macrumors.com/showthread.php?t=1432198">Razer DeathAdder Icon in Menubar (Synapse 2.0)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Mac正确的识别Noppoo Chic Mini84]]></title>
    <link href="http://vangie.github.com/blog/2013/11/13/noppoo-chic-mini84-osx-support/"/>
    <updated>2013-11-13T14:44:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/13/noppoo-chic-mini84-osx-support</id>
    <content type="html"><![CDATA[<blockquote><p>半年前入了一把Noppoo的84键茶轴机械键盘，这把键盘的手感真心不错，也非常的小巧，很短，放在桌上也一点都不占位置。唯一的缺点就是不支持Mac系统。官方未提供mac版本的驱动程序，在mac系统下有部分键不好用。网上倒是提供了两种解决方案：一种是usb转ps2，再ps2转usb两次转换以后就好用了（依靠转换器里的芯片）；另一个种是安装Github上的<a href="https://github.com/thefloweringash/iousbhiddriver-descriptor-override">第三方驱动</a>。</p></blockquote>

<p><img src="http://vangie.github.com/images/post/2013-11-13/noppoo-chic-mini84.jpg" alt="Noppoo Chic Mini84" /></p>

<p>两种方法都有试过，两次转换可以免去装驱动的麻烦，但是由于接了两个转换器，有时候会接触不好。最后选用了加装驱动的方案。</p>

<!-- more -->


<h3>加装驱动</h3>

<ul>
<li><p>pkg安装包 https://thefloweringash.com/iousbhiddriver-descriptor-override/downloads/IOUSBHIDDriverDescriptorOverride-2013-04-21-b545d15.pkg</p></li>
<li><p>编译安装</p>

<ol>
<li>下载源码 https://github.com/thefloweringash/iousbhiddriver-descriptor-override/archive/master.zip</li>
<li>编译</li>
</ol>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># dependencies
</span><span class='line'>gem install bundler
</span><span class='line'>bundle install --without scan
</span><span class='line'>
</span><span class='line'># build
</span><span class='line'>xcodebuild
</span><span class='line'>sudo cp -r build/Release/IOUSBHIDDriverDescriptorOverride.kext \
</span><span class='line'>    /System/Library/Extensions
</span><span class='line'>sudo kextutil \
</span><span class='line'>    /System/Library/Extensions/IOUSBHIDDriverDescriptorOverride.kext</span></code></pre></td></tr></table></div></figure>


<pre><code>3. 启动时加载，把com.apple.IOUSBHIDDriverDescriptorOverride.plist复制到/Library/LaunchDaemons/下面
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>launchctl load -w /Library/LaunchDaemons/com.apple.IOUSBHIDDriverDescriptorOverride.plist
</span><span class='line'>launchctl list | grep om.apple.IOUSBHIDDriverDescriptorOverride</span></code></pre></td></tr></table></div></figure>


<h3>安装KeyRemap4MacBook</h3>

<p>下载地址 https://pqrs.org/macosx/keyremap4macbook/</p>

<h3>参考阅读</h3>

<ol>
<li><a href="http://likidu.com/noppoo-chic-mini84-osx-support/">Noppoo Chic Mini 84支持Mac OS X</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个优雅的Mac OS服务管理程序launchctl的包装工具]]></title>
    <link href="http://vangie.github.com/blog/2013/11/09/a-nice-launchctl-wrapper-for-macos-deamon-management/"/>
    <updated>2013-11-09T17:32:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/09/a-nice-launchctl-wrapper-for-macos-deamon-management</id>
    <content type="html"><![CDATA[<blockquote><p>launchctl是mac os平台的服务管理程序，相当于linux平台的service。但是launchctl真心难用，比如不支持重启服务，关闭服务需要指定配置文件plist的全路径。<a href="https://github.com/mperham/lunchy">lunchy</a>是一个launchctl的包装程序，大大简化了agent的管理。</p></blockquote>

<h3>安装</h3>

<p>lunchy是一个ruby程序，可以通过gem直接安装</p>

<pre><code>gem install lunchy
</code></pre>

<h3>命令</h3>

<ul>
<li>ls [pattern]</li>
<li>start [pattern]</li>
<li>stop [pattern]</li>
<li>restart [pattern]</li>
<li>status [pattern]</li>
<li>install [file]</li>
<li>show [pattern]</li>
<li>edit [pattern]</li>
</ul>


<p>lunchy的一个重要功能改进是支持通配，除了安装install agent需要指定完整的文件路径外，其他命令只需要输入特征词即可。</p>

<p>比如启动redis服务</p>

<pre><code>launchctl load ~/Library/LaunchAgents/io.redis.redis-server.plist
</code></pre>

<p>使用lunchy非常简单</p>

<pre><code>lunchy start redis
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://v2ex.com/t/88644">OS X 下使用 lunchy 替换 launchctl 管理 daemon apps</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac OS里配置Apache+PHP+Mysql环境]]></title>
    <link href="http://vangie.github.com/blog/2013/11/08/config-apache-php-mysql-on-mac-os/"/>
    <updated>2013-11-08T21:54:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/11/08/config-apache-php-mysql-on-mac-os</id>
    <content type="html"><![CDATA[<blockquote><p>Apache+PHP+Mysql是PHP开发的标配，Windows系统可以安装<a href="www.easyphp.org">EasyPHP</a>集成包。Mac系统也有相应的集成包<a href="http://www.mamp.info/en/index.html">MAMP</a>。但是考虑到Mac OS已经自带了Apache和PHP环境，重复安装Apache和PHP有些冗余，所有本文介绍如何使用homebrew安装Mysql并且集成原有的Apache和PHP环境。</p></blockquote>

<h3>启动Apache</h3>

<p>打开Terminal，然后运行</p>

<pre><code>sudo apachectl start
</code></pre>

<p>查看Mac OS X的Apache版本</p>

<pre><code>sudo apachectl -v
</code></pre>

<p>Mac OS X 10.9的返回结果是</p>

<blockquote><p>Server version: Apache/2.2.24 (Unix) <br/>
Server built:   Aug 24 2013 21:10:43</p></blockquote>

<p>如此在浏览器中输入<code>http://localhost</code>，就可以看到一个内容为“It works!”的页面，其位于<code>/Library（资源库）/WebServer/Documents/</code>下，这就是Apache的默认根目录。</p>

<p>另外，用户可以通过<code>http://[本地IP]/~[用户名]</code>来访问<code>/Users/[用户名]/Sites/</code>目录</p>

<h3>开启PHP支持</h3>

<ol>
<li>在终端中运行<code>sudo vi /etc/apache2/httpd.conf</code>，打开Apache的配置文件。</li>
<li>找到<code>#LoadModule php5_module libexec/apache2/libphp5.so</code>，把前面的#号去掉，保存（在命令行输入:w）并退出vi（在命令行输入:q）。</li>
<li><p>运行<code>sudo cp /etc/php.ini.default /etc/php.ini</code>，这样就可以运行<code>sudo vi /etc/php.ini</code>来编辑php.ini配置各种功能了。比如：</p>

<p> ;通过下面两项来调整PHP提交文件的最大值，如phpMyAdmin中导入数据的最大值
 upload_max_filesize = 2M
 post_max_size = 8M
 ;通过display_errors来控制是否显示PHP程序的报错信息，这在调试PHP程序时非常有用
 display_errors = Off</p></li>
<li>运行“sudo apachectl restart”，重启Apache，这样PHP就可以用了。</li>
</ol>


<h3>安装Xdebug</h3>

<ol>
<li>在终端执行<code>php -i | pbcopy</code>，php的输出信息会被拷贝的剪切板。</li>
<li>打开<a href="http://xdebug.org/wizard.php">xdebug安装在线向导</a>,在文本框内Command+V，将剪切板内的内容拷贝到文本框，然后点击“Analyse my phpinfo() output”按钮。</li>
<li>根据生成的步骤安装即可。</li>
</ol>


<h3>安装Mysql</h3>

<p>这一步最简单了，前提是已安装了<a href="http://brew.sh">HomeBrew</a>。
在命令行执行</p>

<pre><code>brew install mysql
</code></pre>

<p>安装完成以后,启动mysql服务</p>

<pre><code>mysql.server start
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://dancewithnet.com/2010/05/09/run-apache-php-mysql-in-mac-os-x/">在Mac OS X中配置Apache ＋ PHP ＋ MySQL</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[致青春]]></title>
    <link href="http://vangie.github.com/blog/2013/09/19/for-youth/"/>
    <updated>2013-09-19T03:04:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/19/for-youth</id>
    <content type="html"><![CDATA[<blockquote><p>送给那些而立之年的伙伴们</p></blockquote>

<p>年华易逝，岁月如歌，<br/>
而立之年，青春渐远。</p>

<p>《那些年，我們一起追的女孩 》和《致青春》触动了我们，80后开始集体怀旧。</p>

<p>那些野蛮生长日子里，<br/>
有过期许，<br/>
有过慌张，<br/>
也曾意气风发，<br/>
也曾年少轻狂。</p>

<p>其实每一代人都有怀旧情结，人们之所以怀念过去，往往不是因为追忆的年代比当下更美好，而是那时正值青春。</p>

<p>青春是美好的，<br/>
青春是奔放的，<br/>
青春是热烈的，<br/>
青春是短暂的，<br/>
如花如雨，<br/>
如烟如梦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决国内rubygems速度慢的问题]]></title>
    <link href="http://vangie.github.com/blog/2013/09/18/installing-rubygems-faster/"/>
    <updated>2013-09-18T14:50:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/18/installing-rubygems-faster</id>
    <content type="html"><![CDATA[<blockquote><p>国内访问rubygems那个慢呀，尤其是走https协议。</p></blockquote>

<h3>借用bash的http代理</h3>

<p>一般来说通过翻墙代理访问的速度要更快一点。ruby遵守unix环境变量约定，支持http_proxy和https_proxy。</p>

<p>在执行<code>bundle install</code>之前先执行</p>

<pre><code>$ export http_proxy=http://127.0.0.1:xxxxx/
$ export https_proxy=http://127.0.0.1:xxxxx/
</code></pre>

<p>当然前提是，系统有一个本地可用的http或者https代理。关于bash里使用http代理的细节参见<a href="http://codelife.me/blog/2012/09/02/how-to-set-proxy-for-terminal/">《如何为MacOS X终端设置代理》</a></p>

<h3>改用国内的镜像</h3>

<pre><code>$ gem sources –r http://rubygems.org/
$ gem sources -a http://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***

http://ruby.taobao.org

# 请确保只有 ruby.taobao.org
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://ruby-china.org/topics/288">国内访问rubygems.org好慢啊，大家有没有提速的方法？</a></li>
<li><a href="http://tec.liux.in/28">解决rubygems速度慢的Tips</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash如何创建随机文件名]]></title>
    <link href="http://vangie.github.com/blog/2013/09/16/how-to-create-temporary-random-file-name-in-bash/"/>
    <updated>2013-09-16T23:50:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/16/how-to-create-temporary-random-file-name-in-bash</id>
    <content type="html"><![CDATA[<blockquote><p>本文介绍3种不同的方法创建随机缓存文件名。在编写需要创建唯一的缓存文件的脚本时非常有用。</p></blockquote>

<h3>1.使用$RANDOM shell变量</h3>

<p>在控制台执行如下命令</p>

<pre><code>echo $RANDOM
</code></pre>

<p>每次都获得一个随机数，借用这个变量可用来生成一个随机的文件名</p>

<pre><code>#!/bin/bash
echo "List of temporary files : "
for i  in 1 2 3 4 5
do
    FILE="/tmp/$(basename $0).$RANDOM.txt"
    echo $FILE # show file name
    &gt; $FILE # create files
done 
</code></pre>

<h3>2.使用$$变量</h3>

<p>这是一个经典的方法，$$变量返回当前进程的进程号，对于整个系统来说这是一个唯一数字。</p>

<pre><code>#!/bin/bash
TFILE="/tmp/$(basename $0).$$.tmp"
ls &gt; $TFILE
echo "See diretory listing in $TFILE"
</code></pre>

<h3>3.使用mktemp和tempfile命令</h3>

<p>通过mktemp和tempfile命令是最佳的方式</p>

<pre><code>$ mktemp
</code></pre>

<p>输出</p>

<pre><code>/tmp/tmp.IAnO5O
</code></pre>

<p>或者</p>

<pre><code>$ tempfile
</code></pre>

<p>输出</p>

<pre><code>/tmp/IAnO5O
</code></pre>

<p>当然还能生成随机文件夹</p>

<pre><code>$ mktemp -d
$ tempfile -d
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://www.cyberciti.biz/tips/shell-scripting-bash-how-to-create-temporary-random-file-name.html">Shell scripting (BASH) : How to create temporary random file name</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx反向代理映射成子路径]]></title>
    <link href="http://vangie.github.com/blog/2013/09/12/reverse-proxy-for-a-subdirectory-in-nginx/"/>
    <updated>2013-09-12T17:41:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/12/reverse-proxy-for-a-subdirectory-in-nginx</id>
    <content type="html"><![CDATA[<blockquote><p>终于搞定了困扰已久的nginx反向代理子路径映射问题</p></blockquote>

<p>多个web应用共享一个域名和端口时，可以考虑把不同的web应用映射成不同的子路径，这个子路径在Java EE里称作ContextPath。下面的配置片段解决nginx作为前端，反向代理多个tomcat主机，通过不同子路径共享一个域名的情况。</p>

<pre><code>server {
    listen       80;
    server_name  _;
    index index.html index.htm index.php;
    root /home/dashboard;

    location /dashboard {
        rewrite /dashboard/(.*) /$1 break;
        rewrite ^/dashboard$ /dashboard/ permanent;
        proxy_pass http://127.0.0.1:9082;
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
</code></pre>

<h3>参考阅读</h3>

<ol>
<li><a href="http://wiki.apache.org/couchdb/Nginx_As_a_Reverse_Proxy">Nginx_As_a_Reverse_Proxy</a></li>
<li><a href="http://superuser.com/questions/603373/how-do-i-reverse-proxy-etherpad-lite-with-nginx-to-a-subdirectory">How do I reverse proxy etherpad-lite with nginx to a subdirectory</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩展Backbone.Router以支持window.history.back]]></title>
    <link href="http://vangie.github.com/blog/2013/09/02/extend-Backbone.Router-to-support-window.history.back/"/>
    <updated>2013-09-02T21:37:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/09/02/extend-Backbone.Router-to-support-window.history.back</id>
    <content type="html"><![CDATA[<blockquote><p>web应用程序重要的功能的URL通过需要达到可访问，可收藏和可分享的需求。Backbone.Router正是检测客户端url变化触发相应动作和事件的实现框架。对于没有实现HTML5 History API的浏览器，Router提供了优雅和透明的兼容实现，通过控制hash的变化。</p></blockquote>

<h3>Route的例子</h3>

<pre><code>var Workspace = Backbone.Router.extend({

    routes: {
        "help":                 "help",    // #help
        "search/:query":        "search",  // #search/kiwis
        "search/:query/p:page": "search"   // #search/kiwis/p7
    },

    help: function() {
        ...
    },

    search: function(query, page) {
        ...
    }

});
</code></pre>

<!-- more -->


<h3>Router的问题</h3>

<p>Router很好的解决了进入一个url能触发相应的方法的问题，但是如果在离开某个url想触发相应的方法，Router显得无能为力。通常如果想通过window.history.back()退回上一页面是，触发相应的方法，就需要Router支持leave方法。</p>

<p>下面我们介绍如何通过扩展Backbone.Router已支持leave。</p>

<h3>扩展Backbone.Router</h3>

<pre><code>class BaseRouter extends Backbone.Router
  route: (route, name, callback)-&gt;

    fn = callback

    route = this._routeToRegExp(route) unless _.isRegExp route

    if _.isFunction name
      callback = name
      name = ''

    fn = callback = this[name] unless callback

    if typeof callback == 'object'
      before = callback.before
      fn = callback.route
      after = callback.after

    Backbone.history.route(route, (fragment)=&gt;
      args = @_extractParameters(route, fragment)

      if leave
        if leave() is false
          return
        else
          leave = false

      return if before and before.apply(@, args) is false
      fn.apply(@, args) if fn
      return if after and after.apply(@, args) is false

      if typeof callback == 'object'
        leave = ((_this, args)-&gt;-&gt;callback.leave.apply(_this, args))(@, args)

      @trigger.apply(@, ["route:#{name}"].concat(args))
      @trigger('route', name, args)
      Backbone.history.trigger('route', @, name, args)
    )
    @
</code></pre>

<h3>编写Router</h3>

<pre><code>class extends Base.Router
  routes:
    "bsdn_editor_:uid/writer":    "fullscreen"
    #catch every url for leave
    "*splat": -&gt;

  fullscreen: {
    route: (uid)-&gt;
      $("#bsdn_editor_#{uid}").parent().editor('showFullscreen')
    leave: (uid)-&gt;
      $("#bsdn_editor_#{uid}").parent().editor('hideFullscreen')
  }
</code></pre>

<h3>参考阅读</h3>

<p>[1] <a href="https://gist.github.com/corpix/1972890">Backbone router before,after,leave</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在backbonejs里使用coffeescript实现mixin]]></title>
    <link href="http://vangie.github.com/blog/2013/07/26/using-mixins-in-backbonejs-by-coffeescript/"/>
    <updated>2013-07-26T09:08:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/07/26/using-mixins-in-backbonejs-by-coffeescript</id>
    <content type="html"><![CDATA[<blockquote><p>Mixin和Inheritance是两种主要的代码复用和封装的方式。Java流行的时候，大家都努力的把javascript写得像java，各大框架努力给javascript加上类继承的特性。当下是Ruby春暖花开的日子，coffeescript让开发者可以以更ruby的方式写js。javascript在不同的时期能适应潮流，足以见得原型链继承型语言的强大之处。</p></blockquote>

<h3>用coffeescript实现Mixin</h3>

<p>Coffescript原生并不支持Mixin，《CoffeeScript小书》第三章提到一种Mixin的实现方式</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">moduleKeywords = </span><span class="p">[</span><span class="s">&#39;extended&#39;</span><span class="p">,</span> <span class="s">&#39;included&#39;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nx">Module</span>
</span><span class='line'>  <span class="vi">@extend: </span><span class="nf">(obj) -&gt;</span>
</span><span class='line'>    <span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">obj</span> <span class="k">when</span> <span class="nx">key</span> <span class="o">not</span> <span class="k">in</span> <span class="nx">moduleKeywords</span>
</span><span class='line'>      <span class="nx">@</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">obj</span><span class="p">.</span><span class="nx">extended</span><span class="o">?</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">@</span><span class="p">)</span>
</span><span class='line'>    <span class="k">this</span>
</span><span class='line'>
</span><span class='line'>  <span class="vi">@include: </span><span class="nf">(obj) -&gt;</span>
</span><span class='line'>    <span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">obj</span> <span class="k">when</span> <span class="nx">key</span> <span class="o">not</span> <span class="k">in</span> <span class="nx">moduleKeywords</span>
</span><span class='line'>      <span class="c1"># Assign properties to the prototype</span>
</span><span class='line'>      <span class="nx">@</span><span class="o">::</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">obj</span><span class="p">.</span><span class="nx">included</span><span class="o">?</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">@</span><span class="p">)</span>
</span><span class='line'>    <span class="k">this</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>上面代码定义了一个Module类型，其包含@extend和@incude两个成员方法，@include方法继承的属性可被实例访问，@extend方法继承的属性可被类访问。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">classProperties = </span>
</span><span class='line'>  <span class="nv">find: </span><span class="nf">(id) -&gt;</span>
</span><span class='line'>  <span class="nv">create: </span><span class="nf">(attrs) -&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">instanceProperties =</span>
</span><span class='line'>  <span class="nv">save: </span><span class="o">-&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nx">User</span> <span class="k">extends</span> <span class="nx">Module</span>
</span><span class='line'>  <span class="nx">@extend</span> <span class="nx">classProperties</span>
</span><span class='line'>  <span class="nx">@include</span> <span class="nx">instanceProperties</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Usage:</span>
</span><span class='line'><span class="nv">user = </span><span class="nx">User</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nv">user = </span><span class="k">new</span> <span class="nx">User</span>
</span><span class='line'><span class="nx">user</span><span class="p">.</span><span class="nx">save</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3>胖箭头<code>=&gt;</code>和Mixin</h3>

<p>coffeescript里用<code>-&gt;</code>符号声明一个function，用<code>=&gt;</code>符号声明一个绑定上下文this的function。 <br/>
下面是一个使用胖箭头声明的function的例子</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">Mixin =</span>
</span><span class='line'>  <span class="nv">fun1 : </span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="o">=&gt;</span>
</span><span class='line'>    <span class="vi">@customer = </span><span class="nx">customer</span>
</span><span class='line'>    <span class="vi">@cart = </span><span class="nx">cart</span>
</span><span class='line'>
</span><span class='line'>  <span class="nv">fun2 : </span><span class="nf">(customer, cart) -&gt;</span>
</span><span class='line'>    <span class="vi">@customer = </span><span class="nx">customer</span>
</span><span class='line'>    <span class="vi">@cart = </span><span class="nx">cart</span>
</span></code></pre></td></tr></table></div></figure>


<p>翻译成javascript如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Mixin</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Mixin</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">fun1</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">_this</span><span class="p">.</span><span class="nx">customer</span> <span class="o">=</span> <span class="nx">customer</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">cart</span> <span class="o">=</span> <span class="nx">cart</span><span class="p">;</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="nx">fun2</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">customer</span> <span class="o">=</span> <span class="nx">customer</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cart</span> <span class="o">=</span> <span class="nx">cart</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面例子中，将Mixin声明为普通对象，由于<em>this并指向当前Mixin所在的上下文this，当<code>=&gt;</code>声明的方法fun1被include到其他类中，</em>this并不会指向新的对象，有悖于通常的面向对象语言中this的语义。 <br/>
<code>-&gt;</code>声明的方法虽然this没有被静态绑定，但是由于js中this指向执行时的上下文，所以在方法被外部调用时，不能执行声明方法的类对象。</p>

<p>再来看看把Mixin声明成class的情况</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">Mixin</span>
</span><span class='line'>  <span class="nv">fun1 : </span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="o">=&gt;</span>
</span><span class='line'>    <span class="vi">@customer = </span><span class="nx">customer</span>
</span><span class='line'>    <span class="vi">@cart = </span><span class="nx">cart</span>
</span><span class='line'>
</span><span class='line'>  <span class="nv">fun2 : </span><span class="nf">(customer, cart) -&gt;</span>
</span><span class='line'>    <span class="vi">@customer = </span><span class="nx">customer</span>
</span><span class='line'>    <span class="vi">@cart = </span><span class="nx">cart</span>
</span></code></pre></td></tr></table></div></figure>


<p>翻译成javascript如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Mixin</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">__bind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">me</span><span class="p">){</span> <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">me</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span> <span class="p">};</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Mixin</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">Mixin</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">fun1</span> <span class="o">=</span> <span class="nx">__bind</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">fun1</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">Mixin</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">fun1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">customer</span> <span class="o">=</span> <span class="nx">customer</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cart</span> <span class="o">=</span> <span class="nx">cart</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">Mixin</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">fun2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">customer</span><span class="p">,</span> <span class="nx">cart</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">customer</span> <span class="o">=</span> <span class="nx">customer</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cart</span> <span class="o">=</span> <span class="nx">cart</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">Mixin</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">})();</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果将Mixin声明为一个class，翻译成js以后，Mixin里声明的方法都被注册到Mixin.prototype上了。而且this的绑定被写在了Mixin的构造方法里，通过一个__bind包装函数进行晚绑定。如果不调用Mixin的构造方法，我们可以绑定派生类的this到方法上。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">Mixin</span>
</span><span class='line'>  <span class="nv">b: </span><span class="o">=&gt;</span> <span class="vi">@something = </span><span class="mi">2</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nx">Foo</span> <span class="k">extends</span> <span class="nx">Module</span>
</span><span class='line'>  <span class="nx">@include</span> <span class="nv">Mixin::</span>
</span><span class='line'>  <span class="nv">constructor: </span><span class="o">-&gt;</span>
</span><span class='line'>    <span class="k">for</span> <span class="nx">fname</span> <span class="k">in</span> <span class="nx">_</span><span class="p">.</span><span class="nx">functions</span> <span class="nx">Mixin</span>
</span><span class='line'>      <span class="nx">@</span><span class="p">[</span><span class="nx">fname</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">bind</span> <span class="nx">@</span><span class="p">[</span><span class="nx">fname</span><span class="p">],</span> <span class="nx">@</span>
</span><span class='line'>    <span class="k">super</span>
</span></code></pre></td></tr></table></div></figure>


<p>有两点需要注意 <br/>
1. @include Minxin.prototype
2. 构造方法中将从Mixin里继承的方法都重新绑定this</p>

<p>如果使用underscore的_.bindAll方法，绑定this可以简化成</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">bindAll</span> <span class="nx">@</span><span class="p">,</span> <span class="nx">_funcitons</span><span class="p">(</span><span class="nx">Mixin</span><span class="p">)...</span>
</span></code></pre></td></tr></table></div></figure>


<h3>结合backbonejs使用Mixin</h3>

<p>使用上面的方法，在coffeescript里使用mixin，已经完美的解决了<code>=&gt;</code>this绑定的问题。</p>

<p>先解决Backbone对象不支持include的问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">include</span> <span class="o">=</span>
</span><span class='line'>  <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">include</span> <span class="o">=</span>
</span><span class='line'>  <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span><span class="p">.</span><span class="nx">include</span> <span class="o">=</span>
</span><span class='line'>  <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Router</span><span class="p">.</span><span class="nx">include</span> <span class="o">=</span>
</span><span class='line'>  <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">_ref</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">value</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">!==</span> <span class="s1">&#39;included&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="nx">_ref</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">included</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">_ref</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="p">}).</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>声明一个Mixin类</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">Mixin</span>
</span><span class='line'>  <span class="nv">b: </span><span class="o">=&gt;</span> <span class="vi">@something = </span><span class="mi">2</span>  
</span></code></pre></td></tr></table></div></figure>


<p>include该Mixin类</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">FooView</span> <span class="k">extends</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">View</span>
</span><span class='line'>  <span class="nx">@include</span> <span class="nx">Mixin</span>
</span><span class='line'>  <span class="nv">constructor: </span><span class="o">-&gt;</span>
</span><span class='line'>    <span class="nv">b: </span><span class="o">=&gt;</span> <span class="vi">@something = </span><span class="mi">2</span>
</span><span class='line'>    <span class="k">super</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考阅读</h3>

<ol>
<li><a href="https://gist.github.com/olivoil/1642328">Mixins/Modules behavior in coffeescript</a></li>
<li><a href="http://stackoverflow.com/questions/12839183/using-mixins-in-coffeescript">Using mixins in Coffeescript</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Eclipse最近使用的标签页显示在标签栏]]></title>
    <link href="http://vangie.github.com/blog/2013/07/01/making-eclipse-most-recently-used-tab-visible/"/>
    <updated>2013-07-01T14:00:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/07/01/making-eclipse-most-recently-used-tab-visible</id>
    <content type="html"><![CDATA[<blockquote><p>当打开文件数量很多时，Eclipse编辑器的标签栏右边会出现一个菜单，把标签栏显示不下的标签页放到一个下拉菜单里，这是一个不错的设计，解决了标签页过多以后标签栏显示不下的问题。（Chrome 的标签页显示采用了另外一种方式，缩写标签页的宽度，以容纳更多的标签页，这种方式对于eclipse不可取，因为网页标签可以借助favicon来区分，而文件标签依赖文件名区分，文件名往往比图标长得多。） Indigo之前版本的eclipse显示标签页采用MRU（Most recently Used）算法来决定标签页的顺序，效果是最近使用过的标签页相对排在前面，显示在标签栏上，很久没有使用过的标签页显示在菜单里。从Eclipse Juno开始标签页的排序算法变了，找到最近打开的标签页变得不方便。</p></blockquote>

<p>Eclipse Juno的界面样式引入了CSS样式表，SWT的界面元素也可以像网页元素一样，方便的通过CSS进行调整。SWT在CSS规范的基础上进行了一下扩展，引入了一些“swt-”为前缀的属性，用于精细化调整界面里控件元素的显示样式。</p>

<p>其中，<code>swt-mru-visible</code>就是一个可以开启MRU算法排序的样式。</p>

<!-- more -->


<h3>安装Eclipse主题CSS编辑器插件</h3>

<p>打开E4安装站点并且安装E4 CSS Editor(Incubation)插件。</p>

<p>E4 update Site: http://download.eclipse.org/e4/updates/0.12</p>

<p><img src="http://vangie.github.com/images/post/2013-07-01/install-plugin.png" alt="安装E4 CSS Editor(Incubation)插件" /></p>

<h3>修改主题</h3>

<p>安装完插件重启后，打开首选项->General->Appearence选项页，Appearence选项页里有一个嵌入的CSS编辑器，就是刚才安装的CSS编辑器的效果。</p>

<p><img src="http://vangie.github.com/images/post/2013-07-01/edit-css.png" alt="编辑CSS" /></p>

<p>保存即可。</p>

<h3>参考阅读</h3>

<p>[1]. <a href="http://stackoverflow.com/questions/12578197/eclipse-juno-tabs-repositionning">Eclipse Juno tabs repositionning</a> <br/>
[2]. <a href="http://wiki.eclipse.org/Eclipse4/CSS">Eclipse4/CSS</a> <br/>
[3]. <a href="http://stackoverflow.com/questions/11255389/retain-previous-open-file-tab-under-visible-tabs">Retain previous open file tab under visible tabs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 6.4升级Git]]></title>
    <link href="http://vangie.github.com/blog/2013/06/25/upgrade-git-on-centos-6-4/"/>
    <updated>2013-06-25T23:42:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/06/25/upgrade-git-on-centos-6-4</id>
    <content type="html"><![CDATA[<blockquote><p>GitHub和许多Git服务依赖的Git版本不低于1.7.10，而CentOS 6.4通过epel安装的git版本为1.7.1。rpmforge源里的二进制包比epel更新，本文介绍如果通过epel源升级git到1.7.11版本。</p></blockquote>

<h3>安装rpmforge源</h3>

<pre><code># rpm -i http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm
</code></pre>

<p>安装证书</p>

<pre><code># rpm --import http://apt.sw.be/RPM-GPG-KEY.dag.txt
</code></pre>

<p>更新rpmforge-extra源</p>

<pre><code># yum --enablerepo=rpmforge-extras update
</code></pre>

<!-- more -->


<h3>安装Git</h3>

<p>插槽可用的git模块</p>

<pre><code># yum --enablerepo=rpmforge-extras provides git
</code></pre>

<p>安装git-1.7.11</p>

<pre><code># yum --enablerepo=rpmforge-extras install git-1.7.11.3-1.el6.rfx.x86_64 
</code></pre>

<p>原来的1.7.1版本的git会被覆盖</p>

<pre><code># git --version
</code></pre>

<h3>参看资料</h3>

<p>[1]. <a href="http://www.charlestonsw.com/update-git-on-centos-6-3/">Update Git On CentOS 6.3</a> <br/>
[2]. <a href="http://www.tecmint.com/install-and-enable-rpmforge-repository-in-rhel-centos-6-5-4/">Install and Enable RPMForge Repository in RHEL/CentOS 6, 5, 4</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 6下配置PPTP VPN客户端]]></title>
    <link href="http://vangie.github.com/blog/2013/06/25/setup-pptp-vpn-client-in-centos-6/"/>
    <updated>2013-06-25T21:34:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/06/25/setup-pptp-vpn-client-in-centos-6</id>
    <content type="html"><![CDATA[<blockquote><p>国内网络环境下载rubygems那叫一个痛苦，最近把https改成http也不好用了。百般无耐，考虑在服务器环境下装个PPTP Client连接国外的PPTPD服务。</p></blockquote>

<h3>安装pptp和pptp-setup</h3>

<p>pptp就不用解释了，pptp-setup是一个设置脚本，通过该脚本可以使用方便地进行初始化设置，生成配置文件。</p>

<pre><code># yum install pptp pptp-setup
</code></pre>

<h3>创建配置</h3>

<pre><code># pptpsetup --create codelife --server vpn.codelife.me \
--username codelife --password me --encrypt
</code></pre>

<!-- more -->


<p>若报如下错误</p>

<pre><code>FATAL: Module ppp_mppe not found.
/usr/sbin/pptpsetup: couldn't find MPPE support in kernel.
</code></pre>

<p>则需要执行</p>

<pre><code># modprobe ppp_mppe
</code></pre>

<p>向内核注册ppp_mppe模块</p>

<h3>连接VPN</h3>

<pre><code># pppd call codelife
</code></pre>

<h4>验证连接情况</h4>

<p>然后通过如下命令验证连接情况</p>

<pre><code># ip a |grep ppp
</code></pre>

<h4>排错</h4>

<p>如果上面命令没有任何返回，则说明连接失败了，可以参看<strong>/var/log/message</strong>文件了解错误的原因</p>

<pre><code># tail -f /var/log/message | grep ppp
</code></pre>

<h5>服务端不支持MPPE</h5>

<p>若错误为</p>

<pre><code>MPPE required but peer negotiation failed
</code></pre>

<p>说明服务端不支持MPPE加密，pptpsetup时不需要使用&#8211;encrypt选项。可以手工修改<strong>/etc/ppp/peers/codelife</strong>文件</p>

<pre><code># vim /etc/ppp/peers/codelife
</code></pre>

<p>去除或者注释掉require-mppe-128</p>

<h5>客户端不支持MPPE</h5>

<p>若错误为</p>

<pre><code>LCP terminated by peer (MPPE required but peer refused)
</code></pre>

<p>说明服务端要求MPPE加密，但是客户端不支持，pptpsetup时漏掉了&#8211;encrypt选项。解决方法正好相反，往<strong>/etc/ppp/peers/codelife</strong>文件添加一行require-mppe-128</p>

<h3>配置路由表</h3>

<p>连接成功后，通过route命令可参看路由表信息</p>

<pre><code># route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.0.1     0.0.0.0         255.255.255.255 UH    0      0        0 ppp0
192.168.228.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0
0.0.0.0         192.168.228.153 0.0.0.0         UG    0      0        0 eth0
</code></pre>

<p>可见，只添加了一条访问192.168.0.1 IP的路由信息。</p>

<h4>访问特定网段</h4>

<p>假设你想让登陆VPN服务器的客户端互相访问，那么，你需要在客户端上加入192.168.0.0网段，即：</p>

<pre><code># route add -net 192.168.0.0 netmask 255.255.255.0 dev ppp0
# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.0.1     *               255.255.255.255 UH    0      0        0 ppp0
192.168.228.0   *               255.255.255.0   U     0      0        0 eth0
192.168.0.0     *               255.255.255.0   U     0      0        0 ppp0
default         192.168.228.153 0.0.0.0         UG    0      0        0 eth0
</code></pre>

<p>然后使用ping命令测试</p>

<pre><code># ping 192.168.0.201 -c 3
PING 192.168.0.201 (192.168.0.201) 56(84) bytes of data.
64 bytes from 192.168.0.201: icmp_seq=1 ttl=127 time=90.1 ms
64 bytes from 192.168.0.201: icmp_seq=2 ttl=127 time=57.2 ms
64 bytes from 192.168.0.201: icmp_seq=3 ttl=127 time=61.9 ms

--- 192.168.0.201 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1999ms
rtt min/avg/max/mdev = 57.299/69.794/90.144/14.515 ms
</code></pre>

<p>这里，192.168.0.201是另一台客户端，同样，若希望访问网段也需要加入类似的路由信息。</p>

<h4>全部流量都通过VPN</h4>

<p>如果您想连接VPN后，全部流量都通过VPN出去（翻墙），就像Windows 那样。那么按上面的步骤可能会遇到一些问题。因为，Linux的默认网关只能是一个，所以，这需要分两种情况。</p>

<h5>a）没有默认网关</h5>

<p>这时，你只需设置一个默认路由即可，例如：</p>

<pre><code># route add -net 0.0.0.0 dev ppp0
</code></pre>

<h5>b）已有默认网关</h5>

<p>但更多情况下，默认网关都是存在的。例如，在这里的局域网内部已经设置了默认网关为192.168.228.153，例如：</p>

<pre><code># tracert www.163.com
traceroute to www.163.com (183.60.136.70), 30 hops max, 40 byte packets
1  192.168.228.153 (192.168.228.153)  0.634 ms  0.879 ms  0.879 ms
2  1.64.63.58.broad.gz.gd.dynamic.163data.com.cn (58.63.64.1)  16.410 ms  16.660 ms  17.150 ms
</code></pre>

<p>若像上面那样添加一条路由是不行的，需要先让访问VPN服务端的流量可通过，然后才能转发其他的数据包。</p>

<pre><code># ip route replace 124.248.205.115 via 192.168.228.153 dev eth0 src 192.168.228.135
# ip route replace default dev ppp0
</code></pre>

<p>更新后的路由表：</p>

<pre><code># route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.0.1     0.0.0.0         255.255.255.255 UH    0      0        0 ppp0
124.248.205.115 192.168.228.153 255.255.255.255 UGH   0      0        0 eth0
192.168.228.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0
0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 ppp0
</code></pre>

<p>访问路径：</p>

<pre><code># tracert www.163.com
traceroute to www.163.com (183.60.136.70), 30 hops max, 40 byte packets
1  192.168.0.1 (192.168.0.1)  33.461 ms  33.665 ms  33.872 ms
2  switch1.hongkong.exchange.gigelayer.com (124.248.205.188)  35.284 ms  35.558 ms  35.799 ms
3  in.core-rt-003.gi.gi0.3.sunnyvision.com (123.242.225.1)  36.502 ms  36.747 ms  40.479 ms
</code></pre>

<p>当然，关闭连接时，也是需要恢复默认网关的：</p>

<pre><code># ip route del 124.248.205.115 via 192.168.228.153 dev eth0 src 192.168.228.135
# ip route add default via 192.168.228.153
</code></pre>

<h3>关闭连接</h3>

<p><strong>注意：启动连接很简单，但停止不能使用ifconfig pp0 down，否则只是禁用了ppp0网卡，后台连接还是存在的。</strong>当然，可以杀进程(<code>killall pppd</code>)来断开连接。不过，ppp工具包提供了更好用的脚本。但需要您进行一些额外的工作：</p>

<pre><code># cp /usr/share/doc/ppp-2.4.5/scripts/pon /usr/sbin/
# cp /usr/share/doc/ppp-2.4.5/scripts/poff /usr/sbin/
# chmod +x /usr/sbin/pon
# chmod +x /usr/sbin/poff
</code></pre>

<p>然后使用下面的命令启动和关闭连接即可：</p>

<pre><code># pon vpn
# poff vpn
</code></pre>

<h3>参考资料</h3>

<p>[1]. <a href="http://blog.secaserver.com/2012/12/centos-6-install-vpn-pptp-client-simple/">CentOS 6: Install VPN PPTP Client – The Simple Way</a> <br/>
[2]. <a href="http://bbs.chinaunix.net/thread-1597299-1-3.html">CentOS 5.3 配置pptp客户端(非图形界面)</a> <br/>
[3]. <a href="http://www.linuxfly.org/post/641/">Linux 下部署PPTP VPN &#8211; 客户端</a> <br/>
[4]. <a href="http://www.linuxfly.org/post/641/">PPTP Client Diagnosis</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kindle Paperwhite越狱和安装KOReader]]></title>
    <link href="http://vangie.github.com/blog/2013/06/20/jailbreak-kindle-paperwhite-and-install-koreader/"/>
    <updated>2013-06-20T00:42:00+08:00</updated>
    <id>http://vangie.github.com/blog/2013/06/20/jailbreak-kindle-paperwhite-and-install-koreader</id>
    <content type="html"><![CDATA[<blockquote><p>亚马逊中国的kindle paperwhite开卖了，与之前坊间谣传的500块的价格相比，849元真的很不给力。正好碰上有个朋友去日本，托人捎了台过来，￥7980，是日元，折合人民币550左右。kindle paperwhite的屏幕已经比较细腻了，翻页时屏幕依然闪烁，电子墨水的通病。但是这个版本的kindle已经内置了光源，一个非常人性化的功能，这么多年以后才加有，不知道亚马逊怎么想的。亚马逊的用户体验那个差呀，不知道是不是老外的思维和我们不一样，反正个人觉得京东和淘宝的页面看上去要顺眼得多。</p></blockquote>

<p>Kindle支持阅读PDF文档，只是效果不怎么好，特别显示扫描版本时。Kindle PaperWhite可以安装第三方的KOReader阅读器改进PDF文档的阅读体验，KOReader支持多种电子书格式，包括DJVU，FB2，EPUB，TXT，CBZ，HTML。在PDF显示方面KOreader得益于开源项目<a href="http://www.willus.com/k2pdfopt/">K2pdfopt</a>。</p>

<p>K2pdfopt也是为了解决PDF文档在小屏幕Kindle上阅读的排版问题而开发的。与其它PDF预处理软件相比，它有很多独一无二的特性，比如自动化程度很高，能够自动识别多栏排版的文档进行分栏，自动去除页面白边，自动对扫描文档进行水平校正，以及最重要的基于图像分割的重排版算法。</p>

<p>K2pdfopt使用完全基于图像处理的方法对文字重新排版，软件处理时会把原始PDF/DJVU页面放大再分割成以词为单位的像素区域，把这些像素区域重新排列到目标宽度的页面中，所以理论上只要能够读取文档的页面像素就可以对其中的文字进行重新排版。这个算法的前提是页面中的文字之间需要有一定的空隙，以提供分割像素区域的位点。</p>

<p>K2pdfopt被移植到Koreader/Kindlepdfviewer以后就可以在阅读时让PDF重新排版。实时重排可以省去电脑上处理PDF的步骤，并且可以在kindle上交互式地微调排版参数，尽可能地生成满意的排版。使用Koreader的重排模式阅读时，软件会自动把当前页和下一页重排版成适应屏幕的尺寸。</p>

<p>安装KOrader需要先越狱，然后安装KPVBooklet。具体步骤如下</p>

<!-- more -->


<h3>Kindle越狱</h3>

<p>Kindle Paperwhite Jailbreak (5.2.0 - 5.3.1,5.3.4,5.3.5)（paperwhite越狱工具不支持5.3.3和5.3.6版本，这些版本的固件需要先进行降级，然后越狱）</p>

<p><strong>如何参看Kindle系统的版本</strong> <br/>
从主页-> 按“菜单”键 -> 然后再按“设置” -> 在设置界面再按“菜单”键 -> 按“设备信息”
<img src="http://vangie.github.com/images/post/2013-06-20/device-info.jpg" alt="设备信息" /></p>

<p>越狱步骤如下：</p>

<ol>
<li><p>用数据线将Kindle连接到电脑上</p></li>
<li><p>下载<a href="http://www.mobileread.com/forums/attachment.php?attachmentid=103175&amp;d=1363715068">kpw_jb.zip</a>文件。（需要翻墙）
讨论原帖地址：http://www.mobileread.com/forums/showthread.php?t=198446</p></li>
<li><p>解压下载好的kpw_jb.zip文件，然后把jailbreak.sh和MOBI8_DEBUG文件拷贝到Kindle根目录，将jailbreak.mobi拷贝到documents目录</p></li>
<li><p>从电脑上安全移除Kindle设备，然后断开数据线</p></li>
<li><p>你将看到一个名为“PaperWhite Jailbreak”的文档在Kindle的主页里。点击打开文档。</p></li>
<li><p>按照提示按住kindle屏幕的左上角不动，直到画面退出桌面。</p></li>
<li><p>回到桌面代表成功了，那本“Paperwhite Jailbreak”的书也不见了，越狱完成。（连接电脑后可以删除documents文件夹中越狱完成后留下个LOG文件，无影响）</p></li>
</ol>


<p>我们进行下一步骤</p>

<h3>安装KPVBooklet</h3>

<p>KPVBooklet使原生系统支持KPV的工具。</p>

<ol>
<li><p>前往 https://code.google.com/p/kpvbooklet-package/downloads/list 下载最新版本的kindle-kpvbooklet-0.4.8.zip</p></li>
<li><p>解压后通过数据线将update_kpvbooklet_0.4.8_install.bin拷贝到kindle根目录，记得安全移除kindle设备和端口数据线.(另一个文件update_kpvbooklet_0.4.8_uninstall.bin用于卸载kpvbooklet此处用不到)</p></li>
<li><p>paperwhite上点击右上角菜单>设置>再点击右上角菜单> 更新您的kindle，一阵读条等待后完成</p></li>
</ol>


<p>终于可以安装KOReader了</p>

<h3>安装KOReader</h3>

<p>KOReader是kindlepdfviewer（KPV）的延续版本，安装方法非常简单，前往https://code.google.com/p/koreader-package/downloads/list下载最新版本koreader-v2013.03-246-gaaeb347.zip。</p>

<p>解压后将“extensions”，“koreader”，“launchpad”三个目录拷贝到kindle根目录即可。</p>

<p>KOReader至此已经安装完成，通过数据线将PDF拷贝到documents目录，然后在kindle的里打开该文件就可以了。pdf的默认阅读器已经是KOReader了。如果希望使用kindle的原生阅读器看pdf文件，可以长按pdf文件，在弹出菜单里选择“前往…”。</p>

<h3>关于升级固件</h3>

<p>目前最新版本的<a href="http://www.amazon.com/gp/help/customer/display.html/ref=hp_left_sib?ie=UTF8&amp;nodeId=201064850">kindle paperwhite固件</a>版本为5.3.6。</p>

<p>将update_kindle_5.3.6.bin放置到根目录然后在设备里点击升级即可。</p>

<p>升级完成以后，需要重新安装<a href="http://www.mobileread.com/forums/showthread.php?t=152294">Kindlet developer certificates</a>和<a href="http://www.mobileread.com/forums/showthread.php?p=2290044">Rescue Pack</a>以恢复越狱效果。</p>

<p>升级后KOReader会失效，重装一遍KPVBooklet即可。</p>

<h3>参考资料</h3>

<p>[1]. <a href="http://www.douban.com/group/topic/36613341/">【越狱，KPV】kindle paperwhite越狱安装KPV教程</a> <br/>
[2]. <a href="http://vislab.bjmu.edu.cn/blog/hwangxin/2012/10/read-scanned-pdfs-with-kindlepdfviewer/">让Kindle支持扫描版PDF重排</a> <br/>
[3]. <a href="http://blog.the-ebook-reader.com/2012/10/28/kindle-paperwhite-tips-and-shortcuts-guide/">Kindle Paperwhite Tips and Shortcuts Guide</a> <br/>
[4]. <a href="http://www.douban.com/group/topic/33931176/">Kindle PaperWhite 45个小技巧</a></p>
]]></content>
  </entry>
  
</feed>
